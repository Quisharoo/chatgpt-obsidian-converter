This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  components/
    FileUploader.js
    Modal.js
    ProgressDisplay.js
    UIBuilder 2.js
    UIBuilder.js
  modules/
    applicationOrchestrator.js
    conversionEngine.js
    fileSystemManager.js
  utils/
    accessibility 2.js
    accessibility.js
    constants.js
    helpers.js
    logger.js
    strings 2.js
    strings.js
    telemetry 2.js
    telemetry.js
  main.js
test-vite-react/
  tests/
    integration/
      fullWorkflow.test.js
    unit/
      applicationOrchestrator.test.js
      conversionEngine.test.js
      fileSystemManager.test.js
      logger.test.js
      modal.test.js
      progressDisplay.test.js
      utils.test.js
    setup.js
  babel.config.cjs
  package.json
tests/
  test_python_converter.py
.cursor.json
.cursorrules
.gitignore
.vercelignore
AGENTS.md
chatgpt_converter.py
example_conversations.json
index.html
LOGGING.md
package.json
README.md
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/components/UIBuilder 2.js">
/**
 * UI Builder Module
 * Handles creation of complex UI components and cards
 * Following AGENTS.md principle: separated concerns for maintainable UI code
 */

import { getString, ui, message, success, error, info } from '../utils/strings.js';
import { getFileSystemAccessInfo, isFileSystemAccessSupported } from '../modules/fileSystemManager.js';

/**
 * UI Builder class for creating complex UI components
 * WHY: Separates UI creation logic from business logic for better maintainability
 */
export class UIBuilder {
    constructor() {
        // Store references for dynamic updates
        this.saveLocalButton = null;
        this.selectedDirectoryHandle = null;
    }

    /**
     * Set directory handle for UI updates
     * WHY: Allows UI to reflect current directory selection state
     */
    setDirectoryHandle(directoryHandle) {
        this.selectedDirectoryHandle = directoryHandle;
    }

    /**
     * Create results summary card
     * WHY: Displays conversion statistics in a clean card format
     */
    createResultsSummaryCard(results) {
        const card = document.createElement('div');
        card.className = 'bg-white rounded-xl shadow-md p-6 mb-8';
        
        const header = document.createElement('div');
        header.className = 'mb-4';
        
        const title = document.createElement('h3');
        title.className = 'text-xl font-medium text-gray-800 flex items-center mb-2';
        title.innerHTML = `
            <i class="fas fa-check-circle mr-3 text-green-500"></i>
            ${ui('CONVERSION_SUMMARY')}
        `;
        
        const description = document.createElement('p');
        description.className = 'text-gray-600';
        description.textContent = message('CONVERSION_DESCRIPTION');
        
        header.appendChild(title);
        header.appendChild(description);
        
        const content = document.createElement('div');
        content.className = '';
        
        const stats = document.createElement('div');
        stats.className = 'flex justify-center gap-4';
        
        // Create stat items - simplified to show only the main conversion result
        const statItems = [
            { 
                label: 'Conversations Converted', 
                value: results.processed, 
                icon: 'fas fa-comments text-indigo-500'
            }
        ];
        
        // Only show errors if there were any
        if (results.errors > 0) {
            statItems.push({ 
                label: 'Errors', 
                value: results.errors, 
                icon: 'fas fa-exclamation-triangle text-red-500'
            });
        }
        
        statItems.forEach(item => {
            const statCard = document.createElement('div');
            statCard.className = 'bg-gray-50 p-6 rounded-lg text-center min-w-[200px]';
            
            statCard.innerHTML = `
                <i class="${item.icon} text-3xl mb-3 block"></i>
                <div class="text-2xl font-bold text-gray-800 mb-2">${item.value}</div>
                <div class="text-base text-gray-600">${item.label}</div>
            `;
            
            stats.appendChild(statCard);
        });
        
        content.appendChild(stats);
        card.appendChild(header);
        card.appendChild(content);
        
        return card;
    }

    /**
     * Create directory selection card
     * WHY: Provides local save options with clear instructions in card format
     */
    createDirectoryCard(results, callbacks = {}) {
        const card = document.createElement('div');
        card.className = 'bg-white rounded-xl shadow-md p-6 mb-8';
        
        const header = document.createElement('div');
        header.className = 'mb-4';
        
        const title = document.createElement('h3');
        title.className = 'text-xl font-medium text-gray-800 flex items-center mb-2';
        title.innerHTML = `
            <i class="fas fa-folder mr-3 text-indigo-500"></i>
            ${ui('SAVE_LOCATION')}
        `;
        
        const description = document.createElement('p');
        description.className = 'text-gray-600';
        description.textContent = message('CHOOSE_SAVE_LOCATION');
        
        header.appendChild(title);
        header.appendChild(description);
        
        const content = document.createElement('div');
        content.className = '';
        
        if (isFileSystemAccessSupported()) {
            // Directory selection buttons
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'flex flex-col gap-3 mb-4';
            
            const selectBtn = this.createDirectoryButton(callbacks.onDirectorySelect);
            const saveBtn = this.createSaveButton(results, callbacks.onSave);
            
            buttonGroup.appendChild(selectBtn);
            buttonGroup.appendChild(saveBtn);
            content.appendChild(buttonGroup);
            
            // Instructions
            const instructions = this.createInstructions();
            content.appendChild(instructions);
            
        } else {
            const apiInfo = getFileSystemAccessInfo();
            const warning = this.createUnsupportedWarning();
            content.appendChild(warning);
            
            // Add prominent download button for mobile users
            if (apiInfo.mobile) {
                const downloadSection = this.createMobileDownloadSection(callbacks.onDownloadZip);
                content.appendChild(downloadSection);
            }
        }
        
        card.appendChild(header);
        card.appendChild(content);
        
        return card;
    }

    /**
     * Create directory selection button
     * WHY: Primary directory selection interface
     */
    createDirectoryButton(onDirectorySelect) {
        const btn = document.createElement('button');
        btn.className = 'bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-lg transition-colors flex items-center';
        
        if (this.selectedDirectoryHandle) {
            btn.innerHTML = `<i class="fas fa-folder-open mr-2"></i>${ui('CHANGE_DIRECTORY', { folderName: this.selectedDirectoryHandle.name })}`;
        } else {
            btn.innerHTML = `<i class="fas fa-folder mr-2"></i>${ui('CHOOSE_FOLDER')}`;
        }
        
        if (onDirectorySelect) {
            btn.onclick = onDirectorySelect;
        }
        
        return btn;
    }

    /**
     * Create save to local folder button
     * WHY: Main save action with visual feedback
     */
    createSaveButton(results, onSave) {
        const btn = document.createElement('button');
        
        if (this.selectedDirectoryHandle) {
            btn.className = 'bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-3 px-6 rounded-lg transition-colors flex items-center justify-center';
            btn.innerHTML = `<i class="fas fa-save mr-2"></i>${ui('SAVE_FILES_TO_FOLDER', { count: results.files.length })}`;
            btn.disabled = false;
        } else {
            btn.className = 'bg-gray-300 text-gray-500 font-medium py-3 px-6 rounded-lg cursor-not-allowed flex items-center justify-center';
            btn.innerHTML = `<i class="fas fa-save mr-2"></i>${ui('SAVE_TO_LOCAL_FOLDER')} (${info('SELECT_FOLDER_FIRST')})`;
            btn.disabled = true;
        }
        
        if (onSave) {
            btn.onclick = onSave;
        }
        
        // Store reference for updates
        this.saveLocalButton = btn;
        
        return btn;
    }

    /**
     * Create instructions element
     * WHY: Provides clear guidance for saving files
     */
    createInstructions() {
        const instructions = document.createElement('div');
        instructions.className = 'mt-3 text-sm text-gray-600 leading-normal';
        
        if (this.selectedDirectoryHandle) {
            instructions.innerHTML = `
                <div class="bg-green-50 border-l-4 border-green-500 p-3 rounded">
                    <div class="flex">
                        <div class="flex-shrink-0">
                            <i class="fas fa-check-circle text-green-500"></i>
                        </div>
                        <div class="ml-3">
                            <p class="text-sm text-green-700">
                                <strong>Ready to save</strong><br>
                                ${message('READY_TO_SAVE_DESCRIPTION', { folderName: this.selectedDirectoryHandle.name })}
                            </p>
                        </div>
                    </div>
                </div>
            `;
        } else {
            instructions.innerHTML = `
                <div class="bg-blue-50 border-l-4 border-blue-500 p-3 rounded">
                    <div class="flex">
                        <div class="flex-shrink-0">
                            <i class="fas fa-info-circle text-blue-500"></i>
                        </div>
                        <div class="ml-3">
                            <p class="text-sm text-blue-700">
                                <strong>Select your destination folder</strong><br>
                                ${message('SELECT_DESTINATION')}
                            </p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        return instructions;
    }

    /**
     * Create unsupported API warning
     * WHY: Informs users when File System Access API is unavailable
     */
    createUnsupportedWarning() {
        const apiInfo = getFileSystemAccessInfo();
        const warning = document.createElement('div');
        warning.className = 'bg-yellow-50 border-l-4 border-yellow-500 p-4 rounded mb-4';
        
        let messageText = message('MOBILE_SAVE_INFO') + ' ';
        
        if (apiInfo.mobile) {
            if (apiInfo.ios) {
                messageText += message('IOS_SAVE_INFO');
            } else {
                messageText += message('MOBILE_DOWNLOAD_INFO');
            }
        } else {
            messageText += message('MOBILE_DOWNLOAD_INFO');
        }
        
        warning.innerHTML = `
            <div class="flex items-start space-x-3">
                <div class="flex-shrink-0">
                    <i class="fas fa-exclamation-triangle text-yellow-500 mt-1"></i>
                </div>
                <div>
                    <strong class="block mb-2 text-yellow-800">${message('MOBILE_BROWSER_DETECTED')}</strong>
                    <p class="text-yellow-700 leading-normal mb-0">${messageText}</p>
                    ${apiInfo.mobile ? `
                        <div class="mt-3 p-3 bg-blue-50 border border-blue-200 rounded">
                            <strong class="block mb-1 text-blue-800"><i class="fas fa-lightbulb mr-1"></i>${message('MOBILE_TIP')}</strong>
                            <p class="text-blue-700 text-sm mb-0">${message('MOBILE_TIP_DESCRIPTION')}</p>
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
        
        return warning;
    }

    /**
     * Create mobile download section
     * WHY: Provides download options optimized for mobile devices
     */
    createMobileDownloadSection(onDownloadZip) {
        const downloadSection = document.createElement('div');
        downloadSection.className = 'mt-4';
        
        const downloadTitle = document.createElement('h4');
        downloadTitle.className = 'text-lg font-medium text-gray-800 mb-3 flex items-center';
        downloadTitle.innerHTML = `
            <i class="fas fa-download mr-2 text-indigo-500"></i>
            ${ui('DOWNLOAD_OPTIONS')}
        `;
        
        const downloadButton = document.createElement('button');
        downloadButton.className = 'bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-4 px-6 rounded-lg transition-colors w-full mb-3 flex items-center justify-center';
        downloadButton.innerHTML = `
            <i class="fas fa-download mr-3"></i>
            ${ui('DOWNLOAD_ALL_ZIP')}
        `;
        if (onDownloadZip) {
            downloadButton.onclick = onDownloadZip;
        }
        
        const downloadInfo = document.createElement('p');
        downloadInfo.className = 'text-sm text-gray-600 mb-3';
        downloadInfo.textContent = message('ZIP_ARCHIVE_INFO');
        
        downloadSection.appendChild(downloadTitle);
        downloadSection.appendChild(downloadInfo);
        downloadSection.appendChild(downloadButton);
        
        return downloadSection;
    }

    /**
     * Create file table row
     * WHY: Extracted method for cleaner code and better maintainability
     */
    createFileRow(file, callbacks = {}) {
        const row = document.createElement('tr');
        row.className = 'border-b border-gray-200 hover:bg-gray-50 transition-colors';
        
        // Fix date extraction - use multiple possible properties
        const dateCreated = this.getFileDate(file);
        
        // Title column with filename shown as subtitle - FIXED WIDTH to prevent layout shifts
        const titleCell = document.createElement('td');
        titleCell.className = 'px-4 py-3 text-gray-800 font-medium align-top';
        titleCell.style.width = '65%'; // Match header width
        
        const titleContainer = document.createElement('div');
        const titleSpan = document.createElement('div');
        titleSpan.textContent = file.title;
        titleSpan.style.wordBreak = 'break-word'; // Prevent overflow
        
        titleContainer.appendChild(titleSpan);
        titleCell.appendChild(titleContainer);
        
        // Date column - FIXED WIDTH to prevent layout shifts
        const dateCell = document.createElement('td');
        dateCell.className = 'px-4 py-3 text-gray-600 text-sm align-top whitespace-nowrap';
        dateCell.style.width = '20%'; // Match header width
        dateCell.textContent = dateCreated;
        
        // Actions column - FIXED WIDTH to prevent layout shifts
        const actionsCell = document.createElement('td');
        actionsCell.className = 'px-4 py-3 text-right align-top whitespace-nowrap';
        actionsCell.style.width = '15%'; // Match header width
        
        const actionsContainer = document.createElement('div');
        actionsContainer.className = 'flex gap-2 justify-end';
        
        // Always create Save button first, then Download button
        // This maintains consistent layout and allows individual file saving
        const saveBtn = document.createElement('button');
        saveBtn.className = 'bg-indigo-600 hover:bg-indigo-700 text-white px-2 py-1 rounded text-xs flex-shrink-0 transition-colors save-file-btn';
        saveBtn.setAttribute('data-filename', file.filename);
        saveBtn.setAttribute('data-content', encodeURIComponent(file.content));
        saveBtn.setAttribute('data-title', file.title);
        saveBtn.innerHTML = `
            <svg class="icon" style="width: 16px; height: 16px;" viewBox="0 0 24 24">
                <path d="M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z"/>
            </svg>
        `;
        actionsContainer.appendChild(saveBtn);
        
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'bg-gray-500 hover:bg-gray-600 text-white px-2 py-1 rounded text-xs flex-shrink-0 transition-colors download-file-btn';
        downloadBtn.setAttribute('data-filename', file.filename);
        downloadBtn.setAttribute('data-content', encodeURIComponent(file.content));
        downloadBtn.innerHTML = `
            <svg class="icon" style="width: 16px; height: 16px;" viewBox="0 0 24 24">
                <path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z"/>
            </svg>
        `;
        
        actionsContainer.appendChild(downloadBtn);
        
        actionsCell.appendChild(actionsContainer);
        
        row.appendChild(titleCell);
        row.appendChild(dateCell);
        row.appendChild(actionsCell);
        
        return row;
    }

    /**
     * Create pagination button
     * WHY: Creates consistent pagination button styling and behavior
     */
    createPaginationButton(text, page, isActive = false, onClick) {
        const button = document.createElement('button');
        button.textContent = text;
        button.className = `btn ${isActive ? 'btn-primary' : 'btn-secondary'}`;
        button.style.padding = 'var(--space-2) var(--space-3)';
        button.style.fontSize = 'var(--font-size-sm)';
        button.style.minWidth = '40px';
        
        if (!isActive && onClick) {
            button.addEventListener('click', () => onClick(page));
        }
        
        return button;
    }

    /**
     * Create file save confirmation dialog
     * WHY: Provides clear visual confirmation when individual files are saved
     */
    createFileSaveConfirmationDialog(fileTitle, folderName, filename) {
        // Create confirmation dialog
        const dialog = document.createElement('div');
        dialog.className = 'file-save-confirmation-dialog';
        dialog.innerHTML = `
            <div class="dialog-overlay">
                <div class="dialog-content">
                    <div class="success-icon">✅</div>
                    <h3>${success('FILE_SAVED_SUCCESS')}</h3>
                    <p><strong>${fileTitle}</strong> ${message('FILE_SAVED_TO_FOLDER', { fileTitle, folderName })}</p>
                    <p class="filename">${message('FILENAME_LABEL')} <code>${filename}</code></p>
                    <div class="dialog-buttons">
                        <button class="btn btn-primary ok-btn">${ui('OK')}</button>
                    </div>
                </div>
            </div>
        `;
        
        return dialog;
    }

    /**
     * Get properly formatted date from file object
     * WHY: Handles different date property names and formats consistently
     */
    getFileDate(file) {
        if (!file || typeof file !== 'object') {
            return 'Unknown';
        }
        
        // Try different possible date properties
        const createTime = file.createTime || file.create_time;
        
        if (createTime && !isNaN(createTime) && createTime > 0) {
            try {
                const date = new Date(createTime * 1000);
                // Check if date is valid
                if (!isNaN(date.getTime())) {
                    return date.toLocaleDateString();
                }
            } catch (error) {
                console.warn('Error formatting date:', error);
            }
        }
        
        // Fallback to createdDate if available
        if (file.createdDate && file.createdDate !== 'Unknown' && typeof file.createdDate === 'string') {
            return file.createdDate;
        }
        
        return 'Unknown';
    }

    /**
     * Update save button state based on directory selection
     * WHY: Provides visual feedback about readiness to save
     */
    updateSaveButtonState(convertedFiles) {
        if (this.saveLocalButton) {
            this.saveLocalButton.disabled = !this.selectedDirectoryHandle;
            
            if (this.selectedDirectoryHandle) {
                this.saveLocalButton.className = 'bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-3 px-6 rounded-lg transition-colors flex items-center justify-center';
                this.saveLocalButton.innerHTML = `<i class="fas fa-save mr-2"></i>${ui('SAVE_FILES_TO_FOLDER', { count: convertedFiles.length })}`;
                this.saveLocalButton.style.animation = 'pulse 2s infinite';
            } else {
                this.saveLocalButton.className = 'bg-gray-300 text-gray-500 font-medium py-3 px-6 rounded-lg cursor-not-allowed flex items-center justify-center';
                this.saveLocalButton.innerHTML = `<i class="fas fa-save mr-2"></i>${ui('SAVE_TO_LOCAL_FOLDER')} (${info('SELECT_FOLDER_FIRST')})`;
                this.saveLocalButton.style.animation = 'none';
            }
        }
    }
}

export default UIBuilder;
</file>

<file path="src/utils/accessibility 2.js">
/**
 * Accessibility Module
 * Manages accessibility features including aria-live regions for status updates
 * Following AGENTS.md principle: inclusive design and web accessibility standards
 */

import { getString } from './strings.js';

/**
 * Accessibility Manager
 * WHY: Centralized accessibility features for screen readers and assistive technologies
 */
class AccessibilityManager {
    constructor() {
        this.statusRegion = null;
        this.progressRegion = null;
        this.resultsRegion = null;
        this.initialized = false;
    }

    /**
     * Initialize accessibility features
     * WHY: Sets up aria-live regions and other a11y enhancements
     */
    initialize() {
        if (this.initialized) return;

        this.createAriaLiveRegions();
        this.enhanceExistingElements();
        this.initialized = true;
        
        console.log('♿ Accessibility features initialized');
    }

    /**
     * Create aria-live regions for dynamic content announcements
     * WHY: Screen readers need live regions to announce status changes
     */
    createAriaLiveRegions() {
        // Status region for general application status
        this.statusRegion = this.createLiveRegion('accessibility-status', 'polite');
        this.statusRegion.setAttribute('aria-label', getString('ACCESSIBILITY.STATUS_REGION_LABEL'));

        // Progress region for conversion progress updates
        this.progressRegion = this.createLiveRegion('accessibility-progress', 'polite');
        this.progressRegion.setAttribute('aria-label', getString('ACCESSIBILITY.PROGRESS_REGION_LABEL'));

        // Results region for conversion results
        this.resultsRegion = this.createLiveRegion('accessibility-results', 'polite');
        this.resultsRegion.setAttribute('aria-label', getString('ACCESSIBILITY.RESULTS_REGION_LABEL'));

        // Add to document
        document.body.appendChild(this.statusRegion);
        document.body.appendChild(this.progressRegion);
        document.body.appendChild(this.resultsRegion);
    }

    /**
     * Create a single aria-live region element
     * WHY: Reusable method for creating consistent live regions
     */
    createLiveRegion(id, politeness = 'polite') {
        const region = document.createElement('div');
        region.id = id;
        region.setAttribute('aria-live', politeness);
        region.setAttribute('aria-atomic', 'true');
        region.className = 'sr-only'; // Screen reader only
        region.style.position = 'absolute';
        region.style.left = '-10000px';
        region.style.width = '1px';
        region.style.height = '1px';
        region.style.overflow = 'hidden';
        
        return region;
    }

    /**
     * Announce status message to screen readers
     * WHY: Provides audio feedback for status changes
     */
    announceStatus(message, level = 'info') {
        if (!this.statusRegion) return;

        // Clear previous message to ensure it's announced again
        this.statusRegion.textContent = '';
        
        // Add slight delay to ensure screen readers pick up the change
        setTimeout(() => {
            const prefix = this.getAnnouncementPrefix(level);
            this.statusRegion.textContent = prefix + message;
        }, 100);
    }

    /**
     * Announce progress updates to screen readers
     * WHY: Keeps users informed of long-running operations
     */
    announceProgress(message, progress = null) {
        if (!this.progressRegion) return;

        this.progressRegion.textContent = '';
        
        setTimeout(() => {
            let announcement = message;
            if (progress !== null) {
                announcement = `${Math.round(progress)}% complete. ${message}`;
            }
            this.progressRegion.textContent = announcement;
        }, 100);
    }

    /**
     * Announce conversion results to screen readers
     * WHY: Provides completion feedback and results summary
     */
    announceResults(message) {
        if (!this.resultsRegion) return;

        this.resultsRegion.textContent = '';
        
        setTimeout(() => {
            this.resultsRegion.textContent = message;
        }, 100);
    }

    /**
     * Get appropriate prefix for announcements based on message level
     * WHY: Provides context for different types of messages
     */
    getAnnouncementPrefix(level) {
        switch (level) {
            case 'error':
                return 'Error: ';
            case 'success':
                return 'Success: ';
            case 'warning':
                return 'Warning: ';
            case 'info':
            default:
                return '';
        }
    }

    /**
     * Enhance existing elements with accessibility attributes
     * WHY: Improves navigation and usability for assistive technologies
     */
    enhanceExistingElements() {
        // Enhance file table if it exists
        this.enhanceFileTable();
        
        // Enhance sort controls
        this.enhanceSortControls();
        
        // Enhance buttons and interactive elements
        this.enhanceButtons();
        
        // Enhance form controls
        this.enhanceFormControls();
    }

    /**
     * Enhance file table with accessibility attributes
     * WHY: Makes table navigation easier for screen readers
     */
    enhanceFileTable() {
        const fileTable = document.getElementById('fileTable');
        if (fileTable) {
            // Add table caption if not present
            if (!fileTable.querySelector('caption')) {
                const caption = document.createElement('caption');
                caption.className = 'sr-only';
                caption.textContent = 'Converted files list with actions';
                fileTable.insertBefore(caption, fileTable.firstChild);
            }

            // Enhance column headers with sort info
            const titleHeader = document.getElementById('titleHeader');
            const dateHeader = document.getElementById('dateHeader');
            
            if (titleHeader) {
                titleHeader.setAttribute('tabindex', '0');
                titleHeader.setAttribute('role', 'button');
                titleHeader.setAttribute('aria-label', 'Sort by title. Click to change sort order.');
            }
            
            if (dateHeader) {
                dateHeader.setAttribute('tabindex', '0');
                dateHeader.setAttribute('role', 'button');
                dateHeader.setAttribute('aria-label', 'Sort by date created. Click to change sort order.');
            }

            // Add instructions for table usage
            const tableContainer = fileTable.closest('.card-content');
            if (tableContainer && !tableContainer.querySelector('.table-instructions')) {
                const instructions = document.createElement('div');
                instructions.className = 'sr-only table-instructions';
                instructions.textContent = getString('ACCESSIBILITY.TABLE_SORT_INFO') + '. ' + getString('ACCESSIBILITY.FILE_ACTIONS_INFO');
                tableContainer.insertBefore(instructions, fileTable);
            }
        }
    }

    /**
     * Enhance sort controls with accessibility
     * WHY: Makes sorting functionality accessible to keyboard and screen reader users
     */
    enhanceSortControls() {
        // Add keyboard navigation for column headers
        document.addEventListener('keydown', (event) => {
            if (event.target.id === 'titleHeader' || event.target.id === 'dateHeader') {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    event.target.click();
                }
            }
        });
    }

    /**
     * Enhance buttons with proper accessibility attributes
     * WHY: Ensures buttons are properly labeled and accessible
     */
    enhanceButtons() {
        // Add accessible names and states to buttons that may be missing them
        const buttons = document.querySelectorAll('button');
        buttons.forEach(button => {
            // Add role if not present
            if (!button.getAttribute('role') && button.tagName.toLowerCase() === 'button') {
                // Button elements don't need explicit role="button"
            }
            
            // Ensure buttons have accessible names
            if (!button.getAttribute('aria-label') && !button.textContent.trim() && !button.querySelector('span:not(.sr-only)')) {
                console.warn('Button without accessible name found:', button);
            }
        });
    }

    /**
     * Enhance form controls with labels and descriptions
     * WHY: Associates labels and help text with form controls
     */
    enhanceFormControls() {
        // Enhance file input
        const fileInput = document.getElementById('fileInput');
        if (fileInput) {
            fileInput.setAttribute('aria-describedby', 'file-input-help');
            
            // Add help text if not present
            if (!document.getElementById('file-input-help')) {
                const helpText = document.createElement('div');
                helpText.id = 'file-input-help';
                helpText.className = 'sr-only';
                helpText.textContent = 'Upload your ChatGPT export JSON file for conversion to Markdown format.';
                fileInput.parentNode.appendChild(helpText);
            }
        }
    }

    /**
     * Update sort indicators with accessibility announcements
     * WHY: Informs screen reader users of current sort state
     */
    updateSortAnnouncement(column, direction) {
        const message = getString('UI.CURRENT_SORT', { 
            column: column === 'title' ? 'title' : 'date', 
            direction: direction === 'asc' ? 'ascending' : 'descending' 
        });
        
        this.announceStatus(message);
    }

    /**
     * Announce file operation results
     * WHY: Provides feedback for file save/download operations
     */
    announceFileOperation(operation, success, filename = '') {
        const verb = operation === 'save' ? 'saved' : 'downloaded';
        const message = success 
            ? `File ${filename} ${verb} successfully`
            : `Failed to ${operation.slice(0, -1)} file ${filename}`;
        
        this.announceStatus(message, success ? 'success' : 'error');
    }

    /**
     * Add skip link for keyboard navigation
     * WHY: Allows keyboard users to skip to main content
     */
    addSkipLink() {
        const skipLink = document.createElement('a');
        skipLink.href = '#main-content';
        skipLink.className = 'skip-link sr-only focus:not-sr-only focus:absolute focus:top-0 focus:left-0 focus:z-50 focus:p-4 focus:bg-indigo-600 focus:text-white focus:underline';
        skipLink.textContent = 'Skip to main content';
        
        document.body.insertBefore(skipLink, document.body.firstChild);
        
        // Ensure main content has the ID
        const mainContent = document.querySelector('main') || document.querySelector('.main-content');
        if (mainContent && !mainContent.id) {
            mainContent.id = 'main-content';
        }
    }

    /**
     * Focus management for modal dialogs
     * WHY: Traps focus within modals for keyboard accessibility
     */
    trapFocus(container) {
        const focusableElements = container.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
        
        if (focusableElements.length === 0) return;
        
        const firstFocusable = focusableElements[0];
        const lastFocusable = focusableElements[focusableElements.length - 1];
        
        // Focus first element
        firstFocusable.focus();
        
        // Handle tab navigation
        container.addEventListener('keydown', (event) => {
            if (event.key === 'Tab') {
                if (event.shiftKey) {
                    // Shift + Tab
                    if (document.activeElement === firstFocusable) {
                        event.preventDefault();
                        lastFocusable.focus();
                    }
                } else {
                    // Tab
                    if (document.activeElement === lastFocusable) {
                        event.preventDefault();
                        firstFocusable.focus();
                    }
                }
            }
            
            // Close on Escape
            if (event.key === 'Escape') {
                const closeButton = container.querySelector('.ok-btn') || container.querySelector('[data-dismiss]');
                if (closeButton) {
                    closeButton.click();
                }
            }
        });
    }

    /**
     * Clean up accessibility features
     * WHY: Removes event listeners and elements when no longer needed
     */
    cleanup() {
        if (this.statusRegion) {
            document.body.removeChild(this.statusRegion);
            this.statusRegion = null;
        }
        
        if (this.progressRegion) {
            document.body.removeChild(this.progressRegion);
            this.progressRegion = null;
        }
        
        if (this.resultsRegion) {
            document.body.removeChild(this.resultsRegion);
            this.resultsRegion = null;
        }
        
        this.initialized = false;
    }
}

// Create singleton instance
const accessibilityManager = new AccessibilityManager();

// Export the instance and initialize on module load
export { accessibilityManager };
export default accessibilityManager;

// Auto-initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        accessibilityManager.initialize();
    });
} else {
    accessibilityManager.initialize();
}
</file>

<file path="src/utils/strings 2.js">
/**
 * Internationalization Strings Module
 * Centralizes all user-facing text for translation and localization
 * Following AGENTS.md principle: clean organization for maintainable i18n
 */

/**
 * Default language strings (English)
 * WHY: Centralized string management enables easy translation and consistent messaging
 */
export const STRINGS = {
    // Application Status Messages
    STATUS: {
        READING_FILE: 'Reading file...',
        PARSING_JSON: 'Parsing conversations...',
        CONVERTING: 'Converting to Markdown...',
        FINALIZING: 'Finalizing conversion...',
        COMPLETE: 'Conversion complete!',
        PREPARING_SAVE: 'Preparing to save files...',
        SAVING_FILES: 'Saving files...',
        CREATING_ZIP: 'Creating ZIP archive...'
    },

    // Error Messages
    ERRORS: {
        INVALID_JSON: 'Invalid JSON file. Please upload a valid ChatGPT export.',
        INVALID_STRUCTURE: 'Invalid file structure. Expected an array of conversations.',
        NO_DIRECTORY: 'Please select a directory first.',
        DIRECTORY_ACCESS_LOST: 'Directory access lost. Please select folder again.',
        FAILED_TO_READ_FILE: 'Failed to read file',
        FAILED_TO_INITIALIZE: 'Failed to initialize application. Please refresh the page.',
        SAVE_FAILED: 'Save failed',
        DOWNLOAD_FAILED: 'Failed to download',
        ZIP_CREATION_FAILED: 'Failed to create ZIP archive. Trying individual downloads...',
        BROWSER_NOT_SUPPORTED: "Your browser doesn't support direct file saving. Use download instead.",
        NO_FILES_TO_SAVE: 'No files available to save'
    },

    // Success Messages
    SUCCESS: {
        CONVERSION_COMPLETE: 'Conversion completed successfully!',
        FILES_SAVED: 'files saved',
        FILES_DOWNLOADED: 'Downloaded',
        DIRECTORY_SELECTED: 'Selected directory',
        READY_TO_SAVE: 'Now click "Save to Local Folder" to save your files!',
        FILE_SAVED_SUCCESS: 'File Saved Successfully!',
        CHECK_FOLDER: 'SUCCESS! Check your {folderName} folder for the files',
        NEW_FILES_SAVED: 'SUCCESS! {count} new files saved. {duplicates} existing files left unchanged.',
        ALL_FILES_SAVED: 'SUCCESS! All {count} files saved. {duplicates} files were overwritten.'
    },

    // Information Messages
    INFO: {
        SELECT_FOLDER_FIRST: 'Select folder first',
        SAVE_CANCELLED: 'File save cancelled',
        SAVE_OPERATION_CANCELLED: 'Save operation cancelled',
        ALL_FILES_EXISTED: 'All files already existed and were skipped. No new files to save.',
        ALL_SAVES_CANCELLED: 'All {count} file saves were cancelled',
        CHOOSE_SAVE_LOCATION: 'Choose where to save "{filename}"',
        PREPARING_FILES: 'Preparing to save {count} files to {folderName} folder...',
        ZIP_NOT_AVAILABLE: 'ZIP download not available. Downloading files individually...'
    },

    // UI Labels and Buttons
    UI: {
        // Buttons
        CHOOSE_FOLDER: 'Choose Folder',
        CHANGE_DIRECTORY: 'Change Directory (Current: {folderName})',
        SAVE_TO_LOCAL_FOLDER: 'Save to Local Folder',
        SAVE_FILES_TO_FOLDER: 'Save {count} files to selected folder',
        DOWNLOAD_ALL_ZIP: 'Download All as ZIP',
        DOWNLOAD_INDIVIDUAL: 'Download files individually',
        OK: 'OK',
        
        // Headers and Titles
        CONVERSION_SUMMARY: 'Conversion Summary',
        SAVE_LOCATION: 'Save Location',
        DOWNLOAD_OPTIONS: 'Download Options',
        
        // Table Headers
        FILE_TITLE: 'Title',
        DATE_CREATED: 'Date Created',
        ACTIONS: 'Actions',
        
        // Status and Progress
        SHOWING_FILES: 'Showing {start}-{end} of {total} files',
        NO_FILES_AVAILABLE: 'No files available',
        
        // Icons and Visual Elements
        LOADING: 'Loading...',
        PROCESSING: 'Processing...',
        
        // Accessibility
        SORT_ASCENDING: 'Sort ascending',
        SORT_DESCENDING: 'Sort descending',
        CURRENT_SORT: 'Currently sorted by {column} {direction}'
    },

    // Detailed Messages and Descriptions
    MESSAGES: {
        CONVERSION_DESCRIPTION: 'Your ChatGPT conversations have been successfully converted',
        CHOOSE_SAVE_LOCATION: 'Choose where to save your converted files',
        READY_TO_SAVE_DESCRIPTION: 'Selected folder: {folderName}. Click "Save to Local Folder" to save all files directly to your chosen location.',
        SELECT_DESTINATION: 'Select your destination folder. Choose where you want to save your converted Markdown files.',
        
        // Mobile/Browser Compatibility
        MOBILE_BROWSER_DETECTED: 'Mobile Browser Detected',
        MOBILE_SAVE_INFO: 'Your browser doesn\'t support direct folder saving.',
        MOBILE_DOWNLOAD_INFO: 'On mobile devices, use the download options below to save your files.',
        IOS_SAVE_INFO: 'On iOS devices, use the download options below to save your files. You can then move them to your preferred folder using the Files app.',
        MOBILE_TIP: 'Mobile Tip:',
        MOBILE_TIP_DESCRIPTION: 'Download all files as a ZIP archive for easier file management on your device.',
        ZIP_ARCHIVE_INFO: 'Download all converted files as a single ZIP archive for easy file management.',
        
        // File Save Confirmation
        FILE_SAVED_TO_FOLDER: '{fileTitle} has been saved to the {folderName} folder.',
        FILENAME_LABEL: 'Filename:',
        
        // Processing Messages
        INITIALIZING_CONVERTER: 'ChatGPT to Markdown Converter initialized',
        FILE_SYSTEM_API_AVAILABLE: 'File System Access API: Available',
        FILE_SYSTEM_API_NOT_AVAILABLE: 'File System Access API: Not available',
        PROCESSING_FILE: 'Processing file: {fileName} ({fileSize} bytes)',
        FILES_VIEW_POPULATED: 'Files view populated with {count} files',
        FILES_TABLE_RENDERED: 'Files table rendered: {count} files on page {page} of {totalPages}'
    },

    // Telemetry and Analytics
    TELEMETRY: {
        SESSION_INITIALIZED: 'Telemetry collector initialized',
        EVENT_TRACKED: 'Event tracked: {eventName}',
        SIGNIFICANT_EVENT: 'Significant event: {eventName}'
    },

    // Accessibility
    ACCESSIBILITY: {
        STATUS_REGION_LABEL: 'Application status updates',
        PROGRESS_REGION_LABEL: 'Conversion progress updates',
        RESULTS_REGION_LABEL: 'Conversion results',
        TABLE_SORT_INFO: 'Click column headers to sort',
        FILE_ACTIONS_INFO: 'Use Save button to choose location or Download for immediate download'
    }
};

/**
 * String interpolation helper
 * WHY: Enables dynamic content in translated strings
 * 
 * @param {string} template - String template with {placeholder} syntax
 * @param {Object} values - Object with placeholder values
 * @returns {string} - Interpolated string
 */
export function interpolate(template, values = {}) {
    if (!template || typeof template !== 'string') {
        return template;
    }
    
    return template.replace(/\{(\w+)\}/g, (match, key) => {
        return values.hasOwnProperty(key) ? values[key] : match;
    });
}

/**
 * Get localized string with optional interpolation
 * WHY: Central function for all string retrieval with future localization support
 * 
 * @param {string} key - Dot-notation key (e.g., 'STATUS.READING_FILE')
 * @param {Object} values - Optional interpolation values
 * @returns {string} - Localized string
 */
export function getString(key, values = {}) {
    const keys = key.split('.');
    let result = STRINGS;
    
    for (const k of keys) {
        if (result && typeof result === 'object' && k in result) {
            result = result[k];
        } else {
            console.warn(`String key not found: ${key}`);
            return key; // Return key as fallback
        }
    }
    
    if (typeof result !== 'string') {
        console.warn(`String key does not point to a string: ${key}`);
        return key;
    }
    
    return interpolate(result, values);
}

/**
 * Pluralization helper
 * WHY: Handle singular/plural forms for different languages
 * 
 * @param {number} count - Number for pluralization
 * @param {string} singular - Singular form
 * @param {string} plural - Plural form (optional, defaults to singular + 's')
 * @returns {string} - Correctly pluralized string
 */
export function pluralize(count, singular, plural = null) {
    if (count === 1) {
        return singular;
    }
    return plural || (singular + 's');
}

/**
 * Format file size for display
 * WHY: Consistent file size formatting with localization support
 * 
 * @param {number} bytes - File size in bytes
 * @returns {string} - Formatted file size
 */
export function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Format numbers with locale-aware formatting
 * WHY: Consistent number formatting across the application
 * 
 * @param {number} number - Number to format
 * @param {string} locale - Locale for formatting (defaults to browser locale)
 * @returns {string} - Formatted number
 */
export function formatNumber(number, locale = navigator.language) {
    return new Intl.NumberFormat(locale).format(number);
}

/**
 * Future: Load locale-specific strings
 * WHY: Enable runtime language switching
 * 
 * @param {string} locale - Locale code (e.g., 'es', 'fr', 'de')
 * @returns {Promise<Object>} - Locale-specific strings
 */
export async function loadLocale(locale) {
    // Placeholder for future locale loading
    // Could load from JSON files, API endpoints, etc.
    console.log(`Loading locale: ${locale} (not implemented yet)`);
    return STRINGS; // Return default for now
}

// Export commonly used string getters for convenience
export const status = (key, values) => getString(`STATUS.${key}`, values);
export const error = (key, values) => getString(`ERRORS.${key}`, values);
export const success = (key, values) => getString(`SUCCESS.${key}`, values);
export const info = (key, values) => getString(`INFO.${key}`, values);
export const ui = (key, values) => getString(`UI.${key}`, values);
export const message = (key, values) => getString(`MESSAGES.${key}`, values);

export default STRINGS;
</file>

<file path="src/utils/telemetry 2.js">
/**
 * Telemetry Module
 * Tracks user interactions and conversion metrics for analytics
 * Following AGENTS.md principle: clean, minimal implementation without large dependencies
 */

import { logInfo, logDebug, logWarn } from './logger.js';

/**
 * Telemetry Events Configuration
 * WHY: Central definition of all trackable events
 */
const TELEMETRY_EVENTS = {
    // Conversion Events
    CONVERSION_STARTED: 'conversion_started',
    CONVERSION_COMPLETED: 'conversion_completed', 
    CONVERSION_FAILED: 'conversion_failed',
    
    // File Events
    FILE_UPLOADED: 'file_uploaded',
    FILES_SAVED_LOCAL: 'files_saved_local',
    FILES_DOWNLOADED_ZIP: 'files_downloaded_zip',
    FILE_DOWNLOADED_INDIVIDUAL: 'file_downloaded_individual',
    FILE_SAVED_INDIVIDUAL: 'file_saved_individual',
    
    // User Actions
    DIRECTORY_SELECTED: 'directory_selected',
    SAVE_CANCELLED: 'save_cancelled',
    
    // Errors
    PARSE_ERROR: 'parse_error',
    SAVE_ERROR: 'save_error',
    FILESYSTEM_ERROR: 'filesystem_error',
    
    // Performance
    CONVERSION_TIME: 'conversion_time',
    SAVE_TIME: 'save_time'
};

/**
 * Simple telemetry collector
 * WHY: Tracks user interactions and performance metrics for product improvement
 */
class TelemetryCollector {
    constructor() {
        this.sessionId = this.generateSessionId();
        this.events = [];
        this.sessionStartTime = Date.now();
        
        // Track session metadata
        this.sessionMetadata = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            timestamp: new Date().toISOString(),
            fileSystemApiSupported: 'showDirectoryPicker' in window
        };
        
        logDebug('📊 Telemetry collector initialized', { sessionId: this.sessionId });
    }
    
    /**
     * Generate unique session ID
     * WHY: Track user sessions for analytics aggregation
     */
    generateSessionId() {
        return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    
    /**
     * Track an event with optional data
     * WHY: Central method for all event tracking
     * 
     * @param {string} eventName - Event name from TELEMETRY_EVENTS
     * @param {Object} data - Optional event data
     */
    track(eventName, data = {}) {
        const event = {
            sessionId: this.sessionId,
            event: eventName,
            timestamp: Date.now(),
            data: { ...data },
            sessionTime: Date.now() - this.sessionStartTime
        };
        
        this.events.push(event);
        logDebug(`📊 Event tracked: ${eventName}`, event);
        
        // Send to analytics service if configured
        this.sendToAnalytics(event);
    }
    
    /**
     * Track conversion metrics
     * WHY: Measure conversion success rates and performance
     */
    trackConversionStarted(fileSize, fileName) {
        this.track(TELEMETRY_EVENTS.CONVERSION_STARTED, {
            fileSize,
            fileName: fileName ? fileName.replace(/[^a-zA-Z0-9.]/g, '') : 'unknown', // Sanitize
            fileSizeCategory: this.getFileSizeCategory(fileSize)
        });
    }
    
    trackConversionCompleted(conversationsCount, filesCount, processingTime, errorsCount = 0) {
        this.track(TELEMETRY_EVENTS.CONVERSION_COMPLETED, {
            conversationsCount,
            filesCount,
            processingTime,
            errorsCount,
            successRate: errorsCount > 0 ? (conversationsCount - errorsCount) / conversationsCount : 1,
            performanceCategory: this.getPerformanceCategory(processingTime)
        });
    }
    
    trackConversionFailed(error, stage) {
        this.track(TELEMETRY_EVENTS.CONVERSION_FAILED, {
            error: error.message,
            errorType: error.name,
            stage, // 'parsing', 'conversion', 'processing'
            stack: error.stack ? error.stack.substring(0, 500) : null // Truncate for privacy
        });
    }
    
    /**
     * Track file operations
     * WHY: Understand user preferences and success rates for different save methods
     */
    trackFilesSaved(method, count, successCount, processingTime) {
        const eventName = method === 'local' ? TELEMETRY_EVENTS.FILES_SAVED_LOCAL : TELEMETRY_EVENTS.FILES_DOWNLOADED_ZIP;
        this.track(eventName, {
            totalFiles: count,
            successfulFiles: successCount,
            failedFiles: count - successCount,
            processingTime,
            successRate: successCount / count
        });
    }
    
    trackIndividualFileAction(action, success = true, error = null) {
        const eventName = action === 'save' ? TELEMETRY_EVENTS.FILE_SAVED_INDIVIDUAL : TELEMETRY_EVENTS.FILE_DOWNLOADED_INDIVIDUAL;
        this.track(eventName, {
            success,
            error: error ? error.message : null
        });
    }
    
    /**
     * Track user actions
     * WHY: Understand user behavior and workflow patterns
     */
    trackDirectorySelected() {
        this.track(TELEMETRY_EVENTS.DIRECTORY_SELECTED);
    }
    
    trackSaveCancelled(stage, progress) {
        this.track(TELEMETRY_EVENTS.SAVE_CANCELLED, {
            stage, // 'selection', 'progress'
            progress // percentage when cancelled
        });
    }
    
    /**
     * Track errors for debugging and improvement
     * WHY: Identify common failure points and improve user experience
     */
    trackError(errorType, error, context = {}) {
        let eventName;
        switch (errorType) {
            case 'parse':
                eventName = TELEMETRY_EVENTS.PARSE_ERROR;
                break;
            case 'save':
                eventName = TELEMETRY_EVENTS.SAVE_ERROR;
                break;
            case 'filesystem':
                eventName = TELEMETRY_EVENTS.FILESYSTEM_ERROR;
                break;
            default:
                eventName = 'unknown_error';
        }
        
        this.track(eventName, {
            error: error.message,
            errorType: error.name,
            context,
            stack: error.stack ? error.stack.substring(0, 500) : null
        });
    }
    
    /**
     * Get file size category for analytics grouping
     * WHY: Understand performance patterns across different file sizes
     */
    getFileSizeCategory(size) {
        if (size < 1024 * 100) return 'small'; // < 100KB
        if (size < 1024 * 1024) return 'medium'; // < 1MB
        if (size < 1024 * 1024 * 10) return 'large'; // < 10MB
        return 'xlarge'; // >= 10MB
    }
    
    /**
     * Get performance category for analytics grouping
     * WHY: Understand performance characteristics
     */
    getPerformanceCategory(timeMs) {
        if (timeMs < 1000) return 'fast'; // < 1s
        if (timeMs < 5000) return 'normal'; // < 5s
        if (timeMs < 15000) return 'slow'; // < 15s
        return 'very_slow'; // >= 15s
    }
    
    /**
     * Send event to analytics service
     * WHY: Enable real analytics collection when service is configured
     */
    sendToAnalytics(event) {
        // Placeholder for analytics service integration
        // Could integrate with Google Analytics, Mixpanel, custom endpoint, etc.
        
        // For now, just log significant events
        if (this.isSignificantEvent(event.event)) {
            logInfo(`📊 Significant event: ${event.event}`, event.data);
        }
    }
    
    /**
     * Check if event is significant for logging
     * WHY: Reduce noise while tracking important events
     */
    isSignificantEvent(eventName) {
        return [
            TELEMETRY_EVENTS.CONVERSION_COMPLETED,
            TELEMETRY_EVENTS.CONVERSION_FAILED,
            TELEMETRY_EVENTS.FILES_SAVED_LOCAL,
            TELEMETRY_EVENTS.FILES_DOWNLOADED_ZIP,
            TELEMETRY_EVENTS.PARSE_ERROR,
            TELEMETRY_EVENTS.SAVE_ERROR
        ].includes(eventName);
    }
    
    /**
     * Get session summary for debugging
     * WHY: Provide session overview for troubleshooting
     */
    getSessionSummary() {
        const summary = {
            sessionId: this.sessionId,
            duration: Date.now() - this.sessionStartTime,
            eventCount: this.events.length,
            metadata: this.sessionMetadata,
            eventsByType: {}
        };
        
        // Count events by type
        this.events.forEach(event => {
            summary.eventsByType[event.event] = (summary.eventsByType[event.event] || 0) + 1;
        });
        
        return summary;
    }
    
    /**
     * Export events for analytics (if needed)
     * WHY: Allow data export for external analytics tools
     */
    exportEvents() {
        return {
            session: this.sessionMetadata,
            events: this.events,
            summary: this.getSessionSummary()
        };
    }
}

// Create singleton instance
const telemetry = new TelemetryCollector();

// Export telemetry instance and events constants
export { telemetry, TELEMETRY_EVENTS };
export default telemetry;
</file>

<file path="src/components/Modal.js">
/**
 * Modal Component
 * Simple confirmation modal to replace system dialogs
 * Following AGENTS.md principle: clean separation of concerns and accessibility
 */

import { logInfo, logWarn } from '../utils/logger.js';

/**
 * Modal Component Class
 * WHY: Encapsulates modal dialog logic with full accessibility support
 */
export class Modal {
    constructor(options = {}) {
        this.id = options.id || `modal-${Date.now()}`;
        this.title = options.title || '';
        this.content = options.content || '';
        this.buttons = options.buttons || [];
        this.onClose = options.onClose || null;
        this.onConfirm = options.onConfirm || null;
        this.allowEscape = options.allowEscape !== false; // Default true
        this.allowClickOutside = options.allowClickOutside !== false; // Default true
        this.autoFocus = options.autoFocus !== false; // Default true
        
        this.element = null;
        this.overlay = null;
        this.contentElement = null;
        this.isVisible = false;
        this.isInitialized = false;
    }

    /**
     * Create modal DOM structure
     * WHY: Builds accessible modal with proper ARIA attributes
     */
    createModalElement() {
        const modal = document.createElement('div');
        modal.className = 'custom-modal';
        modal.id = this.id;
        modal.setAttribute('role', 'dialog');
        modal.setAttribute('aria-modal', 'true');
        modal.setAttribute('aria-labelledby', `${this.id}-title`);
        modal.setAttribute('aria-describedby', `${this.id}-content`);
        
        // Simple confirmation icon
        const icon = `<svg class="modal-icon" viewBox="0 0 24 24">
            <path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M10,17L5,12L6.41,10.59L10,14.17L17.59,6.58L19,8L10,17Z"/>
        </svg>`;
        
        modal.innerHTML = `
            <div class="modal-overlay">
                <div class="modal-container">
                    <div class="modal-header">
                        <div class="modal-title-section">
                            ${icon}
                            <h2 class="modal-title" id="${this.id}-title">${this.title}</h2>
                        </div>
                        <button class="modal-close-btn" aria-label="Close dialog">
                            <svg viewBox="0 0 24 24">
                                <path d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z"/>
                            </svg>
                        </button>
                    </div>
                    <div class="modal-content" id="${this.id}-content">
                        ${this.content}
                    </div>
                    <div class="modal-footer">
                        ${this.buttons.map((button, index) => `
                            <button class="btn ${button.class || 'btn-secondary'}" 
                                    data-action="${button.action || 'close'}"
                                    ${button.primary ? 'data-primary="true"' : ''}>
                                ${button.icon ? `<svg class="icon" viewBox="0 0 24 24">${button.icon}</svg>` : ''}
                                ${button.text}
                            </button>
                        `).join('')}
                    </div>
                </div>
            </div>
        `;
        
        return modal;
    }

    /**
     * Add modal styles to document
     * WHY: Ensures consistent styling across all modals
     */
    addModalStyles() {
        if (document.getElementById('customModalStyles')) return;
        
        const style = document.createElement('style');
        style.id = 'customModalStyles';
        style.textContent = `
            .custom-modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 100000;
                display: flex;
                align-items: center;
                justify-content: center;
                opacity: 0;
                visibility: hidden;
                transition: all 0.3s ease;
            }
            
            .custom-modal.show {
                opacity: 1;
                visibility: visible;
            }
            
            .custom-modal .modal-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(3px);
                display: flex;
                align-items: center;
                justify-content: center;
                padding: var(--space-4);
            }
            
            .custom-modal .modal-container {
                background: var(--bg-card);
                border: 1px solid var(--border-primary);
                border-radius: var(--radius-lg);
                box-shadow: var(--shadow-lg);
                max-width: 500px;
                width: 100%;
                max-height: 80vh;
                overflow: hidden;
                transform: scale(0.9) translateY(-20px);
                transition: transform 0.3s ease;
                animation: modalSlideIn 0.3s ease-out;
            }
            
            .custom-modal.show .modal-container {
                transform: scale(1) translateY(0);
            }
            
            @keyframes modalSlideIn {
                from {
                    opacity: 0;
                    transform: scale(0.9) translateY(-20px);
                }
                to {
                    opacity: 1;
                    transform: scale(1) translateY(0);
                }
            }
            
            .custom-modal .modal-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: var(--space-5) var(--space-6);
                border-bottom: 1px solid var(--border-primary);
            }
            
            .custom-modal .modal-title-section {
                display: flex;
                align-items: center;
                gap: var(--space-3);
            }
            
            .custom-modal .modal-icon {
                width: 24px;
                height: 24px;
                flex-shrink: 0;
                color: var(--accent-primary);
            }
            

            
            .custom-modal .modal-title {
                font-size: var(--font-size-lg);
                font-weight: var(--font-weight-semibold);
                color: var(--text-primary);
                margin: 0;
            }
            
            .custom-modal .modal-close-btn {
                background: transparent;
                border: none;
                color: var(--text-secondary);
                cursor: pointer;
                padding: var(--space-2);
                border-radius: var(--radius-sm);
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .custom-modal .modal-close-btn:hover {
                background: var(--bg-tertiary);
                color: var(--text-primary);
            }
            
            .custom-modal .modal-close-btn svg {
                width: 20px;
                height: 20px;
            }
            
            .custom-modal .modal-content {
                padding: var(--space-6);
                color: var(--text-primary);
                line-height: var(--line-height-normal);
                overflow-y: auto;
                max-height: 60vh;
            }
            
            .custom-modal .modal-content p {
                margin: 0 0 var(--space-3) 0;
            }
            
            .custom-modal .modal-content p:last-child {
                margin-bottom: 0;
            }
            
            .custom-modal .modal-footer {
                display: flex;
                gap: var(--space-3);
                justify-content: flex-end;
                padding: var(--space-5) var(--space-6);
                border-top: 1px solid var(--border-primary);
                background: var(--bg-secondary);
            }
            
            .custom-modal .modal-footer .btn {
                min-width: 80px;
                justify-content: center;
            }
            
            .custom-modal .modal-footer .btn[data-primary="true"] {
                order: -1;
            }
            
            /* Responsive design */
            @media (max-width: 768px) {
                .custom-modal .modal-overlay {
                    padding: var(--space-3);
                }
                
                .custom-modal .modal-container {
                    max-width: none;
                    margin: var(--space-2);
                }
                
                .custom-modal .modal-header,
                .custom-modal .modal-content,
                .custom-modal .modal-footer {
                    padding: var(--space-4);
                }
                
                .custom-modal .modal-footer {
                    flex-direction: column;
                }
                
                .custom-modal .modal-footer .btn {
                    width: 100%;
                }
            }
            
            /* Reduced motion support */
            @media (prefers-reduced-motion: reduce) {
                .custom-modal,
                .custom-modal .modal-container {
                    transition: none;
                    animation: none;
                }
            }
        `;
        
        document.head.appendChild(style);
    }

    /**
     * Initialize modal
     * WHY: Sets up modal structure and event listeners
     */
    initialize() {
        if (this.isInitialized) return;
        
        this.addModalStyles();
        this.element = this.createModalElement();
        this.overlay = this.element.querySelector('.modal-overlay');
        this.contentElement = this.element.querySelector('.modal-content');
        
        this.attachEventListeners();
        this.isInitialized = true;
        
        logInfo(`✅ Modal '${this.id}' initialized`);
    }

    /**
     * Attach event listeners
     * WHY: Handles user interactions and accessibility
     */
    attachEventListeners() {
        // Close button
        const closeBtn = this.element.querySelector('.modal-close-btn');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => this.close());
        }
        
        // Overlay click
        if (this.allowClickOutside && this.overlay) {
            this.overlay.addEventListener('click', (e) => {
                if (e.target === this.overlay) {
                    this.close();
                }
            });
        }
        
        // Escape key
        if (this.allowEscape) {
            const handleKeyDown = (e) => {
                if (e.key === 'Escape' && this.isVisible) {
                    e.preventDefault();
                    this.close();
                }
            };
            document.addEventListener('keydown', handleKeyDown);
            
            // Store reference for cleanup
            this._keyDownHandler = handleKeyDown;
        }
        
        // Button clicks
        const buttons = this.element.querySelectorAll('.modal-footer .btn');
        buttons.forEach(button => {
            button.addEventListener('click', (e) => {
                const action = button.dataset.action;
                this.handleButtonClick(action, e);
            });
        });
    }

    /**
     * Handle button click
     * WHY: Processes user actions and calls appropriate callbacks
     * 
     * @param {string} action - Button action
     * @param {Event} event - Click event
     */
    handleButtonClick(action, event) {
        event.preventDefault();
        
        switch (action) {
            case 'confirm':
                if (this.onConfirm && typeof this.onConfirm === 'function') {
                    this.onConfirm();
                }
                this.close();
                break;
            case 'cancel':
                this.close();
                break;
            default:
                this.close();
                break;
        }
    }

    /**
     * Show modal
     * WHY: Displays modal with proper focus management
     */
    show() {
        if (!this.isInitialized) {
            this.initialize();
        }
        
        // Add to document
        document.body.appendChild(this.element);
        
        // Show modal
        requestAnimationFrame(() => {
            this.element.classList.add('show');
            this.isVisible = true;
            
            // Focus management
            if (this.autoFocus) {
                const primaryButton = this.element.querySelector('.btn[data-primary="true"]');
                const firstButton = this.element.querySelector('.modal-footer .btn');
                const focusTarget = primaryButton || firstButton;
                
                if (focusTarget) {
                    setTimeout(() => focusTarget.focus(), 100);
                }
            }
            
            // Trap focus within modal
            this.trapFocus();
        });
        
        logInfo(`✅ Modal '${this.id}' shown`);
    }

    /**
     * Close modal
     * WHY: Hides modal and cleans up resources
     */
    close() {
        if (!this.isVisible) return;
        
        this.element.classList.remove('show');
        this.isVisible = false;
        
        // Remove from document after animation
        setTimeout(() => {
            if (this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
            
            // Restore focus to previous element
            if (this._previousFocusElement) {
                this._previousFocusElement.focus();
            }
            
            // Call onClose callback
            if (this.onClose && typeof this.onClose === 'function') {
                this.onClose();
            }
        }, 300);
        
        logInfo(`✅ Modal '${this.id}' closed`);
    }

    /**
     * Trap focus within modal
     * WHY: Ensures keyboard navigation stays within modal
     */
    trapFocus() {
        const focusableElements = this.element.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
        
        if (focusableElements.length === 0) return;
        
        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];
        
        // Store current focus for restoration
        this._previousFocusElement = document.activeElement;
        
        const handleTabKey = (e) => {
            if (e.key === 'Tab') {
                if (e.shiftKey) {
                    if (document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    }
                } else {
                    if (document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                }
            }
        };
        
        this.element.addEventListener('keydown', handleTabKey);
        this._tabKeyHandler = handleTabKey;
    }

    /**
     * Update modal content
     * WHY: Allows dynamic content updates
     * 
     * @param {string} content - New content HTML
     */
    updateContent(content) {
        this.content = content;
        if (this.contentElement) {
            this.contentElement.innerHTML = content;
        }
    }

    /**
     * Clean up modal resources
     * WHY: Prevents memory leaks
     */
    destroy() {
        if (this._keyDownHandler) {
            document.removeEventListener('keydown', this._keyDownHandler);
        }
        if (this._tabKeyHandler) {
            this.element.removeEventListener('keydown', this._tabKeyHandler);
        }
        
        if (this.element && this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
        }
        
        this.isInitialized = false;
        this.isVisible = false;
        
        logInfo(`✅ Modal '${this.id}' destroyed`);
    }
}

/**
 * Show confirmation modal
 * WHY: Provides easy way to get user confirmation
 * 
 * @param {string} title - Modal title
 * @param {string} message - Modal message
 * @param {Object} options - Additional options
 * @returns {Promise<boolean>} - Resolves to true if confirmed, false if cancelled
 */
export function showConfirmModal(title, message, options = {}) {
    return new Promise((resolve) => {
        const modal = new Modal({
            title,
            content: `<p>${message}</p>`,
            buttons: [
                {
                    text: options.cancelText || 'Cancel',
                    action: 'cancel',
                    class: 'btn-secondary'
                },
                {
                    text: options.confirmText || 'Confirm',
                    action: 'confirm',
                    primary: true
                }
            ],
            onConfirm: () => resolve(true),
            onClose: () => resolve(false)
        });
        
        modal.show();
    });
}
</file>

<file path="src/components/UIBuilder.js">
/**
 * UI Builder Module
 * Handles creation of complex UI components and cards
 * Following AGENTS.md principle: separated concerns for maintainable UI code
 */

import { getString, ui, message, success, error, info } from '../utils/strings.js';
import { getFileSystemAccessInfo, isFileSystemAccessSupported } from '../modules/fileSystemManager.js';

/**
 * UI Builder class for creating complex UI components
 * WHY: Separates UI creation logic from business logic for better maintainability
 */
export class UIBuilder {
    constructor() {
        // Store references for dynamic updates
        this.saveLocalButton = null;
        this.selectedDirectoryHandle = null;
    }

    /**
     * Set directory handle for UI updates
     * WHY: Allows UI to reflect current directory selection state
     */
    setDirectoryHandle(directoryHandle) {
        this.selectedDirectoryHandle = directoryHandle;
    }

    /**
     * Create results summary card
     * WHY: Displays conversion statistics in a clean card format
     */
    createResultsSummaryCard(results) {
        const card = document.createElement('div');
        card.className = 'bg-white rounded-xl shadow-md p-6 mb-8';
        
        const header = document.createElement('div');
        header.className = 'mb-4';
        
        const title = document.createElement('h3');
        title.className = 'text-xl font-medium text-gray-800 flex items-center mb-2';
        title.innerHTML = `
            <i class="fas fa-check-circle mr-3 text-green-500"></i>
            ${ui('CONVERSION_SUMMARY')}
        `;
        
        const description = document.createElement('p');
        description.className = 'text-gray-600';
        description.textContent = message('CONVERSION_DESCRIPTION');
        
        header.appendChild(title);
        header.appendChild(description);
        
        const content = document.createElement('div');
        content.className = '';
        
        const stats = document.createElement('div');
        stats.className = 'flex justify-center gap-4';
        
        // Create stat items - simplified to show only the main conversion result
        const statItems = [
            { 
                label: 'Conversations Converted', 
                value: results.processed, 
                icon: 'fas fa-comments text-indigo-500'
            }
        ];
        
        // Only show errors if there were any
        if (results.errors > 0) {
            statItems.push({ 
                label: 'Errors', 
                value: results.errors, 
                icon: 'fas fa-exclamation-triangle text-red-500'
            });
        }
        
        statItems.forEach(item => {
            const statCard = document.createElement('div');
            statCard.className = 'bg-gray-50 p-6 rounded-lg text-center min-w-[200px]';
            
            statCard.innerHTML = `
                <i class="${item.icon} text-3xl mb-3 block"></i>
                <div class="text-2xl font-bold text-gray-800 mb-2">${item.value}</div>
                <div class="text-base text-gray-600">${item.label}</div>
            `;
            
            stats.appendChild(statCard);
        });
        
        content.appendChild(stats);
        card.appendChild(header);
        card.appendChild(content);
        
        return card;
    }

    /**
     * Create directory selection card
     * WHY: Provides local save options with clear instructions in card format
     */
    createDirectoryCard(results, callbacks = {}) {
        const card = document.createElement('div');
        card.className = 'bg-white rounded-xl shadow-md p-6 mb-8';
        
        const header = document.createElement('div');
        header.className = 'mb-4';
        
        const title = document.createElement('h3');
        title.className = 'text-xl font-medium text-gray-800 flex items-center mb-2';
        title.innerHTML = `
            <i class="fas fa-folder mr-3 text-indigo-500"></i>
            ${ui('SAVE_LOCATION')}
        `;
        
        const description = document.createElement('p');
        description.className = 'text-gray-600';
        description.textContent = message('CHOOSE_SAVE_LOCATION');
        
        header.appendChild(title);
        header.appendChild(description);
        
        const content = document.createElement('div');
        content.className = '';
        
        if (isFileSystemAccessSupported()) {
            // Directory selection buttons
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'flex flex-col gap-3 mb-4';
            
            const selectBtn = this.createDirectoryButton(callbacks.onDirectorySelect);
            const saveBtn = this.createSaveButton(results, callbacks.onSave);
            
            buttonGroup.appendChild(selectBtn);
            buttonGroup.appendChild(saveBtn);
            content.appendChild(buttonGroup);
            
            // Instructions
            const instructions = this.createInstructions();
            content.appendChild(instructions);
            
        } else {
            const apiInfo = getFileSystemAccessInfo();
            const warning = this.createUnsupportedWarning();
            content.appendChild(warning);
            
            // Add prominent download button for mobile users
            if (apiInfo.mobile) {
                const downloadSection = this.createMobileDownloadSection(callbacks.onDownloadZip);
                content.appendChild(downloadSection);
            }
        }
        
        card.appendChild(header);
        card.appendChild(content);
        
        return card;
    }

    /**
     * Create directory selection button
     * WHY: Primary directory selection interface
     */
    createDirectoryButton(onDirectorySelect) {
        const btn = document.createElement('button');
        btn.className = 'bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-lg transition-colors flex items-center';
        
        if (this.selectedDirectoryHandle) {
            btn.innerHTML = `<i class="fas fa-folder-open mr-2"></i>${ui('CHANGE_DIRECTORY', { folderName: this.selectedDirectoryHandle.name })}`;
        } else {
            btn.innerHTML = `<i class="fas fa-folder mr-2"></i>${ui('CHOOSE_FOLDER')}`;
        }
        
        if (onDirectorySelect) {
            btn.onclick = onDirectorySelect;
        }
        
        return btn;
    }

    /**
     * Create save to local folder button
     * WHY: Main save action with visual feedback
     */
    createSaveButton(results, onSave) {
        const btn = document.createElement('button');
        
        if (this.selectedDirectoryHandle) {
            btn.className = 'bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-3 px-6 rounded-lg transition-colors flex items-center justify-center';
            btn.innerHTML = `<i class="fas fa-save mr-2"></i>${ui('SAVE_FILES_TO_FOLDER', { count: results.files.length })}`;
            btn.disabled = false;
        } else {
            btn.className = 'bg-gray-300 text-gray-500 font-medium py-3 px-6 rounded-lg cursor-not-allowed flex items-center justify-center';
            btn.innerHTML = `<i class="fas fa-save mr-2"></i>${ui('SAVE_TO_LOCAL_FOLDER')} (${info('SELECT_FOLDER_FIRST')})`;
            btn.disabled = true;
        }
        
        if (onSave) {
            btn.onclick = onSave;
        }
        
        // Store reference for updates
        this.saveLocalButton = btn;
        
        return btn;
    }

    /**
     * Create instructions element
     * WHY: Provides clear guidance for saving files
     */
    createInstructions() {
        const instructions = document.createElement('div');
        instructions.className = 'mt-3 text-sm text-gray-600 leading-normal';
        
        if (this.selectedDirectoryHandle) {
            instructions.innerHTML = `
                <div class="bg-green-50 border-l-4 border-green-500 p-3 rounded">
                    <div class="flex">
                        <div class="flex-shrink-0">
                            <i class="fas fa-check-circle text-green-500"></i>
                        </div>
                        <div class="ml-3">
                            <p class="text-sm text-green-700">
                                <strong>Ready to save</strong><br>
                                ${message('READY_TO_SAVE_DESCRIPTION', { folderName: this.selectedDirectoryHandle.name })}
                            </p>
                        </div>
                    </div>
                </div>
            `;
        } else {
            instructions.innerHTML = `
                <div class="bg-blue-50 border-l-4 border-blue-500 p-3 rounded">
                    <div class="flex">
                        <div class="flex-shrink-0">
                            <i class="fas fa-info-circle text-blue-500"></i>
                        </div>
                        <div class="ml-3">
                            <p class="text-sm text-blue-700">
                                <strong>Select your destination folder</strong><br>
                                ${message('SELECT_DESTINATION')}
                            </p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        return instructions;
    }

    /**
     * Create unsupported API warning
     * WHY: Informs users when File System Access API is unavailable
     */
    createUnsupportedWarning() {
        const apiInfo = getFileSystemAccessInfo();
        const warning = document.createElement('div');
        warning.className = 'bg-yellow-50 border-l-4 border-yellow-500 p-4 rounded mb-4';
        
        let messageText = message('MOBILE_SAVE_INFO') + ' ';
        
        if (apiInfo.mobile) {
            if (apiInfo.ios) {
                messageText += message('IOS_SAVE_INFO');
            } else {
                messageText += message('MOBILE_DOWNLOAD_INFO');
            }
        } else {
            messageText += message('MOBILE_DOWNLOAD_INFO');
        }
        
        warning.innerHTML = `
            <div class="flex items-start space-x-3">
                <div class="flex-shrink-0">
                    <i class="fas fa-exclamation-triangle text-yellow-500 mt-1"></i>
                </div>
                <div>
                    <strong class="block mb-2 text-yellow-800">${message('MOBILE_BROWSER_DETECTED')}</strong>
                    <p class="text-yellow-700 leading-normal mb-0">${messageText}</p>
                    ${apiInfo.mobile ? `
                        <div class="mt-3 p-3 bg-blue-50 border border-blue-200 rounded">
                            <strong class="block mb-1 text-blue-800"><i class="fas fa-lightbulb mr-1"></i>${message('MOBILE_TIP')}</strong>
                            <p class="text-blue-700 text-sm mb-0">${message('MOBILE_TIP_DESCRIPTION')}</p>
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
        
        return warning;
    }

    /**
     * Create mobile download section
     * WHY: Provides download options optimized for mobile devices
     */
    createMobileDownloadSection(onDownloadZip) {
        const downloadSection = document.createElement('div');
        downloadSection.className = 'mt-4';
        
        const downloadTitle = document.createElement('h4');
        downloadTitle.className = 'text-lg font-medium text-gray-800 mb-3 flex items-center';
        downloadTitle.innerHTML = `
            <i class="fas fa-download mr-2 text-indigo-500"></i>
            ${ui('DOWNLOAD_OPTIONS')}
        `;
        
        const downloadButton = document.createElement('button');
        downloadButton.className = 'bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-4 px-6 rounded-lg transition-colors w-full mb-3 flex items-center justify-center';
        downloadButton.innerHTML = `
            <i class="fas fa-download mr-3"></i>
            ${ui('DOWNLOAD_ALL_ZIP')}
        `;
        if (onDownloadZip) {
            downloadButton.onclick = onDownloadZip;
        }
        
        const downloadInfo = document.createElement('p');
        downloadInfo.className = 'text-sm text-gray-600 mb-3';
        downloadInfo.textContent = message('ZIP_ARCHIVE_INFO');
        
        downloadSection.appendChild(downloadTitle);
        downloadSection.appendChild(downloadInfo);
        downloadSection.appendChild(downloadButton);
        
        return downloadSection;
    }

    /**
     * Create file table row
     * WHY: Extracted method for cleaner code and better maintainability
     */
    createFileRow(file, callbacks = {}) {
        const row = document.createElement('tr');
        row.className = 'border-b border-gray-200 hover:bg-gray-50 transition-colors';
        
        // Fix date extraction - use multiple possible properties
        const dateCreated = this.getFileDate(file);
        
        // Title column with filename shown as subtitle - FIXED WIDTH to prevent layout shifts
        const titleCell = document.createElement('td');
        titleCell.className = 'px-4 py-3 text-gray-800 font-medium align-top';
        titleCell.style.width = '65%'; // Match header width
        
        const titleContainer = document.createElement('div');
        const titleSpan = document.createElement('div');
        titleSpan.textContent = file.title;
        titleSpan.style.wordBreak = 'break-word'; // Prevent overflow
        
        titleContainer.appendChild(titleSpan);
        titleCell.appendChild(titleContainer);
        
        // Date column - FIXED WIDTH to prevent layout shifts
        const dateCell = document.createElement('td');
        dateCell.className = 'px-4 py-3 text-gray-600 text-sm align-top whitespace-nowrap';
        dateCell.style.width = '20%'; // Match header width
        dateCell.textContent = dateCreated;
        
        // Actions column - FIXED WIDTH to prevent layout shifts
        const actionsCell = document.createElement('td');
        actionsCell.className = 'px-4 py-3 text-right align-top whitespace-nowrap';
        actionsCell.style.width = '15%'; // Match header width
        
        const actionsContainer = document.createElement('div');
        actionsContainer.className = 'flex gap-2 justify-end';
        
        // Always create Save button first, then Download button
        // This maintains consistent layout and allows individual file saving
        const saveBtn = document.createElement('button');
        saveBtn.className = 'bg-indigo-600 hover:bg-indigo-700 text-white px-2 py-1 rounded text-xs flex-shrink-0 transition-colors save-file-btn';
        saveBtn.setAttribute('data-filename', file.filename);
        saveBtn.setAttribute('data-content', encodeURIComponent(file.content));
        saveBtn.setAttribute('data-title', file.title);
        saveBtn.innerHTML = `
            <svg class="icon" style="width: 16px; height: 16px;" viewBox="0 0 24 24">
                <path d="M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z"/>
            </svg>
        `;
        actionsContainer.appendChild(saveBtn);
        
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'bg-gray-500 hover:bg-gray-600 text-white px-2 py-1 rounded text-xs flex-shrink-0 transition-colors download-file-btn';
        downloadBtn.setAttribute('data-filename', file.filename);
        downloadBtn.setAttribute('data-content', encodeURIComponent(file.content));
        downloadBtn.innerHTML = `
            <svg class="icon" style="width: 16px; height: 16px;" viewBox="0 0 24 24">
                <path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z"/>
            </svg>
        `;
        
        actionsContainer.appendChild(downloadBtn);
        
        actionsCell.appendChild(actionsContainer);
        
        row.appendChild(titleCell);
        row.appendChild(dateCell);
        row.appendChild(actionsCell);
        
        return row;
    }

    /**
     * Create pagination button
     * WHY: Creates consistent pagination button styling and behavior
     */
    createPaginationButton(text, page, isActive = false, onClick) {
        const button = document.createElement('button');
        button.textContent = text;
        button.className = `btn ${isActive ? 'btn-primary' : 'btn-secondary'}`;
        button.style.padding = 'var(--space-2) var(--space-3)';
        button.style.fontSize = 'var(--font-size-sm)';
        button.style.minWidth = '40px';
        
        if (!isActive && onClick) {
            button.addEventListener('click', () => onClick(page));
        }
        
        return button;
    }

    /**
     * Create file save confirmation dialog
     * WHY: Provides clear visual confirmation when individual files are saved
     */
    createFileSaveConfirmationDialog(fileTitle, folderName, filename) {
        // Create confirmation dialog
        const dialog = document.createElement('div');
        dialog.className = 'file-save-confirmation-dialog';
        dialog.innerHTML = `
            <div class="dialog-overlay">
                <div class="dialog-content">
                    <div class="success-icon">✅</div>
                    <h3>${success('FILE_SAVED_SUCCESS')}</h3>
                    <p><strong>${fileTitle}</strong> ${message('FILE_SAVED_TO_FOLDER', { fileTitle, folderName })}</p>
                    <p class="filename">${message('FILENAME_LABEL')} <code>${filename}</code></p>
                    <div class="dialog-buttons">
                        <button class="btn btn-primary ok-btn">${ui('OK')}</button>
                    </div>
                </div>
            </div>
        `;
        
        return dialog;
    }

    /**
     * Get properly formatted date from file object
     * WHY: Handles different date property names and formats consistently
     */
    getFileDate(file) {
        if (!file || typeof file !== 'object') {
            return 'Unknown';
        }
        
        // Try different possible date properties
        const createTime = file.createTime || file.create_time;
        
        if (createTime && !isNaN(createTime) && createTime > 0) {
            try {
                const date = new Date(createTime * 1000);
                // Check if date is valid
                if (!isNaN(date.getTime())) {
                    return date.toLocaleDateString();
                }
            } catch (error) {
                console.warn('Error formatting date:', error);
            }
        }
        
        // Fallback to createdDate if available
        if (file.createdDate && file.createdDate !== 'Unknown' && typeof file.createdDate === 'string') {
            return file.createdDate;
        }
        
        return 'Unknown';
    }

    /**
     * Update save button state based on directory selection
     * WHY: Provides visual feedback about readiness to save
     */
    updateSaveButtonState(convertedFiles) {
        if (this.saveLocalButton) {
            this.saveLocalButton.disabled = !this.selectedDirectoryHandle;
            
            if (this.selectedDirectoryHandle) {
                this.saveLocalButton.className = 'bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-3 px-6 rounded-lg transition-colors flex items-center justify-center';
                this.saveLocalButton.innerHTML = `<i class="fas fa-save mr-2"></i>${ui('SAVE_FILES_TO_FOLDER', { count: convertedFiles.length })}`;
                this.saveLocalButton.style.animation = 'pulse 2s infinite';
            } else {
                this.saveLocalButton.className = 'bg-gray-300 text-gray-500 font-medium py-3 px-6 rounded-lg cursor-not-allowed flex items-center justify-center';
                this.saveLocalButton.innerHTML = `<i class="fas fa-save mr-2"></i>${ui('SAVE_TO_LOCAL_FOLDER')} (${info('SELECT_FOLDER_FIRST')})`;
                this.saveLocalButton.style.animation = 'none';
            }
        }
    }
}

export default UIBuilder;
</file>

<file path="src/utils/accessibility.js">
/**
 * Accessibility Module
 * Manages accessibility features including aria-live regions for status updates
 * Following AGENTS.md principle: inclusive design and web accessibility standards
 */

import { getString } from './strings.js';

/**
 * Accessibility Manager
 * WHY: Centralized accessibility features for screen readers and assistive technologies
 */
class AccessibilityManager {
    constructor() {
        this.statusRegion = null;
        this.progressRegion = null;
        this.resultsRegion = null;
        this.initialized = false;
    }

    /**
     * Initialize accessibility features
     * WHY: Sets up aria-live regions and other a11y enhancements
     */
    initialize() {
        if (this.initialized) return;

        this.createAriaLiveRegions();
        this.enhanceExistingElements();
        this.initialized = true;
        
        console.log('♿ Accessibility features initialized');
    }

    /**
     * Create aria-live regions for dynamic content announcements
     * WHY: Screen readers need live regions to announce status changes
     */
    createAriaLiveRegions() {
        // Status region for general application status
        this.statusRegion = this.createLiveRegion('accessibility-status', 'polite');
        this.statusRegion.setAttribute('aria-label', getString('ACCESSIBILITY.STATUS_REGION_LABEL'));

        // Progress region for conversion progress updates
        this.progressRegion = this.createLiveRegion('accessibility-progress', 'polite');
        this.progressRegion.setAttribute('aria-label', getString('ACCESSIBILITY.PROGRESS_REGION_LABEL'));

        // Results region for conversion results
        this.resultsRegion = this.createLiveRegion('accessibility-results', 'polite');
        this.resultsRegion.setAttribute('aria-label', getString('ACCESSIBILITY.RESULTS_REGION_LABEL'));

        // Add to document
        document.body.appendChild(this.statusRegion);
        document.body.appendChild(this.progressRegion);
        document.body.appendChild(this.resultsRegion);
    }

    /**
     * Create a single aria-live region element
     * WHY: Reusable method for creating consistent live regions
     */
    createLiveRegion(id, politeness = 'polite') {
        const region = document.createElement('div');
        region.id = id;
        region.setAttribute('aria-live', politeness);
        region.setAttribute('aria-atomic', 'true');
        region.className = 'sr-only'; // Screen reader only
        region.style.position = 'absolute';
        region.style.left = '-10000px';
        region.style.width = '1px';
        region.style.height = '1px';
        region.style.overflow = 'hidden';
        
        return region;
    }

    /**
     * Announce status message to screen readers
     * WHY: Provides audio feedback for status changes
     */
    announceStatus(message, level = 'info') {
        if (!this.statusRegion) return;

        // Clear previous message to ensure it's announced again
        this.statusRegion.textContent = '';
        
        // Add slight delay to ensure screen readers pick up the change
        setTimeout(() => {
            const prefix = this.getAnnouncementPrefix(level);
            this.statusRegion.textContent = prefix + message;
        }, 100);
    }

    /**
     * Announce progress updates to screen readers
     * WHY: Keeps users informed of long-running operations
     */
    announceProgress(message, progress = null) {
        if (!this.progressRegion) return;

        this.progressRegion.textContent = '';
        
        setTimeout(() => {
            let announcement = message;
            if (progress !== null) {
                announcement = `${Math.round(progress)}% complete. ${message}`;
            }
            this.progressRegion.textContent = announcement;
        }, 100);
    }

    /**
     * Announce conversion results to screen readers
     * WHY: Provides completion feedback and results summary
     */
    announceResults(message) {
        if (!this.resultsRegion) return;

        this.resultsRegion.textContent = '';
        
        setTimeout(() => {
            this.resultsRegion.textContent = message;
        }, 100);
    }

    /**
     * Get appropriate prefix for announcements based on message level
     * WHY: Provides context for different types of messages
     */
    getAnnouncementPrefix(level) {
        switch (level) {
            case 'error':
                return 'Error: ';
            case 'success':
                return 'Success: ';
            case 'warning':
                return 'Warning: ';
            case 'info':
            default:
                return '';
        }
    }

    /**
     * Enhance existing elements with accessibility attributes
     * WHY: Improves navigation and usability for assistive technologies
     */
    enhanceExistingElements() {
        // Enhance file table if it exists
        this.enhanceFileTable();
        
        // Enhance sort controls
        this.enhanceSortControls();
        
        // Enhance buttons and interactive elements
        this.enhanceButtons();
        
        // Enhance form controls
        this.enhanceFormControls();
    }

    /**
     * Enhance file table with accessibility attributes
     * WHY: Makes table navigation easier for screen readers
     */
    enhanceFileTable() {
        const fileTable = document.getElementById('fileTable');
        if (fileTable) {
            // Add table caption if not present
            if (!fileTable.querySelector('caption')) {
                const caption = document.createElement('caption');
                caption.className = 'sr-only';
                caption.textContent = 'Converted files list with actions';
                fileTable.insertBefore(caption, fileTable.firstChild);
            }

            // Enhance column headers with sort info
            const titleHeader = document.getElementById('titleHeader');
            const dateHeader = document.getElementById('dateHeader');
            
            if (titleHeader) {
                titleHeader.setAttribute('tabindex', '0');
                titleHeader.setAttribute('role', 'button');
                titleHeader.setAttribute('aria-label', 'Sort by title. Click to change sort order.');
            }
            
            if (dateHeader) {
                dateHeader.setAttribute('tabindex', '0');
                dateHeader.setAttribute('role', 'button');
                dateHeader.setAttribute('aria-label', 'Sort by date created. Click to change sort order.');
            }

            // Add instructions for table usage
            const tableContainer = fileTable.closest('.card-content');
            if (tableContainer && !tableContainer.querySelector('.table-instructions')) {
                const instructions = document.createElement('div');
                instructions.className = 'sr-only table-instructions';
                instructions.textContent = getString('ACCESSIBILITY.TABLE_SORT_INFO') + '. ' + getString('ACCESSIBILITY.FILE_ACTIONS_INFO');
                tableContainer.insertBefore(instructions, fileTable);
            }
        }
    }

    /**
     * Enhance sort controls with accessibility
     * WHY: Makes sorting functionality accessible to keyboard and screen reader users
     */
    enhanceSortControls() {
        // Add keyboard navigation for column headers
        document.addEventListener('keydown', (event) => {
            if (event.target.id === 'titleHeader' || event.target.id === 'dateHeader') {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    event.target.click();
                }
            }
        });
    }

    /**
     * Enhance buttons with proper accessibility attributes
     * WHY: Ensures buttons are properly labeled and accessible
     */
    enhanceButtons() {
        // Add accessible names and states to buttons that may be missing them
        const buttons = document.querySelectorAll('button');
        buttons.forEach(button => {
            // Add role if not present
            if (!button.getAttribute('role') && button.tagName.toLowerCase() === 'button') {
                // Button elements don't need explicit role="button"
            }
            
            // Ensure buttons have accessible names
            if (!button.getAttribute('aria-label') && !button.textContent.trim() && !button.querySelector('span:not(.sr-only)')) {
                console.warn('Button without accessible name found:', button);
            }
        });
    }

    /**
     * Enhance form controls with labels and descriptions
     * WHY: Associates labels and help text with form controls
     */
    enhanceFormControls() {
        // Enhance file input
        const fileInput = document.getElementById('fileInput');
        if (fileInput) {
            fileInput.setAttribute('aria-describedby', 'file-input-help');
            
            // Add help text if not present
            if (!document.getElementById('file-input-help')) {
                const helpText = document.createElement('div');
                helpText.id = 'file-input-help';
                helpText.className = 'sr-only';
                helpText.textContent = 'Upload your ChatGPT export JSON file for conversion to Markdown format.';
                fileInput.parentNode.appendChild(helpText);
            }
        }
    }

    /**
     * Update sort indicators with accessibility announcements
     * WHY: Informs screen reader users of current sort state
     */
    updateSortAnnouncement(column, direction) {
        const message = getString('UI.CURRENT_SORT', { 
            column: column === 'title' ? 'title' : 'date', 
            direction: direction === 'asc' ? 'ascending' : 'descending' 
        });
        
        this.announceStatus(message);
    }

    /**
     * Announce file operation results
     * WHY: Provides feedback for file save/download operations
     */
    announceFileOperation(operation, success, filename = '') {
        const verb = operation === 'save' ? 'saved' : 'downloaded';
        const message = success 
            ? `File ${filename} ${verb} successfully`
            : `Failed to ${operation.slice(0, -1)} file ${filename}`;
        
        this.announceStatus(message, success ? 'success' : 'error');
    }

    /**
     * Add skip link for keyboard navigation
     * WHY: Allows keyboard users to skip to main content
     */
    addSkipLink() {
        const skipLink = document.createElement('a');
        skipLink.href = '#main-content';
        skipLink.className = 'skip-link sr-only focus:not-sr-only focus:absolute focus:top-0 focus:left-0 focus:z-50 focus:p-4 focus:bg-indigo-600 focus:text-white focus:underline';
        skipLink.textContent = 'Skip to main content';
        
        document.body.insertBefore(skipLink, document.body.firstChild);
        
        // Ensure main content has the ID
        const mainContent = document.querySelector('main') || document.querySelector('.main-content');
        if (mainContent && !mainContent.id) {
            mainContent.id = 'main-content';
        }
    }

    /**
     * Focus management for modal dialogs
     * WHY: Traps focus within modals for keyboard accessibility
     */
    trapFocus(container) {
        const focusableElements = container.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
        
        if (focusableElements.length === 0) return;
        
        const firstFocusable = focusableElements[0];
        const lastFocusable = focusableElements[focusableElements.length - 1];
        
        // Focus first element
        firstFocusable.focus();
        
        // Handle tab navigation
        container.addEventListener('keydown', (event) => {
            if (event.key === 'Tab') {
                if (event.shiftKey) {
                    // Shift + Tab
                    if (document.activeElement === firstFocusable) {
                        event.preventDefault();
                        lastFocusable.focus();
                    }
                } else {
                    // Tab
                    if (document.activeElement === lastFocusable) {
                        event.preventDefault();
                        firstFocusable.focus();
                    }
                }
            }
            
            // Close on Escape
            if (event.key === 'Escape') {
                const closeButton = container.querySelector('.ok-btn') || container.querySelector('[data-dismiss]');
                if (closeButton) {
                    closeButton.click();
                }
            }
        });
    }

    /**
     * Clean up accessibility features
     * WHY: Removes event listeners and elements when no longer needed
     */
    cleanup() {
        if (this.statusRegion) {
            document.body.removeChild(this.statusRegion);
            this.statusRegion = null;
        }
        
        if (this.progressRegion) {
            document.body.removeChild(this.progressRegion);
            this.progressRegion = null;
        }
        
        if (this.resultsRegion) {
            document.body.removeChild(this.resultsRegion);
            this.resultsRegion = null;
        }
        
        this.initialized = false;
    }
}

// Create singleton instance
const accessibilityManager = new AccessibilityManager();

// Export the instance and initialize on module load
export { accessibilityManager };
export default accessibilityManager;

// Auto-initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        accessibilityManager.initialize();
    });
} else {
    accessibilityManager.initialize();
}
</file>

<file path="src/utils/logger.js">
/**
 * Logging Utility
 * Centralized logging system with configurable levels
 * Following AGENTS.md principle: modular, focused functionality
 */

// Log levels in order of severity
export const LOG_LEVELS = {
    ERROR: 0,
    WARN: 1,
    INFO: 2,
    DEBUG: 3,
    TRACE: 4
};

// Default configuration
const DEFAULT_CONFIG = {
    level: LOG_LEVELS.INFO, // Default to INFO level
    enableConsole: true,    // Enable console output by default
    enableExternal: false,  // Disable external logging by default
    externalLogger: null    // Function for external logging (e.g., Datadog)
};

// Initialize config immediately
let config = { ...DEFAULT_CONFIG };

// Check for debug mode immediately if in browser environment
if (typeof window !== 'undefined') {
    const urlParams = new URLSearchParams(window.location.search);
    const debugMode = urlParams.get('debug') === 'true' || 
                     localStorage.getItem('chatgpt-converter-debug') === 'true';
    
    if (debugMode) {
        config.level = LOG_LEVELS.DEBUG;
    }
}

/**
 * Configure the logger
 * @param {Object} options - Configuration options
 */
export function configureLogger(options = {}) {
    config = { ...config, ...options };
}

/**
 * Get current log level name
 * @returns {string} - Current log level name
 */
function getCurrentLevelName() {
    return Object.keys(LOG_LEVELS).find(key => LOG_LEVELS[key] === config.level) || 'INFO';
}

/**
 * Format log message with timestamp and level
 * @param {string} level - Log level
 * @param {string} message - Log message
 * @param {*} data - Optional data to log
 * @returns {Object} - Formatted log entry
 */
function formatLogEntry(level, message, data = null) {
    const timestamp = new Date().toISOString();
    const entry = {
        timestamp,
        level,
        message,
        data,
        context: {
            userAgent: navigator.userAgent,
            url: window.location.href
        }
    };

    return entry;
}

/**
 * Internal logging function
 * @param {number} level - Log level number
 * @param {string} levelName - Log level name
 * @param {string} message - Log message
 * @param {*} data - Optional data
 */
function log(level, levelName, message, data = null) {
    if (level > config.level) {
        return; // Skip if below current log level
    }

    const entry = formatLogEntry(levelName, message, data);

    // Console output
    if (config.enableConsole) {
        const consoleMethod = levelName.toLowerCase();
        if (consoleMethod in console && typeof console[consoleMethod] === 'function') {
            if (data) {
                console[consoleMethod](message, data);
            } else {
                console[consoleMethod](message);
            }
        } else {
            // Fallback to console.log
            console.log(`[${levelName}] ${message}`, data || '');
        }
    }

    // External logging (e.g., Datadog)
    if (config.enableExternal && config.externalLogger && typeof config.externalLogger === 'function') {
        try {
            config.externalLogger(entry);
        } catch (error) {
            // Don't let external logging errors break the app
            console.warn('External logging failed:', error);
        }
    }
}

/**
 * Log error messages
 * @param {string} message - Error message
 * @param {*} data - Optional error data
 */
export function logError(message, data = null) {
    log(LOG_LEVELS.ERROR, 'ERROR', message, data);
}

/**
 * Log warning messages
 * @param {string} message - Warning message
 * @param {*} data - Optional warning data
 */
export function logWarn(message, data = null) {
    log(LOG_LEVELS.WARN, 'WARN', message, data);
}

/**
 * Log info messages
 * @param {string} message - Info message
 * @param {*} data - Optional info data
 */
export function logInfo(message, data = null) {
    log(LOG_LEVELS.INFO, 'LOG', message, data);
}

/**
 * Log debug messages
 * @param {string} message - Debug message
 * @param {*} data - Optional debug data
 */
export function logDebug(message, data = null) {
    log(LOG_LEVELS.DEBUG, 'DEBUG', message, data);
}

/**
 * Log trace messages (most verbose)
 * @param {string} message - Trace message
 * @param {*} data - Optional trace data
 */
export function logTrace(message, data = null) {
    log(LOG_LEVELS.TRACE, 'TRACE', message, data);
}

/**
 * Convenience method for logging with emoji prefixes (for backward compatibility)
 * @param {string} message - Log message
 * @param {*} data - Optional data
 */
export function logWithEmoji(message, data = null) {
    logInfo(message, data);
}

/**
 * Get current logger configuration
 * @returns {Object} - Current configuration
 */
export function getLoggerConfig() {
    return { ...config };
}

/**
 * Set log level by name
 * @param {string} levelName - Log level name (ERROR, WARN, INFO, DEBUG, TRACE)
 */
export function setLogLevel(levelName) {
    const level = LOG_LEVELS[levelName.toUpperCase()];
    if (level !== undefined) {
        config.level = level;
        logInfo(`Log level set to: ${levelName.toUpperCase()}`);
    } else {
        logWarn(`Invalid log level: ${levelName}. Available levels: ${Object.keys(LOG_LEVELS).join(', ')}`);
    }
}
</file>

<file path="src/utils/strings.js">
/**
 * Internationalization Strings Module
 * Centralizes all user-facing text for translation and localization
 * Following AGENTS.md principle: clean organization for maintainable i18n
 */

/**
 * Default language strings (English)
 * WHY: Centralized string management enables easy translation and consistent messaging
 */
export const STRINGS = {
    // Application Status Messages
    STATUS: {
        READING_FILE: 'Reading file...',
        PARSING_JSON: 'Parsing conversations...',
        CONVERTING: 'Converting to Markdown...',
        FINALIZING: 'Finalizing conversion...',
        COMPLETE: 'Conversion complete!',
        PREPARING_SAVE: 'Preparing to save files...',
        SAVING_FILES: 'Saving files...',
        CREATING_ZIP: 'Creating ZIP archive...'
    },

    // Error Messages
    ERRORS: {
        INVALID_JSON: 'Invalid JSON file. Please upload a valid ChatGPT export.',
        INVALID_STRUCTURE: 'Invalid file structure. Expected an array of conversations.',
        NO_DIRECTORY: 'Please select a directory first.',
        DIRECTORY_ACCESS_LOST: 'Directory access lost. Please select folder again.',
        FAILED_TO_READ_FILE: 'Failed to read file',
        FAILED_TO_INITIALIZE: 'Failed to initialize application. Please refresh the page.',
        SAVE_FAILED: 'Save failed',
        DOWNLOAD_FAILED: 'Failed to download',
        ZIP_CREATION_FAILED: 'Failed to create ZIP archive. Trying individual downloads...',
        BROWSER_NOT_SUPPORTED: "Your browser doesn't support direct file saving. Use download instead.",
        NO_FILES_TO_SAVE: 'No files available to save'
    },

    // Success Messages
    SUCCESS: {
        CONVERSION_COMPLETE: 'Conversion completed successfully!',
        FILES_SAVED: 'files saved',
        FILES_DOWNLOADED: 'Downloaded',
        DIRECTORY_SELECTED: 'Selected directory',
        READY_TO_SAVE: 'Now click "Save to Local Folder" to save your files!',
        FILE_SAVED_SUCCESS: 'File Saved Successfully!',
        CHECK_FOLDER: 'SUCCESS! Check your {folderName} folder for the files',
        NEW_FILES_SAVED: 'SUCCESS! {count} new files saved. {duplicates} existing files left unchanged.',
        ALL_FILES_SAVED: 'SUCCESS! All {count} files saved. {duplicates} files were overwritten.'
    },

    // Information Messages
    INFO: {
        SELECT_FOLDER_FIRST: 'Select folder first',
        SAVE_CANCELLED: 'File save cancelled',
        SAVE_OPERATION_CANCELLED: 'Save operation cancelled',
        ALL_FILES_EXISTED: 'All files already existed and were skipped. No new files to save.',
        ALL_SAVES_CANCELLED: 'All {count} file saves were cancelled',
        CHOOSE_SAVE_LOCATION: 'Choose where to save "{filename}"',
        PREPARING_FILES: 'Preparing to save {count} files to {folderName} folder...',
        ZIP_NOT_AVAILABLE: 'ZIP download not available. Downloading files individually...'
    },

    // UI Labels and Buttons
    UI: {
        // Buttons
        CHOOSE_FOLDER: 'Choose Folder',
        CHANGE_DIRECTORY: 'Change Directory (Current: {folderName})',
        SAVE_TO_LOCAL_FOLDER: 'Save to Local Folder',
        SAVE_FILES_TO_FOLDER: 'Save {count} files to selected folder',
        DOWNLOAD_ALL_ZIP: 'Download All as ZIP',
        DOWNLOAD_INDIVIDUAL: 'Download files individually',
        OK: 'OK',
        
        // Headers and Titles
        CONVERSION_SUMMARY: 'Conversion Summary',
        SAVE_LOCATION: 'Save Location',
        DOWNLOAD_OPTIONS: 'Download Options',
        
        // Table Headers
        FILE_TITLE: 'Title',
        DATE_CREATED: 'Date Created',
        ACTIONS: 'Actions',
        
        // Status and Progress
        SHOWING_FILES: 'Showing {start}-{end} of {total} files',
        NO_FILES_AVAILABLE: 'No files available',
        
        // Icons and Visual Elements
        LOADING: 'Loading...',
        PROCESSING: 'Processing...',
        
        // Accessibility
        SORT_ASCENDING: 'Sort ascending',
        SORT_DESCENDING: 'Sort descending',
        CURRENT_SORT: 'Currently sorted by {column} {direction}'
    },

    // Detailed Messages and Descriptions
    MESSAGES: {
        CONVERSION_DESCRIPTION: 'Your ChatGPT conversations have been successfully converted',
        CHOOSE_SAVE_LOCATION: 'Choose where to save your converted files',
        READY_TO_SAVE_DESCRIPTION: 'Selected folder: {folderName}. Click "Save to Local Folder" to save all files directly to your chosen location.',
        SELECT_DESTINATION: 'Select your destination folder. Choose where you want to save your converted Markdown files.',
        
        // Mobile/Browser Compatibility
        MOBILE_BROWSER_DETECTED: 'Mobile Browser Detected',
        MOBILE_SAVE_INFO: 'Your browser doesn\'t support direct folder saving.',
        MOBILE_DOWNLOAD_INFO: 'On mobile devices, use the download options below to save your files.',
        IOS_SAVE_INFO: 'On iOS devices, use the download options below to save your files. You can then move them to your preferred folder using the Files app.',
        MOBILE_TIP: 'Mobile Tip:',
        MOBILE_TIP_DESCRIPTION: 'Download all files as a ZIP archive for easier file management on your device.',
        ZIP_ARCHIVE_INFO: 'Download all converted files as a single ZIP archive for easy file management.',
        
        // File Save Confirmation
        FILE_SAVED_TO_FOLDER: '{fileTitle} has been saved to the {folderName} folder.',
        FILENAME_LABEL: 'Filename:',
        
        // Processing Messages
        INITIALIZING_CONVERTER: 'ChatGPT to Markdown Converter initialized',
        FILE_SYSTEM_API_AVAILABLE: 'File System Access API: Available',
        FILE_SYSTEM_API_NOT_AVAILABLE: 'File System Access API: Not available',
        PROCESSING_FILE: 'Processing file: {fileName} ({fileSize} bytes)',
        FILES_VIEW_POPULATED: 'Files view populated with {count} files',
        FILES_TABLE_RENDERED: 'Files table rendered: {count} files on page {page} of {totalPages}'
    },

    // Telemetry and Analytics
    TELEMETRY: {
        SESSION_INITIALIZED: 'Telemetry collector initialized',
        EVENT_TRACKED: 'Event tracked: {eventName}',
        SIGNIFICANT_EVENT: 'Significant event: {eventName}'
    },

    // Accessibility
    ACCESSIBILITY: {
        STATUS_REGION_LABEL: 'Application status updates',
        PROGRESS_REGION_LABEL: 'Conversion progress updates',
        RESULTS_REGION_LABEL: 'Conversion results',
        TABLE_SORT_INFO: 'Click column headers to sort',
        FILE_ACTIONS_INFO: 'Use Save button to choose location or Download for immediate download'
    }
};

/**
 * String interpolation helper
 * WHY: Enables dynamic content in translated strings
 * 
 * @param {string} template - String template with {placeholder} syntax
 * @param {Object} values - Object with placeholder values
 * @returns {string} - Interpolated string
 */
export function interpolate(template, values = {}) {
    if (!template || typeof template !== 'string') {
        return template;
    }
    
    return template.replace(/\{(\w+)\}/g, (match, key) => {
        return values.hasOwnProperty(key) ? values[key] : match;
    });
}

/**
 * Get localized string with optional interpolation
 * WHY: Central function for all string retrieval with future localization support
 * 
 * @param {string} key - Dot-notation key (e.g., 'STATUS.READING_FILE')
 * @param {Object} values - Optional interpolation values
 * @returns {string} - Localized string
 */
export function getString(key, values = {}) {
    const keys = key.split('.');
    let result = STRINGS;
    
    for (const k of keys) {
        if (result && typeof result === 'object' && k in result) {
            result = result[k];
        } else {
            console.warn(`String key not found: ${key}`);
            return key; // Return key as fallback
        }
    }
    
    if (typeof result !== 'string') {
        console.warn(`String key does not point to a string: ${key}`);
        return key;
    }
    
    return interpolate(result, values);
}

/**
 * Pluralization helper
 * WHY: Handle singular/plural forms for different languages
 * 
 * @param {number} count - Number for pluralization
 * @param {string} singular - Singular form
 * @param {string} plural - Plural form (optional, defaults to singular + 's')
 * @returns {string} - Correctly pluralized string
 */
export function pluralize(count, singular, plural = null) {
    if (count === 1) {
        return singular;
    }
    return plural || (singular + 's');
}

/**
 * Format file size for display
 * WHY: Consistent file size formatting with localization support
 * 
 * @param {number} bytes - File size in bytes
 * @returns {string} - Formatted file size
 */
export function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Format numbers with locale-aware formatting
 * WHY: Consistent number formatting across the application
 * 
 * @param {number} number - Number to format
 * @param {string} locale - Locale for formatting (defaults to browser locale)
 * @returns {string} - Formatted number
 */
export function formatNumber(number, locale = navigator.language) {
    return new Intl.NumberFormat(locale).format(number);
}

/**
 * Future: Load locale-specific strings
 * WHY: Enable runtime language switching
 * 
 * @param {string} locale - Locale code (e.g., 'es', 'fr', 'de')
 * @returns {Promise<Object>} - Locale-specific strings
 */
export async function loadLocale(locale) {
    // Placeholder for future locale loading
    // Could load from JSON files, API endpoints, etc.
    console.log(`Loading locale: ${locale} (not implemented yet)`);
    return STRINGS; // Return default for now
}

// Export commonly used string getters for convenience
export const status = (key, values) => getString(`STATUS.${key}`, values);
export const error = (key, values) => getString(`ERRORS.${key}`, values);
export const success = (key, values) => getString(`SUCCESS.${key}`, values);
export const info = (key, values) => getString(`INFO.${key}`, values);
export const ui = (key, values) => getString(`UI.${key}`, values);
export const message = (key, values) => getString(`MESSAGES.${key}`, values);

export default STRINGS;
</file>

<file path="src/utils/telemetry.js">
/**
 * Telemetry Module
 * Tracks user interactions and conversion metrics for analytics
 * Following AGENTS.md principle: clean, minimal implementation without large dependencies
 */

import { logInfo, logDebug, logWarn } from './logger.js';

/**
 * Telemetry Events Configuration
 * WHY: Central definition of all trackable events
 */
const TELEMETRY_EVENTS = {
    // Conversion Events
    CONVERSION_STARTED: 'conversion_started',
    CONVERSION_COMPLETED: 'conversion_completed', 
    CONVERSION_FAILED: 'conversion_failed',
    
    // File Events
    FILE_UPLOADED: 'file_uploaded',
    FILES_SAVED_LOCAL: 'files_saved_local',
    FILES_DOWNLOADED_ZIP: 'files_downloaded_zip',
    FILE_DOWNLOADED_INDIVIDUAL: 'file_downloaded_individual',
    FILE_SAVED_INDIVIDUAL: 'file_saved_individual',
    
    // User Actions
    DIRECTORY_SELECTED: 'directory_selected',
    SAVE_CANCELLED: 'save_cancelled',
    
    // Errors
    PARSE_ERROR: 'parse_error',
    SAVE_ERROR: 'save_error',
    FILESYSTEM_ERROR: 'filesystem_error',
    
    // Performance
    CONVERSION_TIME: 'conversion_time',
    SAVE_TIME: 'save_time'
};

/**
 * Simple telemetry collector
 * WHY: Tracks user interactions and performance metrics for product improvement
 */
class TelemetryCollector {
    constructor() {
        this.sessionId = this.generateSessionId();
        this.events = [];
        this.sessionStartTime = Date.now();
        
        // Track session metadata
        this.sessionMetadata = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            timestamp: new Date().toISOString(),
            fileSystemApiSupported: 'showDirectoryPicker' in window
        };
        
        logDebug('📊 Telemetry collector initialized', { sessionId: this.sessionId });
    }
    
    /**
     * Generate unique session ID
     * WHY: Track user sessions for analytics aggregation
     */
    generateSessionId() {
        return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    
    /**
     * Track an event with optional data
     * WHY: Central method for all event tracking
     * 
     * @param {string} eventName - Event name from TELEMETRY_EVENTS
     * @param {Object} data - Optional event data
     */
    track(eventName, data = {}) {
        const event = {
            sessionId: this.sessionId,
            event: eventName,
            timestamp: Date.now(),
            data: { ...data },
            sessionTime: Date.now() - this.sessionStartTime
        };
        
        this.events.push(event);
        logDebug(`📊 Event tracked: ${eventName}`, event);
        
        // Send to analytics service if configured
        this.sendToAnalytics(event);
    }
    
    /**
     * Track conversion metrics
     * WHY: Measure conversion success rates and performance
     */
    trackConversionStarted(fileSize, fileName) {
        this.track(TELEMETRY_EVENTS.CONVERSION_STARTED, {
            fileSize,
            fileName: fileName ? fileName.replace(/[^a-zA-Z0-9.]/g, '') : 'unknown', // Sanitize
            fileSizeCategory: this.getFileSizeCategory(fileSize)
        });
    }
    
    trackConversionCompleted(conversationsCount, filesCount, processingTime, errorsCount = 0) {
        this.track(TELEMETRY_EVENTS.CONVERSION_COMPLETED, {
            conversationsCount,
            filesCount,
            processingTime,
            errorsCount,
            successRate: errorsCount > 0 ? (conversationsCount - errorsCount) / conversationsCount : 1,
            performanceCategory: this.getPerformanceCategory(processingTime)
        });
    }
    
    trackConversionFailed(error, stage) {
        this.track(TELEMETRY_EVENTS.CONVERSION_FAILED, {
            error: error.message,
            errorType: error.name,
            stage, // 'parsing', 'conversion', 'processing'
            stack: error.stack ? error.stack.substring(0, 500) : null // Truncate for privacy
        });
    }
    
    /**
     * Track file operations
     * WHY: Understand user preferences and success rates for different save methods
     */
    trackFilesSaved(method, count, successCount, processingTime) {
        const eventName = method === 'local' ? TELEMETRY_EVENTS.FILES_SAVED_LOCAL : TELEMETRY_EVENTS.FILES_DOWNLOADED_ZIP;
        this.track(eventName, {
            totalFiles: count,
            successfulFiles: successCount,
            failedFiles: count - successCount,
            processingTime,
            successRate: successCount / count
        });
    }
    
    trackIndividualFileAction(action, success = true, error = null) {
        const eventName = action === 'save' ? TELEMETRY_EVENTS.FILE_SAVED_INDIVIDUAL : TELEMETRY_EVENTS.FILE_DOWNLOADED_INDIVIDUAL;
        this.track(eventName, {
            success,
            error: error ? error.message : null
        });
    }
    
    /**
     * Track user actions
     * WHY: Understand user behavior and workflow patterns
     */
    trackDirectorySelected() {
        this.track(TELEMETRY_EVENTS.DIRECTORY_SELECTED);
    }
    
    trackSaveCancelled(stage, progress) {
        this.track(TELEMETRY_EVENTS.SAVE_CANCELLED, {
            stage, // 'selection', 'progress'
            progress // percentage when cancelled
        });
    }
    
    /**
     * Track errors for debugging and improvement
     * WHY: Identify common failure points and improve user experience
     */
    trackError(errorType, error, context = {}) {
        let eventName;
        switch (errorType) {
            case 'parse':
                eventName = TELEMETRY_EVENTS.PARSE_ERROR;
                break;
            case 'save':
                eventName = TELEMETRY_EVENTS.SAVE_ERROR;
                break;
            case 'filesystem':
                eventName = TELEMETRY_EVENTS.FILESYSTEM_ERROR;
                break;
            default:
                eventName = 'unknown_error';
        }
        
        this.track(eventName, {
            error: error.message,
            errorType: error.name,
            context,
            stack: error.stack ? error.stack.substring(0, 500) : null
        });
    }
    
    /**
     * Get file size category for analytics grouping
     * WHY: Understand performance patterns across different file sizes
     */
    getFileSizeCategory(size) {
        if (size < 1024 * 100) return 'small'; // < 100KB
        if (size < 1024 * 1024) return 'medium'; // < 1MB
        if (size < 1024 * 1024 * 10) return 'large'; // < 10MB
        return 'xlarge'; // >= 10MB
    }
    
    /**
     * Get performance category for analytics grouping
     * WHY: Understand performance characteristics
     */
    getPerformanceCategory(timeMs) {
        if (timeMs < 1000) return 'fast'; // < 1s
        if (timeMs < 5000) return 'normal'; // < 5s
        if (timeMs < 15000) return 'slow'; // < 15s
        return 'very_slow'; // >= 15s
    }
    
    /**
     * Send event to analytics service
     * WHY: Enable real analytics collection when service is configured
     */
    sendToAnalytics(event) {
        // Placeholder for analytics service integration
        // Could integrate with Google Analytics, Mixpanel, custom endpoint, etc.
        
        // For now, just log significant events
        if (this.isSignificantEvent(event.event)) {
            logInfo(`📊 Significant event: ${event.event}`, event.data);
        }
    }
    
    /**
     * Check if event is significant for logging
     * WHY: Reduce noise while tracking important events
     */
    isSignificantEvent(eventName) {
        return [
            TELEMETRY_EVENTS.CONVERSION_COMPLETED,
            TELEMETRY_EVENTS.CONVERSION_FAILED,
            TELEMETRY_EVENTS.FILES_SAVED_LOCAL,
            TELEMETRY_EVENTS.FILES_DOWNLOADED_ZIP,
            TELEMETRY_EVENTS.PARSE_ERROR,
            TELEMETRY_EVENTS.SAVE_ERROR
        ].includes(eventName);
    }
    
    /**
     * Get session summary for debugging
     * WHY: Provide session overview for troubleshooting
     */
    getSessionSummary() {
        const summary = {
            sessionId: this.sessionId,
            duration: Date.now() - this.sessionStartTime,
            eventCount: this.events.length,
            metadata: this.sessionMetadata,
            eventsByType: {}
        };
        
        // Count events by type
        this.events.forEach(event => {
            summary.eventsByType[event.event] = (summary.eventsByType[event.event] || 0) + 1;
        });
        
        return summary;
    }
    
    /**
     * Export events for analytics (if needed)
     * WHY: Allow data export for external analytics tools
     */
    exportEvents() {
        return {
            session: this.sessionMetadata,
            events: this.events,
            summary: this.getSessionSummary()
        };
    }
}

// Create singleton instance
const telemetry = new TelemetryCollector();

// Export telemetry instance and events constants
export { telemetry, TELEMETRY_EVENTS };
export default telemetry;
</file>

<file path="test-vite-react/tests/unit/applicationOrchestrator.test.js">
/**
 * Unit Tests for Application Orchestrator Business Logic
 * Testing core application methods for file processing and UI management
 * Following AGENTS.md principle: comprehensive testing of business logic
 */

import { describe, test, expect, beforeEach, jest } from '@jest/globals';
import { ChatGPTConverter } from '../../../src/modules/applicationOrchestrator.js';

// Mock dependencies
jest.mock('../../../src/components/FileUploader.js', () => ({
    FileUploader: jest.fn().mockImplementation(() => ({
        setFileSelectedCallback: jest.fn(),
        setProcessingState: jest.fn()
    }))
}));

jest.mock('../../../src/components/ProgressDisplay.js', () => ({
    ProgressDisplay: jest.fn().mockImplementation(() => ({
        show: jest.fn(),
        hide: jest.fn(),
        updateProgress: jest.fn(),
        showError: jest.fn(),
        setCancelCallback: jest.fn(),
        isVisible: false
    }))
}));

jest.mock('../../../src/utils/telemetry.js', () => ({
    telemetry: {
        trackConversionStarted: jest.fn(),
        trackConversionCompleted: jest.fn(),
        trackConversionFailed: jest.fn(),
        trackFilesSaved: jest.fn(),
        trackError: jest.fn()
    }
}));

jest.mock('../../../src/utils/accessibility.js', () => ({
    accessibilityManager: {
        announceStatus: jest.fn(),
        announceProgress: jest.fn(),
        announceResults: jest.fn()
    }
}));

describe('Application Orchestrator Business Logic', () => {
    let converter;

    beforeEach(() => {
        // Reset mocks
        jest.clearAllMocks();
        
        // Mock window functions (document is already mocked in setup.js)
        global.window.switchToComplete = jest.fn();
        global.window.showResults = jest.fn();
        global.window.showFiles = jest.fn();
        global.window.switchToView = jest.fn();

        converter = new ChatGPTConverter();
    });

    describe('parseConversations', () => {
        test('parses valid JSON array', () => {
            const validJson = '[{"title": "Test", "mapping": {}}]';
            const result = converter.parseConversations(validJson);
            
            expect(result).toEqual([{"title": "Test", "mapping": {}}]);
        });

        test('throws error for invalid JSON', () => {
            const invalidJson = '{ invalid json }';
            
            expect(() => {
                converter.parseConversations(invalidJson);
            }).toThrow('Invalid JSON file. Please upload a valid ChatGPT export.');
        });

        test('throws error for non-array JSON', () => {
            const nonArrayJson = '{"title": "Test", "mapping": {}}';
            
            expect(() => {
                converter.parseConversations(nonArrayJson);
            }).toThrow('Invalid file structure. Expected an array of conversations.');
        });

        test('handles empty array', () => {
            const emptyArray = '[]';
            const result = converter.parseConversations(emptyArray);
            
            expect(result).toEqual([]);
        });

        test('handles complex nested conversation structure', () => {
            const complexJson = JSON.stringify([
                {
                    title: "Complex Conversation",
                    create_time: 1703522622,
                    mapping: {
                        "msg_1": {
                            message: {
                                author: { role: "user" },
                                content: { parts: ["Hello"] }
                            }
                        }
                    }
                }
            ]);
            
            const result = converter.parseConversations(complexJson);
            
            expect(result).toHaveLength(1);
            expect(result[0].title).toBe("Complex Conversation");
            expect(result[0].mapping).toBeDefined();
        });
    });

    describe('sortFiles', () => {
        let testFiles;

        beforeEach(() => {
            testFiles = [
                {
                    title: "Zebra Conversation",
                    filename: "zebra.md",
                    createTime: 1703522600,
                    create_time: 1703522600
                },
                {
                    title: "Apple Discussion", 
                    filename: "apple.md",
                    createTime: 1703522700,
                    create_time: 1703522700
                },
                {
                    title: "Beta Test",
                    filename: "beta.md", 
                    createTime: 1703522650,
                    create_time: 1703522650
                }
            ];
        });

        test('sorts by title ascending', () => {
            converter.currentSort = 'title';
            converter.sortDirection = 'asc';
            
            const result = converter.sortFiles([...testFiles]);
            
            expect(result[0].title).toBe("Apple Discussion");
            expect(result[1].title).toBe("Beta Test");
            expect(result[2].title).toBe("Zebra Conversation");
        });

        test('sorts by title descending', () => {
            converter.currentSort = 'title';
            converter.sortDirection = 'desc';
            
            const result = converter.sortFiles([...testFiles]);
            
            expect(result[0].title).toBe("Zebra Conversation");
            expect(result[1].title).toBe("Beta Test");
            expect(result[2].title).toBe("Apple Discussion");
        });

        test('sorts by date ascending (oldest first)', () => {
            converter.currentSort = 'date';
            converter.sortDirection = 'asc';
            
            const result = converter.sortFiles([...testFiles]);
            
            expect(result[0].createTime).toBe(1703522600); // Zebra - oldest
            expect(result[1].createTime).toBe(1703522650); // Beta - middle  
            expect(result[2].createTime).toBe(1703522700); // Apple - newest
        });

        test('sorts by date descending (newest first)', () => {
            converter.currentSort = 'date';
            converter.sortDirection = 'desc';
            
            const result = converter.sortFiles([...testFiles]);
            
            expect(result[0].createTime).toBe(1703522700); // Apple - newest
            expect(result[1].createTime).toBe(1703522650); // Beta - middle
            expect(result[2].createTime).toBe(1703522600); // Zebra - oldest
        });

        test('handles files with invalid timestamps', () => {
            const filesWithInvalidDates = [
                {
                    title: "Valid Date",
                    createTime: 1703522600,
                    create_time: 1703522600
                },
                {
                    title: "Invalid Date",
                    createTime: null,
                    create_time: null
                },
                {
                    title: "Another Valid",
                    createTime: 1703522700, 
                    create_time: 1703522700
                }
            ];
            
            converter.currentSort = 'date';
            converter.sortDirection = 'desc';
            
            const result = converter.sortFiles([...filesWithInvalidDates]);
            
            // Valid dates should be sorted properly, invalid dates should be last
            expect(result[0].title).toBe("Another Valid");
            expect(result[1].title).toBe("Valid Date");
            expect(result[2].title).toBe("Invalid Date");
        });

        test('handles natural numeric sorting in titles', () => {
            const filesWithNumbers = [
                { title: "Chat 10", filename: "chat10.md", createTime: 1703522600 },
                { title: "Chat 2", filename: "chat2.md", createTime: 1703522650 },
                { title: "Chat 1", filename: "chat1.md", createTime: 1703522700 }
            ];
            
            converter.currentSort = 'title';
            converter.sortDirection = 'asc';
            
            const result = converter.sortFiles([...filesWithNumbers]);
            
            expect(result[0].title).toBe("Chat 1");
            expect(result[1].title).toBe("Chat 2");
            expect(result[2].title).toBe("Chat 10");
        });

        test('handles empty files array', () => {
            converter.currentSort = 'title';
            converter.sortDirection = 'asc';
            
            const result = converter.sortFiles([]);
            
            expect(result).toEqual([]);
        });

        test('handles files with missing title properties', () => {
            const filesWithMissingTitles = [
                { title: "Has Title", filename: "has.md", createTime: 1703522600 },
                { filename: "no-title.md", createTime: 1703522650 },
                { title: "", filename: "empty-title.md", createTime: 1703522700 }
            ];
            
            converter.currentSort = 'title';
            converter.sortDirection = 'asc';
            
            const result = converter.sortFiles([...filesWithMissingTitles]);
            
            // Should not crash and should handle missing/empty titles gracefully
            expect(result).toHaveLength(3);
            expect(result[0].title || result[0].filename).toBeTruthy();
        });
    });

    describe('readFileContent', () => {
        test('reads file content successfully', async () => {
            const mockFile = {
                name: 'test.json',
                size: 1000
            };
            
            // Mock FileReader
            const mockFileReader = {
                readAsText: jest.fn(),
                onload: null,
                onerror: null,
                result: '{"test": "data"}'
            };
            
            global.FileReader = jest.fn(() => mockFileReader);
            
            const promise = converter.readFileContent(mockFile);
            
            // Simulate successful read
            setTimeout(() => {
                mockFileReader.onload({ target: { result: '{"test": "data"}' } });
            }, 0);
            
            const result = await promise;
            expect(result).toBe('{"test": "data"}');
            expect(mockFileReader.readAsText).toHaveBeenCalledWith(mockFile);
        });

        test('handles file read error', async () => {
            const mockFile = {
                name: 'test.json',
                size: 1000
            };
            
            const mockFileReader = {
                readAsText: jest.fn(),
                onload: null,
                onerror: null
            };
            
            global.FileReader = jest.fn(() => mockFileReader);
            
            const promise = converter.readFileContent(mockFile);
            
            // Simulate read error
            setTimeout(() => {
                mockFileReader.onerror(new Error('Read failed'));
            }, 0);
            
            await expect(promise).rejects.toThrow('Failed to read file');
        });
    });

    describe('getValidTimestamp', () => {
        test('returns valid timestamp unchanged', () => {
            const validTimestamp = 1703522622;
            const result = converter.getValidTimestamp(validTimestamp);
            
            expect(result).toBe(validTimestamp);
        });

        test('returns 0 for null timestamp', () => {
            const result = converter.getValidTimestamp(null);
            
            expect(result).toBe(0);
        });

        test('returns 0 for undefined timestamp', () => {
            const result = converter.getValidTimestamp(undefined);
            
            expect(result).toBe(0);
        });

        test('returns 0 for negative timestamp', () => {
            const result = converter.getValidTimestamp(-123);
            
            expect(result).toBe(0);
        });

        test('returns 0 for NaN timestamp', () => {
            const result = converter.getValidTimestamp(NaN);
            
            expect(result).toBe(0);
        });

        test('returns 0 for string timestamp', () => {
            const result = converter.getValidTimestamp("not-a-number");
            
            expect(result).toBe(0);
        });

        test('returns 0 for zero timestamp', () => {
            const result = converter.getValidTimestamp(0);
            
            expect(result).toBe(0);
        });
    });

    describe('getFileDate', () => {
        test('formats valid timestamp correctly', () => {
            const file = {
                createTime: 1703522622,
                create_time: 1703522622
            };
            
            const result = converter.getFileDate(file);
            
            // Should return a formatted date string
            expect(result).toMatch(/\d{1,2}\/\d{1,2}\/\d{4}/); // MM/DD/YYYY or similar
        });

        test('returns "Unknown" for invalid file object', () => {
            expect(converter.getFileDate(null)).toBe('Unknown');
            expect(converter.getFileDate(undefined)).toBe('Unknown'); 
            expect(converter.getFileDate("not-an-object")).toBe('Unknown');
        });

        test('returns "Unknown" for file without date properties', () => {
            const file = {
                title: "No Date File",
                filename: "no-date.md"
            };
            
            const result = converter.getFileDate(file);
            
            expect(result).toBe('Unknown');
        });

        test('handles create_time property', () => {
            const file = {
                create_time: 1703522622
            };
            
            const result = converter.getFileDate(file);
            
            expect(result).toMatch(/\d{1,2}\/\d{1,2}\/\d{4}/);
        });

        test('falls back to createdDate string', () => {
            const file = {
                createdDate: "12/25/2023"
            };
            
            const result = converter.getFileDate(file);
            
            expect(result).toBe("12/25/2023");
        });

        test('handles invalid createTime gracefully', () => {
            const file = {
                createTime: "invalid-timestamp",
                create_time: null
            };
            
            const result = converter.getFileDate(file);
            
            expect(result).toBe('Unknown');
        });
    });

    describe('delay', () => {
        test('resolves after specified time', async () => {
            const startTime = Date.now();
            await converter.delay(100);
            const endTime = Date.now();
            
            // Allow some margin for timing variations
            expect(endTime - startTime).toBeGreaterThanOrEqual(90);
            expect(endTime - startTime).toBeLessThan(200);
        });

        test('works with zero delay', async () => {
            const startTime = Date.now();
            await converter.delay(0);
            const endTime = Date.now();
            
            // Should complete very quickly
            expect(endTime - startTime).toBeLessThan(50);
        });
    });

    describe('Error Handling', () => {
        test('parseConversations provides helpful error messages', () => {
            const malformedJson = '{"incomplete": true,';
            
            expect(() => {
                converter.parseConversations(malformedJson);
            }).toThrow('Invalid JSON file. Please upload a valid ChatGPT export.');
        });

        test('parseConversations handles edge case JSON structures', () => {
            // Test various edge cases
            expect(() => converter.parseConversations('null')).toThrow('Invalid file structure. Expected an array of conversations.');
            expect(() => converter.parseConversations('true')).toThrow('Invalid file structure. Expected an array of conversations.');
            expect(() => converter.parseConversations('123')).toThrow('Invalid file structure. Expected an array of conversations.');
            expect(() => converter.parseConversations('"string"')).toThrow('Invalid file structure. Expected an array of conversations.');
        });
    });
});
</file>

<file path="test-vite-react/tests/unit/logger.test.js">
/**
 * Logger Unit Tests
 * Tests for the centralized logging system
 */

import { 
    logError, 
    logWarn, 
    logInfo, 
    logDebug, 
    logTrace,
    configureLogger,
    setLogLevel,
    LOG_LEVELS,
    getLoggerConfig
} from '../../../src/utils/logger.js';

// Mock console methods
const originalConsole = { ...console };
let consoleLogs = [];
let consoleWarns = [];
let consoleErrors = [];
let consoleDebugs = [];
let consoleTraces = [];

beforeEach(() => {
    // Reset console mocks
    consoleLogs = [];
    consoleWarns = [];
    consoleErrors = [];
    consoleDebugs = [];
    consoleTraces = [];
    
    // Mock console methods
    console.log = jest.fn((...args) => consoleLogs.push(args));
    console.warn = jest.fn((...args) => consoleWarns.push(args));
    console.error = jest.fn((...args) => consoleErrors.push(args));
    console.debug = jest.fn((...args) => consoleDebugs.push(args));
    console.trace = jest.fn((...args) => consoleTraces.push(args));
    
    // Reset logger to default state
    configureLogger({
        level: LOG_LEVELS.INFO,
        enableConsole: true,
        enableExternal: false,
        externalLogger: null
    });
});

afterEach(() => {
    // Restore original console
    console.log = originalConsole.log;
    console.warn = originalConsole.warn;
    console.error = originalConsole.error;
    console.debug = originalConsole.debug;
    console.trace = originalConsole.trace;
});

describe('Logger Configuration', () => {
    test('should have correct default configuration', () => {
        const config = getLoggerConfig();
        expect(config.level).toBe(LOG_LEVELS.INFO);
        expect(config.enableConsole).toBe(true);
        expect(config.enableExternal).toBe(false);
    });

    test('should configure logger with custom settings', () => {
        configureLogger({
            level: LOG_LEVELS.DEBUG,
            enableConsole: false
        });
        
        const config = getLoggerConfig();
        expect(config.level).toBe(LOG_LEVELS.DEBUG);
        expect(config.enableConsole).toBe(false);
    });

    test('should set log level by name', () => {
        setLogLevel('DEBUG');
        const config = getLoggerConfig();
        expect(config.level).toBe(LOG_LEVELS.DEBUG);
    });

    test('should handle invalid log level gracefully', () => {
        setLogLevel('INVALID_LEVEL');
        const config = getLoggerConfig();
        expect(config.level).toBe(LOG_LEVELS.INFO); // Should remain at default
    });
});

describe('Log Level Filtering', () => {
    test('should log ERROR level messages at INFO level', () => {
        logError('Test error');
        expect(consoleErrors).toHaveLength(1);
        expect(consoleErrors[0][0]).toBe('Test error');
    });

    test('should log WARN level messages at INFO level', () => {
        logWarn('Test warning');
        expect(consoleWarns).toHaveLength(1);
        expect(consoleWarns[0][0]).toBe('Test warning');
    });

    test('should log INFO level messages at INFO level', () => {
        logInfo('Test info');
        expect(consoleLogs).toHaveLength(1);
        expect(consoleLogs[0][0]).toBe('Test info');
    });

    test('should NOT log DEBUG level messages at INFO level', () => {
        logDebug('Test debug');
        expect(consoleDebugs).toHaveLength(0);
    });

    test('should NOT log TRACE level messages at INFO level', () => {
        logTrace('Test trace');
        expect(consoleTraces).toHaveLength(0);
    });

    test('should log DEBUG level messages when set to DEBUG level', () => {
        setLogLevel('DEBUG');
        logDebug('Test debug');
        expect(consoleDebugs).toHaveLength(1);
        expect(consoleDebugs[0][0]).toBe('Test debug');
    });

    test('should log all levels when set to TRACE level', () => {
        setLogLevel('TRACE');
        
        logError('Test error');
        logWarn('Test warning');
        logInfo('Test info');
        logDebug('Test debug');
        logTrace('Test trace');
        
        expect(consoleErrors).toHaveLength(1);
        expect(consoleWarns).toHaveLength(1);
        expect(consoleLogs).toHaveLength(2); // INFO (including the setLogLevel message)
        expect(consoleDebugs).toHaveLength(1); // DEBUG
        expect(consoleTraces).toHaveLength(1); // TRACE
    });
});

describe('Log Data Handling', () => {
    test('should handle log messages with data', () => {
        const testData = { key: 'value', number: 42 };
        logInfo('Test message', testData);
        
        expect(consoleLogs).toHaveLength(1);
        expect(consoleLogs[0][0]).toBe('Test message');
        expect(consoleLogs[0][1]).toEqual(testData);
    });

    test('should handle log messages without data', () => {
        logInfo('Test message');
        
        expect(consoleLogs).toHaveLength(1);
        expect(consoleLogs[0][0]).toBe('Test message');
        expect(consoleLogs[0][1]).toBeUndefined();
    });
});

describe('Console Output Control', () => {
    test('should not output to console when disabled', () => {
        configureLogger({ enableConsole: false });
        logInfo('Test message');
        expect(consoleLogs).toHaveLength(0);
    });

    test('should output to console when enabled', () => {
        configureLogger({ enableConsole: true });
        logInfo('Test message');
        expect(consoleLogs).toHaveLength(1);
    });
});

describe('External Logging', () => {
    test('should call external logger when configured', () => {
        const externalLogger = jest.fn();
        configureLogger({
            enableExternal: true,
            externalLogger
        });
        
        logInfo('Test message', { data: 'test' });
        
        expect(externalLogger).toHaveBeenCalledWith(
            expect.objectContaining({
                level: 'LOG',
                message: 'Test message',
                data: { data: 'test' },
                timestamp: expect.any(String),
                context: expect.objectContaining({
                    userAgent: expect.any(String),
                    url: expect.any(String)
                })
            })
        );
    });

    test('should not call external logger when disabled', () => {
        const externalLogger = jest.fn();
        configureLogger({
            enableExternal: false,
            externalLogger
        });
        
        logInfo('Test message');
        expect(externalLogger).not.toHaveBeenCalled();
    });

    test('should handle external logger errors gracefully', () => {
        const externalLogger = jest.fn().mockImplementation(() => {
            throw new Error('External logger failed');
        });
        
        configureLogger({
            enableExternal: true,
            externalLogger
        });
        
        // Should not throw error
        expect(() => {
            logInfo('Test message');
        }).not.toThrow();
        
        // Should still log to console
        expect(consoleLogs).toHaveLength(1);
    });
});

describe('LOG_LEVELS Constants', () => {
    test('should have correct level hierarchy', () => {
        expect(LOG_LEVELS.ERROR).toBe(0);
        expect(LOG_LEVELS.WARN).toBe(1);
        expect(LOG_LEVELS.INFO).toBe(2);
        expect(LOG_LEVELS.DEBUG).toBe(3);
        expect(LOG_LEVELS.TRACE).toBe(4);
    });
});
</file>

<file path="test-vite-react/tests/unit/modal.test.js">
/**
 * Modal Component Tests
 * Tests for the reusable modal dialog component
 * Following AGENTS.md principle: comprehensive testing for all components
 */

import { Modal, showConfirmModal } from '../../../src/components/Modal.js';

describe('Modal Component', () => {
    let modal;
    
    beforeEach(() => {
        // Clean up any existing modals
        const existingModals = document.querySelectorAll('.custom-modal');
        existingModals.forEach(modal => modal.remove());
        
        // Clean up any existing styles
        const existingStyles = document.getElementById('customModalStyles');
        if (existingStyles) {
            existingStyles.remove();
        }
    });
    
    afterEach(() => {
        if (modal) {
            modal.destroy();
            modal = null;
        }
    });

    describe('Modal Constructor', () => {
        test('should create modal with default options', () => {
            modal = new Modal();
            
            expect(modal.id).toMatch(/^modal-\d+$/);
            expect(modal.title).toBe('');
            expect(modal.content).toBe('');
            expect(modal.allowEscape).toBe(true);
            expect(modal.allowClickOutside).toBe(true);
            expect(modal.autoFocus).toBe(true);
        });

        test('should create modal with custom options', () => {
            modal = new Modal({
                id: 'test-modal',
                title: 'Test Title',
                content: 'Test Content',
                allowEscape: false,
                allowClickOutside: false,
                autoFocus: false
            });
            
            expect(modal.id).toBe('test-modal');
            expect(modal.title).toBe('Test Title');
            expect(modal.content).toBe('Test Content');
            expect(modal.allowEscape).toBe(false);
            expect(modal.allowClickOutside).toBe(false);
            expect(modal.autoFocus).toBe(false);
        });
    });

    describe('Modal Initialization', () => {
        test('should initialize modal structure', () => {
            modal = new Modal({
                title: 'Test Modal',
                content: '<p>Test content</p>'
            });
            
            modal.initialize();
            
            expect(modal.isInitialized).toBe(true);
            expect(modal.element).toBeTruthy();
            expect(modal.element.classList.contains('custom-modal')).toBe(true);
            expect(modal.element.getAttribute('role')).toBe('dialog');
            expect(modal.element.getAttribute('aria-modal')).toBe('true');
        });

        test('should add modal styles to document', () => {
            modal = new Modal();
            modal.initialize();
            
            const styles = document.getElementById('customModalStyles');
            expect(styles).toBeTruthy();
            expect(styles.textContent).toContain('.custom-modal');
        });

        test('should not reinitialize if already initialized', () => {
            modal = new Modal();
            modal.initialize();
            
            const initialElement = modal.element;
            modal.initialize();
            
            expect(modal.element).toBe(initialElement);
        });
    });

    describe('Modal Display', () => {
        test('should show modal', (done) => {
            modal = new Modal({
                title: 'Test Modal',
                content: '<p>Test content</p>'
            });
            
            modal.show();
            
            // Wait for animation to complete
            setTimeout(() => {
                expect(modal.isVisible).toBe(true);
                expect(modal.element.classList.contains('show')).toBe(true);
                expect(document.body.contains(modal.element)).toBe(true);
                done();
            }, 100);
        });

        test('should close modal', () => {
            modal = new Modal({
                title: 'Test Modal',
                content: '<p>Test content</p>'
            });
            
            modal.show();
            modal.close();
            
            expect(modal.isVisible).toBe(false);
            expect(modal.element.classList.contains('show')).toBe(false);
        });

        test('should call onClose callback when closed', (done) => {
            const onCloseMock = jest.fn();
            modal = new Modal({
                title: 'Test Modal',
                content: '<p>Test content</p>',
                onClose: onCloseMock
            });
            
            modal.show();
            
            // Wait for modal to be visible, then close
            setTimeout(() => {
                modal.close();
                
                // Wait for close animation and callback
                setTimeout(() => {
                    expect(onCloseMock).toHaveBeenCalled();
                    done();
                }, 400);
            }, 100);
        });
    });

    describe('Modal Icon', () => {
        test('should render modal with correct icon', () => {
            modal = new Modal({
                title: 'Test Modal',
                content: '<p>Test content</p>'
            });
            
            modal.initialize();
            
            const icon = modal.element.querySelector('.modal-icon');
            expect(icon).toBeTruthy();
            expect(icon.innerHTML).toContain('M12,2A10,10');
        });
    });

    describe('Modal Buttons', () => {
        test('should render custom buttons', () => {
            modal = new Modal({
                title: 'Test Modal',
                content: '<p>Test content</p>',
                buttons: [
                    {
                        text: 'Cancel',
                        action: 'cancel',
                        class: 'btn-secondary'
                    },
                    {
                        text: 'Confirm',
                        action: 'confirm',
                        primary: true
                    }
                ]
            });
            
            modal.initialize();
            
            const buttons = modal.element.querySelectorAll('.modal-footer .btn');
            expect(buttons).toHaveLength(2);
            expect(buttons[0].textContent.trim()).toBe('Cancel');
            expect(buttons[1].textContent.trim()).toBe('Confirm');
        });

        test('should handle button clicks', () => {
            const onConfirmMock = jest.fn();
            modal = new Modal({
                title: 'Test Modal',
                content: '<p>Test content</p>',
                buttons: [
                    {
                        text: 'Confirm',
                        action: 'confirm',
                        primary: true
                    }
                ],
                onConfirm: onConfirmMock
            });
            
            modal.initialize();
            modal.show();
            
            const confirmButton = modal.element.querySelector('[data-action="confirm"]');
            confirmButton.click();
            
            expect(onConfirmMock).toHaveBeenCalled();
        });
    });

    describe('Modal Accessibility', () => {
        test('should have proper ARIA attributes', () => {
            modal = new Modal({
                title: 'Test Modal',
                content: '<p>Test content</p>'
            });
            
            modal.initialize();
            
            expect(modal.element.getAttribute('role')).toBe('dialog');
            expect(modal.element.getAttribute('aria-modal')).toBe('true');
            expect(modal.element.getAttribute('aria-labelledby')).toBe(`${modal.id}-title`);
            expect(modal.element.getAttribute('aria-describedby')).toBe(`${modal.id}-content`);
        });

        test('should have proper title and content IDs', () => {
            modal = new Modal({
                title: 'Test Modal',
                content: '<p>Test content</p>'
            });
            
            modal.initialize();
            
            const title = modal.element.querySelector(`#${modal.id}-title`);
            const content = modal.element.querySelector(`#${modal.id}-content`);
            
            expect(title).toBeTruthy();
            expect(content).toBeTruthy();
            expect(title.textContent).toBe('Test Modal');
            expect(content.innerHTML.trim()).toBe('<p>Test content</p>');
        });
    });

    describe('Convenience Functions', () => {
        test('should show confirm modal and resolve correctly', async () => {
            const promise = showConfirmModal('Confirm Title', 'Confirm message');
            
            // Wait for modal to be created
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const modalElement = document.querySelector('.custom-modal');
            expect(modalElement).toBeTruthy();
            
            // Click confirm button
            const confirmButton = modalElement.querySelector('[data-action="confirm"]');
            confirmButton.click();
            
            const result = await promise;
            expect(result).toBe(true);
        });
    });

    describe('Modal Cleanup', () => {
        test('should clean up resources on destroy', () => {
            modal = new Modal({
                title: 'Test Modal',
                content: '<p>Test content</p>'
            });
            
            modal.initialize();
            modal.show();
            modal.destroy();
            
            expect(modal.isInitialized).toBe(false);
            expect(modal.isVisible).toBe(false);
            expect(document.body.contains(modal.element)).toBe(false);
        });
    });
});
</file>

<file path="test-vite-react/babel.config.cjs">
module.exports = {
  presets: [
    [
      '@babel/preset-env',
      {
        targets: { node: 'current' },
        modules: 'cjs'
      }
    ]
  ]
};
</file>

<file path=".gitignore">
# Node modules
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Test outputs and coverage
coverage/
.nyc_output/
test-results/
*.lcov

# Temporary files and test outputs
temp-test-*/
ChatGPT/
*.tmp
*.temp

# System files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# IDE and editor files
.vscode/
.idea/
*.swp
*.swo
*~

# Logs
*.log
logs/

# Runtime data
pids/
*.pid
*.seed
*.pid.lock

# Build outputs
dist/
build/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
ENV/

# Vercel
.vercel

# Local test files
conversations.json
test_conversations.json
</file>

<file path=".vercelignore">
# Test files and directories
tests/
test-vite-react/
*.test.js
*.test.jsx
*.spec.js
*.spec.jsx

# Development files
.cursorrules
.cursor.json
LOGGING.md
AGENTS.md

# Python files (not needed for static deployment)
*.py
__pycache__/
*.pyc

# Development dependencies
node_modules/

# Build artifacts
dist/
build/

# Logs and temporary files
*.log
temp-*/
*.tmp
*.temp

# Git and IDE files
.git/
.vscode/
.idea/

# Environment files
.env*
</file>

<file path="example_conversations.json">
[
  {
    "id": "example_conv_001",
    "title": "Python Best Practices",
    "create_time": 1703520622.123,
    "mapping": {
      "msg_001": {
        "message": {
          "author": {
            "role": "user"
          },
          "content": {
            "parts": [
              "What are some essential Python best practices for writing clean, maintainable code?"
            ]
          }
        },
        "children": ["msg_002"],
        "parent": null
      },
      "msg_002": {
        "message": {
          "author": {
            "role": "assistant"
          },
          "content": {
            "parts": [
              "Here are some essential Python best practices for writing clean, maintainable code:\n\n## 1. Follow PEP 8 Style Guide\n- Use 4 spaces for indentation\n- Keep lines under 79 characters\n- Use meaningful variable and function names\n- Add blank lines to separate logical sections\n\n## 2. Write Clear Documentation\n- Use docstrings for functions, classes, and modules\n- Include type hints for better code clarity\n- Write comments that explain why, not what\n\n## 3. Error Handling\n- Use specific exception types rather than bare `except`\n- Handle exceptions at the appropriate level\n- Use context managers (`with` statements) for resource management\n\n## 4. Code Organization\n- Keep functions small and focused on one task\n- Use meaningful names for variables and functions\n- Organize code into modules and packages\n- Separate concerns and avoid tight coupling\n\n## 5. Testing\n- Write unit tests for your functions\n- Use pytest or unittest for testing\n- Aim for good test coverage\n- Test edge cases and error conditions\n\nThese practices will help you write Python code that's easier to read, maintain, and debug."
            ]
          }
        },
        "children": ["msg_003"],
        "parent": "msg_001"
      },
      "msg_003": {
        "message": {
          "author": {
            "role": "user"
          },
          "content": {
            "parts": [
              "Can you elaborate on type hints? How do they improve code quality?"
            ]
          }
        },
        "children": ["msg_004"],
        "parent": "msg_002"
      },
      "msg_004": {
        "message": {
          "author": {
            "role": "assistant"
          },
          "content": {
            "parts": [
              "Type hints are a powerful feature in Python that significantly improve code quality in several ways:\n\n## What are Type Hints?\nType hints are annotations that specify the expected types of variables, function parameters, and return values. They were introduced in Python 3.5 via PEP 484.\n\n## Benefits:\n\n### 1. **Improved Code Readability**\n```python\n# Without type hints\ndef calculate_area(length, width):\n    return length * width\n\n# With type hints\ndef calculate_area(length: float, width: float) -> float:\n    return length * width\n```\n\n### 2. **Better IDE Support**\n- Auto-completion becomes more accurate\n- IDEs can catch type-related errors before runtime\n- Better refactoring tools\n\n### 3. **Static Analysis**\n- Tools like mypy can check for type consistency\n- Catch potential bugs during development\n- Ensure API contracts are maintained\n\n### 4. **Documentation**\n- Type hints serve as inline documentation\n- Make function interfaces clearer\n- Help new team members understand code faster\n\n### 5. **Runtime Validation** (with libraries)\n- Libraries like pydantic can validate types at runtime\n- Useful for API endpoints and data validation\n\nType hints don't affect runtime performance but provide substantial benefits during development and maintenance."
            ]
          }
        },
        "children": [],
        "parent": "msg_003"
      }
    }
  },
  {
    "id": "example_conv_002", 
    "title": "Redis Caching Strategies",
    "create_time": 1703610000.456,
    "mapping": {
      "msg_101": {
        "message": {
          "author": {
            "role": "user"
          },
          "content": {
            "parts": [
              "What are effective Redis caching strategies for a high-traffic web application?"
            ]
          }
        },
        "children": ["msg_102"],
        "parent": null
      },
      "msg_102": {
        "message": {
          "author": {
            "role": "assistant"
          },
          "content": {
            "parts": [
              "Here are effective Redis caching strategies for high-traffic web applications:\n\n## 1. Cache-Aside Pattern\n- Application manages cache explicitly\n- Check cache first, then database if miss\n- Update cache after database writes\n\n## 2. Write-Through Caching\n- Write to cache and database simultaneously\n- Ensures data consistency\n- Higher latency for writes but guaranteed cache freshness\n\n## 3. Write-Behind (Write-Back)\n- Write to cache immediately\n- Asynchronously write to database\n- Faster writes but risk of data loss\n\n## 4. Key Strategies\n\n### TTL Management\n- Set appropriate expiration times\n- Use different TTLs for different data types\n- Implement TTL jittering to avoid cache stampedes\n\n### Data Structures\n- Strings: Simple key-value pairs\n- Hashes: Objects with multiple fields\n- Lists: Ordered data, queues\n- Sets: Unique items, tags\n- Sorted Sets: Leaderboards, rankings\n\n### Memory Optimization\n- Use compression for large values\n- Implement eviction policies (LRU, LFU)\n- Monitor memory usage and set limits\n\n## 5. Advanced Patterns\n- **Cache warming**: Preload frequently accessed data\n- **Circuit breaker**: Handle cache failures gracefully\n- **Distributed locking**: Prevent race conditions\n- **Pipeline operations**: Batch multiple commands\n\nThese strategies help ensure optimal performance and reliability in high-traffic scenarios."
            ]
          }
        },
        "children": [],
        "parent": "msg_101"
      }
    }
  }
]
</file>

<file path="LOGGING.md">
# Logging System

This document explains the logging system implemented in the ChatGPT to Markdown converter.

## Overview

The application now uses a centralized logging system with configurable levels to reduce console noise while maintaining the ability to capture important information for debugging and monitoring.

## Log Levels

The logging system supports five levels (in order of increasing verbosity):

- **ERROR** (0): Critical errors that need immediate attention
- **WARN** (1): Warning messages for potential issues
- **INFO** (2): General information about application state (default)
- **DEBUG** (3): Detailed debugging information
- **TRACE** (4): Most verbose logging for deep debugging

## Default Behavior

By default, the application logs at the **INFO** level, which means:
- ✅ ERROR, WARN, and INFO messages are displayed
- ❌ DEBUG and TRACE messages are suppressed

## Configuration

### Environment-Based Configuration

The logger automatically detects debug mode through:

1. **URL Parameter**: Add `?debug=true` to the URL
2. **Local Storage**: Set `chatgpt-converter-debug` to `true` in browser localStorage

### Programmatic Configuration

You can configure the logger programmatically:

```javascript
import { configureLogger, setLogLevel, LOG_LEVELS } from './src/utils/logger.js';

// Set log level
setLogLevel('DEBUG'); // or 'ERROR', 'WARN', 'INFO', 'TRACE'

// Configure multiple options
configureLogger({
    level: LOG_LEVELS.DEBUG,
    enableConsole: true,
    enableExternal: false,
    externalLogger: null
});
```

## External Logging Integration

The logging system is designed to support external logging services like Datadog:

```javascript
import { configureLogger, LOG_LEVELS } from './src/utils/logger.js';

// Configure external logging
configureLogger({
    level: LOG_LEVELS.INFO,
    enableConsole: true,
    enableExternal: true,
    externalLogger: (logEntry) => {
        // Send to Datadog or other service
        datadogLogger.log(logEntry);
    }
});
```

## Log Entry Format

Each log entry includes:

```javascript
{
    timestamp: "2024-01-15T10:30:00.000Z",
    level: "INFO",
    message: "Application initialized successfully",
    data: null, // Optional additional data
    context: {
        userAgent: "Mozilla/5.0...",
        url: "https://example.com"
    }
}
```

## Usage Examples

### Basic Logging

```javascript
import { logInfo, logWarn, logError, logDebug } from './src/utils/logger.js';

logInfo('Application started');
logWarn('File size is large');
logError('Failed to save file', error);
logDebug('Processing file', { filename: 'conversations.json', size: 1024 });
```

### Conditional Debugging

```javascript
import { logDebug } from './src/utils/logger.js';

// This will only log when debug mode is enabled
logDebug('Processing conversation', { id: conversation.id, title: conversation.title });
```

## Migration from console.log

The logging system replaces excessive `console.log` statements with appropriate log levels:

- **console.log** → `logInfo()` or `logDebug()` depending on importance
- **console.warn** → `logWarn()`
- **console.error** → `logError()`

## Benefits

1. **Reduced Console Noise**: Only important messages are shown by default
2. **Configurable Verbosity**: Enable detailed logging when needed
3. **External Integration Ready**: Easy to integrate with monitoring services
4. **Structured Data**: Consistent log format with timestamps and context
5. **Performance**: Debug logs are completely skipped when not needed

## Debug Mode

To enable debug mode for development:

1. **Browser**: Add `?debug=true` to the URL
2. **Permanent**: Set `localStorage.setItem('chatgpt-converter-debug', 'true')`
3. **Programmatic**: Call `setLogLevel('DEBUG')`

Debug mode will show all log levels including detailed debugging information about:
- File processing steps
- Directory scanning operations
- Column sorting events
- API detection results
</file>

<file path=".cursor.json">
{
    "name": "ChatGPT to Obsidian Converter",
    "version": "1.0.0",
    "description": "Convert ChatGPT conversation exports into Obsidian-compatible Markdown files with clean formatting, chronological naming, and local folder saving.",
    "instructions": "Always follow AGENTS.md when working in this repository. It defines strict rules for git workflow, testing, code structure, and design style.",
    "rules": [
      "@AGENTS.md"
    ],
    "composer": {
      "include": [
        "AGENTS.md",
        "test-vite-react/"
      ]
    },
    "chat": {
      "include": [
        "AGENTS.md"
      ]
    },
    "context": {
      "technologies": [
        "JavaScript",
        "Python",
        "HTML/CSS",
        "File System Access API",
        "Web APIs",
        "Vercel"
      ],
      "patterns": [
        "Privacy-first browser processing",
        "Progressive enhancement",
        "Cross-platform consistency",
        "Chronological file ordering",
        "Human-readable filenames",
        "Obsidian-compatible markdown formatting"
      ]
    }
  }
</file>

<file path=".cursorrules">
always_include: AGENTS.md

@AGENTS.md

Follow the guidelines and conventions outlined in AGENTS.md when working on this repository. This document contains important information about:

- Git workflow and branch management
- Deployment considerations
- Code quality standards  
- Testing requirements
- Repository structure
- Collaboration patterns

Always refer to AGENTS.md for the complete set of guidelines and ensure all contributions align with these standards.
</file>

<file path="AGENTS.md">
# AGENTS.md (Minimal Agent Rules)

> You are an AI agent working on this repository. You must follow all rules below.

---

## @RULE: WORKFLOW
- NEVER commit to `main`. Use a feature branch + pull request.
- Always rebase or merge latest `main` before a PR.
- Write descriptive commit messages summarizing what and why.

## @RULE: FILES
- ✅ Only modify: `src/`, `test-vite-react/`, config files.
- ❌ DO NOT touch: `index.html`, public folder, or move top-level dirs.

## @RULE: TESTING
- 🔁 After EVERY code or UI change, run `npm test`.
- ⛔ STOP immediately if any test fails — do not proceed.
- 🧪 If logic or UI is added or changed, create or update a matching test.
- 🧼 Prefer colocated tests in `test-vite-react/tests/`.
- ✅ Ensure HTML and React test versions stay aligned.

## @RULE: DESIGN STYLE
- Use dark theme with subtle contrast and minimal visuals.
- Match current spacing, 14–16px sans-serif typography.
- Reuse card components, icon patterns, and layout structure.

## @RULE: SAFETY
- Do not add large libraries unless explicitly instructed.
- Do not change exports or public APIs without writing tests.
- If unclear on a task, stop and request clarification before proceeding.

## ✅ CHECKLIST (BEFORE PR)
- [ ] All tests pass (`npm test`)
- [ ] All changes have matching tests
- [ ] Commit message is clear
- [ ] Design and layout follow current style
- [ ] Any unclear requirements were confirmed
</file>

<file path="src/main.js">
/**
 * Main Application Entry Point
 * Initializes the ChatGPT to Markdown converter with clean architecture
 * Following AGENTS.md principle: clean separation of concerns and initialization
 */

import { ChatGPTConverter } from './modules/applicationOrchestrator.js';
import { logInfo, logError, configureLogger } from './utils/logger.js';
import { LOGGING_CONFIG } from './utils/constants.js';

/**
 * Global application instance
 * WHY: Provides single point of control for the application
 */
let converterApp = null;

/**
 * Initialize the application
 * WHY: Sets up the application and provides error handling for initialization
 */
function initializeApplication() {
    try {
        // Configure logging
        configureLogger({ level: LOGGING_CONFIG.DEFAULT_LEVEL });
        
        // Create application instance
        converterApp = new ChatGPTConverter();
        
        // Add global error handling
        window.addEventListener('error', handleGlobalError);
        window.addEventListener('unhandledrejection', handleUnhandledRejection);
        
        // Add pulse animation CSS if not present
        addPulseAnimation();
        
        // Add screen reader only styles if not present
        addAccessibilityStyles();
        
        logInfo('🚀 Application initialized successfully');
        
    } catch (error) {
        logError('❌ Failed to initialize application:', error);
        showFallbackError('Failed to initialize application. Please refresh the page.');
    }
}

/**
 * Handle global JavaScript errors
 * WHY: Provides graceful error handling and user feedback
 * 
 * @param {ErrorEvent} event - Error event
 */
function handleGlobalError(event) {
    logError('Global error:', event.error);
    
    // Don't show user errors for known harmless issues
    if (event.error?.message?.includes('Non-Error promise rejection')) {
        return;
    }
    
    showFallbackError('An unexpected error occurred. Please try refreshing the page.');
}

/**
 * Handle unhandled promise rejections
 * WHY: Catches async errors that might otherwise be silent
 * 
 * @param {PromiseRejectionEvent} event - Rejection event
 */
function handleUnhandledRejection(event) {
    logError('Unhandled promise rejection:', event.reason);
    
    // Don't show user errors for known harmless issues
    if (event.reason?.name === 'AbortError') {
        return; // User cancelled operation
    }
    
    showFallbackError('An error occurred during processing. Please try again.');
}

/**
 * Show fallback error message when normal UI is unavailable
 * WHY: Ensures users always get feedback even when application fails to initialize
 * 
 * @param {string} message - Error message to display
 */
function showFallbackError(message) {
    // Try to find status element first
    const statusElement = document.getElementById('statusText');
    if (statusElement) {
        statusElement.textContent = message;
        statusElement.className = 'status error';
        statusElement.setAttribute('role', 'alert');
        return;
    }
    
    // Fallback: create error display
    const errorDiv = document.createElement('div');
    errorDiv.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #f8d7da;
        color: #721c24;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #f5c6cb;
        z-index: 9999;
        max-width: 500px;
        text-align: center;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    `;
    errorDiv.setAttribute('role', 'alert');
    errorDiv.textContent = message;
    
    document.body.appendChild(errorDiv);
    
    // Auto-remove after 10 seconds
    setTimeout(() => {
        if (errorDiv.parentNode) {
            errorDiv.remove();
        }
    }, 10000);
}

/**
 * Add pulse animation CSS for save button
 * WHY: Provides visual feedback for save button state
 */
function addPulseAnimation() {
    if (document.getElementById('pulseStyle')) return;
    
    const style = document.createElement('style');
    style.id = 'pulseStyle';
    style.textContent = `
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
    `;
    document.head.appendChild(style);
}

/**
 * Add screen reader only styles for accessibility
 * WHY: Ensures screen reader content is properly hidden visually
 */
function addAccessibilityStyles() {
    if (document.getElementById('accessibilityStyles')) return;
    
    const style = document.createElement('style');
    style.id = 'accessibilityStyles';
    style.textContent = `
        .sr-only {
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            padding: 0 !important;
            margin: -1px !important;
            overflow: hidden !important;
            clip: rect(0, 0, 0, 0) !important;
            white-space: nowrap !important;
            border: 0 !important;
        }
        
        /* Focus styles for better keyboard navigation */
        .upload-area:focus,
        .btn:focus,
        button:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }
        
        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .btn {
                border: 2px solid currentColor;
            }
            
            .upload-area {
                border-width: 3px;
                border-style: solid;
            }
        }
        
        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            .progress-fill,
            .btn,
            .upload-area {
                transition: none !important;
                animation: none !important;
            }
        }
    `;
    document.head.appendChild(style);
}

/**
 * Get current application instance
 * WHY: Allows external access to application for debugging or extensions
 * 
 * @returns {ChatGPTConverter|null} - Current application instance
 */
function getApplicationInstance() {
    return converterApp;
}

/**
 * Restart the application
 * WHY: Allows recovery from errors or reset of state
 */
function restartApplication() {
    if (converterApp) {
        converterApp.reset();
    }
    
    // Clear any error displays
    const errorElements = document.querySelectorAll('[role="alert"]');
    errorElements.forEach(el => {
        if (el.parentNode && !el.id) { // Don't remove permanent elements
            el.remove();
        }
    });
    
    initializeApplication();
}

// Export for potential external use
window.ChatGPTConverterApp = {
    getInstance: getApplicationInstance,
    restart: restartApplication
};



// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApplication);
} else {
    // DOM already loaded
    initializeApplication();
}
</file>

<file path="test-vite-react/tests/unit/fileSystemManager.test.js">
/**
 * Unit Tests for File System Manager
 * Testing file saving, directory operations, and cancellation functionality
 * Following AGENTS.md principle: comprehensive module testing
 */

import { describe, test, expect, beforeEach, jest } from '@jest/globals';

// Mock the file system manager module
const fileSystemManager = {
    saveFilesChronologically: jest.fn(),
    scanForExistingFiles: jest.fn(),
    saveFileToDirectory: jest.fn(),
    delay: jest.fn()
};

// Mock the logger
const logger = {
    logInfo: jest.fn(),
    logWarn: jest.fn(),
    logError: jest.fn()
};

// Mock the constants
const constants = {
    PROCESSING_CONFIG: {
        DELAY_BETWEEN_FILES_MS: 100
    }
};

describe('File System Manager', () => {
    
    describe('saveFilesChronologically', () => {
        let mockDirectoryHandle;
        let mockFiles;

        beforeEach(() => {
            mockDirectoryHandle = {
                name: 'test-folder',
                getFileHandle: jest.fn(),
                getDirectoryHandle: jest.fn()
            };

            mockFiles = [
                { filename: 'test1.md', content: '# Test 1' },
                { filename: 'test2.md', content: '# Test 2' },
                { filename: 'test3.md', content: '# Test 3' }
            ];

            // Reset all mocks
            jest.clearAllMocks();
        });

        test('should save files chronologically without cancellation', async () => {
            // Mock the return value for saveFilesChronologically
            fileSystemManager.saveFilesChronologically.mockResolvedValue({
                successCount: 3,
                errorCount: 0,
                cancelledCount: 0,
                results: [
                    { success: true, filename: 'test1.md' },
                    { success: true, filename: 'test2.md' },
                    { success: true, filename: 'test3.md' }
                ],
                totalProcessed: 3,
                userChoice: 'proceed',
                duplicatesFound: 0,
                scanErrors: [],
                scanAge: 0
            });

            const progressCallback = jest.fn();
            const results = await fileSystemManager.saveFilesChronologically(
                mockFiles, 
                mockDirectoryHandle, 
                progressCallback
            );

            expect(results.successCount).toBe(3);
            expect(results.errorCount).toBe(0);
            expect(results.cancelledCount).toBe(0);
            expect(results.totalProcessed).toBe(3);
            expect(results.userChoice).toBe('proceed');
            expect(results.duplicatesFound).toBe(0);
        });

        test('should handle cancellation during save operation', async () => {
            // Mock the return value for saveFilesChronologically with cancellation
            fileSystemManager.saveFilesChronologically.mockResolvedValue({
                successCount: 1,
                errorCount: 0,
                cancelledCount: 2,
                results: [
                    { success: true, filename: 'test1.md' },
                    { success: false, cancelled: true, message: 'Save operation cancelled by user', filename: 'test2.md' },
                    { success: false, cancelled: true, message: 'Save operation cancelled by user', filename: 'test3.md' }
                ],
                totalProcessed: 3,
                userChoice: 'proceed',
                duplicatesFound: 0,
                scanErrors: [],
                scanAge: 0,
                userCancelled: true
            });

            const progressCallback = jest.fn();
            const cancellationCallback = jest.fn(() => true);

            const results = await fileSystemManager.saveFilesChronologically(
                mockFiles, 
                mockDirectoryHandle, 
                progressCallback,
                cancellationCallback
            );

            // Should have saved 1 file, cancelled 2 files
            expect(results.successCount).toBe(1);
            expect(results.cancelledCount).toBe(2);
            expect(results.errorCount).toBe(0);
            expect(results.userCancelled).toBe(true);
            
            // Verify cancelled files have correct message
            const cancelledResults = results.results.filter(r => r.cancelled);
            expect(cancelledResults).toHaveLength(2);
            cancelledResults.forEach(result => {
                expect(result.message).toBe('Save operation cancelled by user');
            });
        });

        test('should handle immediate cancellation', async () => {
            // Mock the return value for saveFilesChronologically with immediate cancellation
            fileSystemManager.saveFilesChronologically.mockResolvedValue({
                successCount: 0,
                errorCount: 0,
                cancelledCount: 3,
                results: [
                    { success: false, cancelled: true, message: 'Save operation cancelled by user', filename: 'test1.md' },
                    { success: false, cancelled: true, message: 'Save operation cancelled by user', filename: 'test2.md' },
                    { success: false, cancelled: true, message: 'Save operation cancelled by user', filename: 'test3.md' }
                ],
                totalProcessed: 3,
                userChoice: 'proceed',
                duplicatesFound: 0,
                scanErrors: [],
                scanAge: 0,
                userCancelled: true
            });

            const progressCallback = jest.fn();
            const cancellationCallback = jest.fn(() => true); // Always return true

            const results = await fileSystemManager.saveFilesChronologically(
                mockFiles, 
                mockDirectoryHandle, 
                progressCallback,
                cancellationCallback
            );

            // Should have cancelled all files
            expect(results.successCount).toBe(0);
            expect(results.cancelledCount).toBe(3);
            expect(results.errorCount).toBe(0);
            expect(results.userCancelled).toBe(true);
        });

        test('should handle scan failure', async () => {
            // Mock the return value for saveFilesChronologically with scan failure
            fileSystemManager.saveFilesChronologically.mockResolvedValue({
                successCount: 0,
                errorCount: 3,
                cancelledCount: 0,
                results: [
                    { success: false, cancelled: false, message: 'Scan failed: Scan failed', filename: 'test1.md' },
                    { success: false, cancelled: false, message: 'Scan failed: Scan failed', filename: 'test2.md' },
                    { success: false, cancelled: false, message: 'Scan failed: Scan failed', filename: 'test3.md' }
                ],
                totalProcessed: 0,
                scanFailed: true
            });

            const progressCallback = jest.fn();
            const results = await fileSystemManager.saveFilesChronologically(
                mockFiles, 
                mockDirectoryHandle, 
                progressCallback
            );

            expect(results.successCount).toBe(0);
            expect(results.errorCount).toBe(3);
            expect(results.cancelledCount).toBe(0);
            expect(results.scanFailed).toBe(true);
        });

        test('should handle user cancellation during duplicate dialog', async () => {
            // Mock the return value for saveFilesChronologically with user cancellation
            fileSystemManager.saveFilesChronologically.mockResolvedValue({
                successCount: 0,
                errorCount: 0,
                cancelledCount: 2,
                results: [
                    { success: false, cancelled: true, message: 'Bulk operation cancelled by user', filename: 'test1.md' },
                    { success: false, cancelled: true, message: 'Bulk operation cancelled by user', filename: 'test2.md' }
                ],
                totalProcessed: 0,
                userCancelled: true
            });

            const progressCallback = jest.fn();
            const results = await fileSystemManager.saveFilesChronologically(
                mockFiles, 
                mockDirectoryHandle, 
                progressCallback
            );

            expect(results.userCancelled).toBe(true);
            expect(results.successCount).toBe(0);
            expect(results.cancelledCount).toBe(2);
        });

        test('should update progress bar with correct total when skipping duplicates', async () => {
            // Mock the return value for saveFilesChronologically with skip duplicates
            fileSystemManager.saveFilesChronologically.mockResolvedValue({
                successCount: 2,
                errorCount: 0,
                cancelledCount: 2,
                results: [
                    { success: false, cancelled: true, message: 'File "existing1.md" already exists and was skipped.', filename: 'existing1.md', skipped: true },
                    { success: false, cancelled: true, message: 'File "existing2.md" already exists and was skipped.', filename: 'existing2.md', skipped: true },
                    { success: true, filename: 'new1.md' },
                    { success: true, filename: 'new2.md' }
                ],
                totalProcessed: 4,
                userChoice: 'skip',
                duplicatesFound: 2,
                scanErrors: [],
                scanAge: 0
            });

            const progressCallback = jest.fn();
            const results = await fileSystemManager.saveFilesChronologically(
                mockFiles, 
                mockDirectoryHandle, 
                progressCallback
            );

            expect(results.successCount).toBe(2);
            expect(results.cancelledCount).toBe(2);
            expect(results.userChoice).toBe('skip');
            expect(results.duplicatesFound).toBe(2);

            // Verify that the function was called with the progress callback
            expect(fileSystemManager.saveFilesChronologically).toHaveBeenCalledWith(
                mockFiles,
                mockDirectoryHandle,
                progressCallback
            );
        });

        test('should accept cancellation callback parameter', async () => {
            // Test that the function accepts the cancellation callback parameter
            fileSystemManager.saveFilesChronologically.mockResolvedValue({
                successCount: 3,
                errorCount: 0,
                cancelledCount: 0,
                results: [],
                totalProcessed: 3,
                userChoice: 'proceed',
                duplicatesFound: 0,
                scanErrors: [],
                scanAge: 0
            });

            const progressCallback = jest.fn();
            const cancellationCallback = jest.fn(() => false);

            await fileSystemManager.saveFilesChronologically(
                mockFiles, 
                mockDirectoryHandle, 
                progressCallback,
                cancellationCallback
            );

            // Verify the function was called with all parameters
            expect(fileSystemManager.saveFilesChronologically).toHaveBeenCalledWith(
                mockFiles,
                mockDirectoryHandle,
                progressCallback,
                cancellationCallback
            );
        });
    });
});
</file>

<file path="test-vite-react/tests/unit/progressDisplay.test.js">
/**
 * Unit Tests for Progress Display Component
 * Testing progress display functionality and cancel button
 * Following AGENTS.md principle: comprehensive component testing
 */

import { describe, test, expect, beforeEach, afterEach, jest } from '@jest/globals';

// Mock DOM environment
document.body.innerHTML = `
    <div id="progressContainer"></div>
    <div id="conversionProgressContainer"></div>
    <div id="progressCard" class="hidden" style="display: none;"></div>
    <div id="conversionProgressCard" class="hidden" style="display: none;"></div>
    <div id="uploadCard" style="display: block;"></div>
`;

// Mock the constants
const constants = {
    STATUS_MESSAGES: {
        PROCESSING: 'Processing conversations...'
    }
};

// Mock the logger
const logger = {
    logInfo: jest.fn(),
    logWarn: jest.fn(),
    logError: jest.fn()
};

describe('Progress Display Component', () => {
    let ProgressDisplay;
    let progressDisplay;

    beforeEach(() => {
        // Reset DOM (recreate if needed)
        if (!document.getElementById('progressContainer')) {
            document.body.innerHTML = `
                <div id="progressContainer"></div>
                <div id="conversionProgressContainer"></div>
                <div id="progressCard" class="hidden" style="display: none;"></div>
                <div id="conversionProgressCard" class="hidden" style="display: none;"></div>
                <div id="uploadCard" style="display: block;"></div>
            `;
        } else {
            document.getElementById('progressContainer').innerHTML = '';
            document.getElementById('conversionProgressContainer').innerHTML = '';
            document.getElementById('progressCard').style.display = 'none';
            document.getElementById('conversionProgressCard').style.display = 'none';
            document.getElementById('uploadCard').style.display = 'block';
        }
        
        // Reset mocks
        jest.clearAllMocks();
        
        // Mock window.switchToView (do not redefine window)
        if (!global.window) global.window = {};
        global.window.switchToView = jest.fn();
        
        // Mock the module imports
        jest.doMock('../../../src/utils/constants.js', () => constants);
        jest.doMock('../../../src/utils/logger.js', () => logger);
        
        // Import the component
        const module = require('../../../src/components/ProgressDisplay.js');
        ProgressDisplay = module.ProgressDisplay;
        
        progressDisplay = new ProgressDisplay('progressContainer');
    });

    afterEach(() => {
        jest.dontMock('../../../src/utils/constants.js');
        jest.dontMock('../../../src/utils/logger.js');
    });

    describe('initialization', () => {
        test('should initialize with correct container', () => {
            expect(progressDisplay.container).toBeDefined();
            expect(progressDisplay.container.id).toBe('progressContainer');
        });

        test('should handle missing container gracefully', () => {
            const invalidProgressDisplay = new ProgressDisplay('nonexistent');
            expect(invalidProgressDisplay.container).toBeNull();
        });
    });

    describe('show method', () => {
        test('should show progress display without cancel button by default', () => {
            progressDisplay.show();
            
            expect(progressDisplay.isVisible).toBe(true);
            expect(progressDisplay.container.style.display).toBe('block');
            
            const cancelButton = progressDisplay.cancelButton;
            expect(cancelButton.className).toContain('hidden');
        });

        test('should show progress display with cancel button when requested', () => {
            progressDisplay.show(true);
            
            expect(progressDisplay.isVisible).toBe(true);
            expect(progressDisplay.container.style.display).toBe('block');
            
            const cancelButton = progressDisplay.cancelButton;
            expect(cancelButton.className).not.toContain('hidden');
            expect(cancelButton.disabled).toBe(false);
        });
    });

    describe('hide method', () => {
        test('should hide progress display', () => {
            progressDisplay.show();
            expect(progressDisplay.isVisible).toBe(true);
            
            progressDisplay.hide();
            
            expect(progressDisplay.isVisible).toBe(false);
            expect(progressDisplay.container.style.display).toBe('none');
        });
    });

    describe('updateProgress method', () => {
        test('should update progress with percentage and message', () => {
            progressDisplay.show();
            
            progressDisplay.updateProgress(50, 'Halfway done');
            
            const statusText = progressDisplay.statusText;
            expect(statusText.getAttribute('aria-valuenow')).toBe('50');
            expect(statusText.textContent).toBe('Halfway done');
        });

        test('should handle 100% completion styling', () => {
            progressDisplay.show();
            
            progressDisplay.updateProgress(100, 'Complete');
            
            const statusText = progressDisplay.statusText;
            expect(statusText.className).toContain('success');
        });
    });

    describe('showError method', () => {
        test('should display error message with correct styling', () => {
            progressDisplay.show();
            
            progressDisplay.showError('Something went wrong');
            
            const statusText = progressDisplay.statusText;
            expect(statusText.textContent).toBe('Something went wrong');
            expect(statusText.className).toContain('error');
            expect(statusText.getAttribute('role')).toBe('alert');
        });
    });

    describe('cancel button functionality', () => {
        test('should set cancel callback', () => {
            const mockCallback = jest.fn();
            progressDisplay.setCancelCallback(mockCallback);
            
            expect(progressDisplay.onCancelCallback).toBe(mockCallback);
        });

        test('should handle cancel button click', () => {
            const mockCallback = jest.fn();
            progressDisplay.setCancelCallback(mockCallback);
            progressDisplay.show(true);
            
            // Simulate cancel button click
            progressDisplay.handleCancel();
            
            expect(mockCallback).toHaveBeenCalled();
            expect(progressDisplay.cancelButton.disabled).toBe(true);
            expect(progressDisplay.cancelButton.textContent).toContain('Cancelling...');
        });

        test('should handle cancel button click without callback', () => {
            progressDisplay.show(true);
            
            // Should not throw error when no callback is set
            expect(() => {
                progressDisplay.handleCancel();
            }).not.toThrow();
        });
    });

    describe('DOM structure', () => {
        test('should create correct DOM structure on initialization', () => {
            progressDisplay.initialize();
            
            const statusText = progressDisplay.container.querySelector('#statusText');
            const cancelButton = progressDisplay.container.querySelector('#cancelButton');
            
            expect(statusText).toBeDefined();
            expect(statusText.getAttribute('role')).toBe('progressbar');
            expect(statusText.getAttribute('aria-live')).toBe('polite');
            
            expect(cancelButton).toBeDefined();
            expect(cancelButton.id).toBe('cancelButton');
            expect(cancelButton.className).toContain('bg-gray-500');
        });
    });

    describe('Progress bar visibility logic', () => {
        test('should show only one progress bar at a time', () => {
            jest.useFakeTimers();
            // Mock DOM elements
            const mockProgressCard = { style: { display: 'none' }, classList: { remove: jest.fn(), add: jest.fn() } };
            const mockConversionProgressCard = { style: { display: 'none' }, classList: { remove: jest.fn(), add: jest.fn() } };

            // Mock document.getElementById
            const originalGetElementById = document.getElementById;
            document.getElementById = jest.fn((id) => {
                if (id === 'progressCard') return mockProgressCard;
                if (id === 'conversionProgressCard') return mockConversionProgressCard;
                return originalGetElementById.call(document, id);
            });

            try {
                // Test conversion progress (should show conversion card)
                progressDisplay.show(false, false);
                jest.runAllTimers();
                expect(mockConversionProgressCard.classList.remove).toHaveBeenCalledWith('hidden');
                expect(mockProgressCard.classList.remove).not.toHaveBeenCalled();

                // Reset display
                mockProgressCard.style.display = 'none';
                mockConversionProgressCard.style.display = 'none';

                // Test save progress (should show files card)
                progressDisplay.show(true, true);
                jest.runAllTimers();
                expect(mockProgressCard.style.display).toBe('block');
            } finally {
                // Restore original function
                document.getElementById = originalGetElementById;
                jest.useRealTimers();
            }
        });

        test('should visually update progress bar width', () => {
            progressDisplay.initialize();
            progressDisplay.show();
            
            // Test 0% progress
            progressDisplay.updateProgress(0, 'Starting...');
            expect(progressDisplay.progressFill.style.width).toBe('0%');
            
            // Test 50% progress
            progressDisplay.updateProgress(50, 'Halfway...');
            expect(progressDisplay.progressFill.style.width).toBe('50%');
            
            // Test 100% progress
            progressDisplay.updateProgress(100, 'Complete');
            expect(progressDisplay.progressFill.style.width).toBe('100%');
            expect(progressDisplay.statusText.className).toContain('success');
        });

        test('should handle progress values outside 0-100 range', () => {
            progressDisplay.initialize();
            progressDisplay.show();
            
            // Test negative value
            progressDisplay.updateProgress(-10, 'Negative');
            expect(progressDisplay.progressFill.style.width).toBe('0%');
            
            // Test value over 100
            progressDisplay.updateProgress(150, 'Over 100');
            expect(progressDisplay.progressFill.style.width).toBe('100%');
        });

        test('should hide upload card during conversion progress', () => {
            const uploadCard = document.getElementById('uploadCard');
            expect(uploadCard.style.display).toBe('block'); // Initially visible
            
            progressDisplay.initialize();
            progressDisplay.show(false, false); // Conversion progress (not files view)
            
            expect(uploadCard.style.display).toBe('none'); // Should be hidden
        });

        test('should show upload card again when progress is hidden', () => {
            const uploadCard = document.getElementById('uploadCard');
            expect(uploadCard.style.display).toBe('block'); // Initially visible
            
            progressDisplay.initialize();
            progressDisplay.show(false, false); // Conversion progress
            expect(uploadCard.style.display).toBe('none'); // Hidden during progress
            
            progressDisplay.hide();
            expect(uploadCard.style.display).toBe('block'); // Should be visible again
        });

        test('should not hide upload card during files view progress', () => {
            const uploadCard = document.getElementById('uploadCard');
            expect(uploadCard.style.display).toBe('block'); // Initially visible
            
            progressDisplay.initialize();
            progressDisplay.show(true, true); // Files view progress
            
            expect(uploadCard.style.display).toBe('block'); // Should remain visible
        });
    });
});
</file>

<file path="test-vite-react/package.json">
{
  "name": "chatgpt-converter-tests",
  "version": "1.0.0",
  "description": "Test suite for ChatGPT to Markdown Converter",
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:integration": "jest --testPathPattern=integration",
    "test:unit": "jest --testPathPattern=unit"
  },
  "devDependencies": {
    "@babel/core": "^7.23.6",
    "@babel/preset-env": "^7.23.6",
    "@jest/globals": "^29.7.0",
    "babel-jest": "^29.7.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0"
  },
  "jest": {
    "testEnvironment": "jsdom",
    "setupFilesAfterEnv": ["<rootDir>/tests/setup.js"],
    "testMatch": [
      "<rootDir>/tests/**/*.test.js"
    ],
    "collectCoverageFrom": [
      "../src/**/*.js",
      "!../src/**/*.test.js"
    ],
    "coverageDirectory": "coverage",
    "coverageReporters": ["text", "html", "lcov"],
    "moduleFileExtensions": ["js", "json"],
    "transform": {
      "^.+\\.(js|jsx)$": "babel-jest"
    },
    "transformIgnorePatterns": [
      "node_modules/(?!(module-that-needs-to-be-transformed)/)"
    ],
    "testTimeout": 10000
  }
}
</file>

<file path="package.json">
{
  "name": "chatgpt-cursor-import",
  "version": "1.0.0",
  "description": "Convert ChatGPT conversation exports to clean Markdown files",
  "main": "index.html",
  "scripts": {
    "start": "kill-port 5173 && vite",
    "dev": "kill-port 5173 && vite",
    "build": "echo 'Static site - no build required' && exit 0",
    "deploy": "vercel --prod",
    "test": "cd test-vite-react && npm test",
    "test:install": "cd test-vite-react && npm install",
    "test:watch": "cd test-vite-react && npm run test:watch",
    "test:coverage": "cd test-vite-react && npm run test:coverage",
    "test:python": "python3 -m pytest tests/ -v",
    "test:all": "npm run test:python && npm run test"
  },
  "keywords": [
    "chatgpt",
    "markdown",
    "converter",
    "export",
    "conversation"
  ],
  "author": "Your Name",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/yourusername/chatgpt-cursor-import.git"
  },
  "engines": {
    "node": ">=14.0.0"
  },
  "devDependencies": {
    "kill-port": "^2.0.1",
    "vite": "^7.0.6"
  },
  "files": [
    "index.html",
    "src/",
    "chatgpt_converter.py",
    "example_conversations.json",
    "README.md",
    "AGENTS.md"
  ]
}
</file>

<file path="src/components/FileUploader.js">
/**
 * File Uploader Component
 * Accessible drag-and-drop file uploader with keyboard support
 * Following AGENTS.md principle: semantic HTML, ARIA attributes, keyboard navigation
 */

import { isValidJsonFile } from '../utils/helpers.js';
import { UI_CONFIG, ERROR_MESSAGES } from '../utils/constants.js';
import { logError } from '../utils/logger.js';

/**
 * File Uploader Component Class
 * WHY: Encapsulates file upload logic with full accessibility support
 */
export class FileUploader {
    constructor(uploadAreaId, fileInputId) {
        // Support both old and new dropzone IDs
        this.uploadArea = document.getElementById('dropzone') || document.getElementById(uploadAreaId);
        this.fileInput = document.getElementById(fileInputId);
        this.onFileSelected = null;
        this.isProcessing = false;
        
        this.validateElements();
        this.initializeAccessibility();
        this.attachEventListeners();
    }

    /**
     * Validate required DOM elements exist
     * WHY: Prevents runtime errors if elements are missing
     */
    validateElements() {
        if (!this.uploadArea) {
            throw new Error(`Upload area element with id 'uploadArea' not found`);
        }
        if (!this.fileInput) {
            throw new Error(`File input element with id 'fileInput' not found`);
        }
    }

    /**
     * Initialize accessibility features
     * WHY: Ensures component is usable by all users including keyboard and screen reader users
     */
    initializeAccessibility() {
        // Set up proper ARIA attributes
        this.uploadArea.setAttribute('tabindex', '0');
        this.uploadArea.setAttribute('role', 'button');
        this.uploadArea.setAttribute('aria-label', 'Upload area for ChatGPT conversations.json file');
        
        // Ensure file input is properly labeled
        if (!this.fileInput.getAttribute('aria-label')) {
            this.fileInput.setAttribute('aria-label', 'Select conversations.json file');
        }
    }

    /**
     * Attach all event listeners
     * WHY: Sets up user interaction handling for upload functionality
     */
    attachEventListeners() {
        // Click events
        this.uploadArea.addEventListener('click', this.handleUploadAreaClick.bind(this));
        
        // File input change
        this.fileInput.addEventListener('change', this.handleFileInputChange.bind(this));
        
        // Drag and drop events
        this.uploadArea.addEventListener('dragover', this.handleDragOver.bind(this));
        this.uploadArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
        this.uploadArea.addEventListener('drop', this.handleDrop.bind(this));
        
        // Keyboard events for accessibility
        this.uploadArea.addEventListener('keydown', this.handleKeyDown.bind(this));
        
        // Prevent default drag behaviors on the window
        window.addEventListener('dragover', (e) => e.preventDefault());
        window.addEventListener('drop', (e) => e.preventDefault());
    }

    /**
     * Handle upload area click
     * WHY: Provides intuitive click-to-upload functionality
     */
    handleUploadAreaClick(event) {
        if (this.isProcessing) return;
        
        this.fileInput.click();
    }

    /**
     * Handle file input change
     * WHY: Processes selected files from input element
     */
    handleFileInputChange(event) {
        const files = event.target.files;
        if (files && files.length > 0) {
            this.processFile(files[0]);
        }
    }

    /**
     * Handle drag over event
     * WHY: Provides visual feedback during drag operations
     */
    handleDragOver(event) {
        event.preventDefault();
        event.stopPropagation();
        
        if (this.isProcessing) return;
        
        // Use new Tailwind active class instead of dragover
        this.uploadArea.classList.add('active');
        event.dataTransfer.dropEffect = 'copy';
    }

    /**
     * Handle drag leave event
     * WHY: Removes visual feedback when drag leaves area
     */
    handleDragLeave(event) {
        event.preventDefault();
        event.stopPropagation();
        
        // Only remove active class if actually leaving the upload area
        if (!this.uploadArea.contains(event.relatedTarget)) {
            this.uploadArea.classList.remove('active');
        }
    }

    /**
     * Handle drop event
     * WHY: Processes dropped files
     */
    handleDrop(event) {
        event.preventDefault();
        event.stopPropagation();
        
        this.uploadArea.classList.remove('active');
        
        if (this.isProcessing) return;
        
        const files = event.dataTransfer.files;
        if (files && files.length > 0) {
            this.processFile(files[0]);
        }
    }

    /**
     * Handle keyboard navigation
     * WHY: Ensures keyboard accessibility for the upload area
     */
    handleKeyDown(event) {
        if (this.isProcessing) return;
        
        // Activate on Enter or Space
        if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            this.fileInput.click();
        }
    }

    /**
     * Process selected file
     * WHY: Validates and handles file processing with proper feedback
     * 
     * @param {File} file - Selected file to process
     */
    processFile(file) {
        try {
            // Validate file type and content
            if (!isValidJsonFile(file)) {
                this.showFileError(ERROR_MESSAGES.INVALID_FILE_TYPE);
                return;
            }
            
            // Clear any previous errors
            this.clearFileError();
            
            // Update UI state
            this.setProcessingState(true);
            
            // Call the callback if set
            if (this.onFileSelected && typeof this.onFileSelected === 'function') {
                this.onFileSelected(file);
            }
            
        } catch (error) {
            logError('Error processing file:', error);
            this.showFileError(ERROR_MESSAGES.FILE_PROCESSING_ERROR);
            this.setProcessingState(false);
        }
    }

    /**
     * Set file selected callback
     * WHY: Allows parent component to handle file processing
     * 
     * @param {Function} callback - Function to call when file is selected
     */
    setFileSelectedCallback(callback) {
        this.onFileSelected = callback;
    }

    /**
     * Set processing state
     * WHY: Updates UI to reflect current processing status
     * 
     * @param {boolean} isProcessing - Whether file is currently being processed
     */
    setProcessingState(isProcessing) {
        this.isProcessing = isProcessing;
        
        // Update button state
        // Removed chooseButton.disabled = isProcessing;
        
        // Update upload area state
        if (isProcessing) {
            this.uploadArea.classList.add('processing');
            this.uploadArea.setAttribute('aria-busy', 'true');
        } else {
            this.uploadArea.classList.remove('processing');
            this.uploadArea.setAttribute('aria-busy', 'false');
        }
        
        // Update visual feedback
        this.updateUploadAreaText(isProcessing);
    }

    /**
     * Update upload area text based on state
     * WHY: Provides contextual feedback to users
     * 
     * @param {boolean} isProcessing - Current processing state
     */
    updateUploadAreaText(isProcessing) {
        // Find text elements using the new structure
        const uploadText = this.uploadArea.querySelector('p.text-lg');
        const uploadSubtext = this.uploadArea.querySelector('p.text-gray-500');
        
        if (uploadText && uploadSubtext) {
            if (isProcessing) {
                uploadText.textContent = 'Processing your file...';
                uploadSubtext.textContent = 'Please wait while we convert your conversations';
            } else {
                uploadText.textContent = 'Drop your conversations.json file here';
                uploadSubtext.textContent = 'or';
            }
        }
    }

    /**
     * Show file error message
     * WHY: Provides clear feedback when file validation fails
     * 
     * @param {string} message - Error message to display
     */
    showFileError(message) {
        // Remove any existing error
        this.clearFileError();
        
        // Create error element with Tailwind styling
        const errorDiv = document.createElement('div');
        errorDiv.className = 'bg-red-50 border-l-4 border-red-500 p-4 mt-4';
        errorDiv.id = 'uploadError';
        errorDiv.setAttribute('role', 'alert');
        
        errorDiv.innerHTML = `
            <div class="flex">
                <div class="flex-shrink-0">
                    <i class="fas fa-exclamation-triangle text-red-500"></i>
                </div>
                <div class="ml-3">
                    <p class="text-sm text-red-700">${message}</p>
                </div>
            </div>
        `;
        
        // Insert after upload area in the upload section
        const uploadSection = document.getElementById('upload-section');
        if (uploadSection) {
            // Find the dropzone and insert the error after it
            const dropzone = uploadSection.querySelector('#dropzone');
            if (dropzone && dropzone.parentNode) {
                dropzone.parentNode.insertBefore(errorDiv, dropzone.nextSibling);
            }
        }
        
        // Reset file input
        this.fileInput.value = '';
    }

    /**
     * Clear file error message
     * WHY: Removes error when user selects a new file
     */
    clearFileError() {
        const existingError = document.getElementById('uploadError');
        if (existingError) {
            existingError.remove();
        }
    }
}
</file>

<file path="test-vite-react/tests/setup.js">
/**
 * Jest Test Environment Setup
 * Configures mocks and global environment for testing
 * Following AGENTS.md principle: reliable test infrastructure
 */

// Enhanced DOM mocking
const createMockElement = (id, tagName = 'div') => {
    const element = {
        id,
        tagName,
        textContent: '',
        innerHTML: '',
        className: '',
        style: {},
        disabled: false,
        onclick: null,
        addEventListener: jest.fn(),
        removeEventListener: jest.fn(),
        appendChild: jest.fn(),
        removeChild: jest.fn(),
        setAttribute: jest.fn(),
        getAttribute: jest.fn(),
        classList: {
            add: jest.fn(),
            remove: jest.fn(),
            contains: jest.fn(),
            toggle: jest.fn()
        },
        querySelector: jest.fn(),
        querySelectorAll: jest.fn(() => []),
        click: jest.fn(),
        focus: jest.fn(),
        blur: jest.fn()
    };
    
    return element;
};

// Mock document with jest.fn() functions  
const mockGetElementById = jest.fn();
const mockCreateElement = jest.fn((tagName) => createMockElement('mock', tagName));
const mockQuerySelector = jest.fn();
const mockQuerySelectorAll = jest.fn(() => []);
const mockAddEventListener = jest.fn();
const mockRemoveEventListener = jest.fn();

// File System Access API Mocks
const mockWritableStream = {
    write: jest.fn(),
    close: jest.fn()
};

const mockFileHandle = {
    requestPermission: jest.fn(),
    createWritable: jest.fn()
};

const mockDirectoryHandle = {
    requestPermission: jest.fn(),
    getFileHandle: jest.fn()
};

// Mock document methods without overriding JSDOM's body property
if (!global.document) {
    global.document = {};
}

// Safely add mock methods to existing document ONLY if not provided by JSDOM
if (typeof global.document.getElementById !== 'function') {
    global.document.getElementById = mockGetElementById;
}
if (typeof global.document.createElement !== 'function') {
    global.document.createElement = mockCreateElement;
}
if (typeof global.document.querySelector !== 'function') {
    global.document.querySelector = mockQuerySelector;
}
if (typeof global.document.querySelectorAll !== 'function') {
    global.document.querySelectorAll = mockQuerySelectorAll;
}
if (typeof global.document.addEventListener !== 'function') {
    global.document.addEventListener = mockAddEventListener;
}
if (typeof global.document.removeEventListener !== 'function') {
    global.document.removeEventListener = mockRemoveEventListener;
}

// Only set body if it doesn't exist (to avoid JSDOM conflicts)
if (!global.document.body) {
    global.document.body = createMockElement('body', 'body');
}

// Mock window with File System Access API support
if (!global.window) {
    global.window = {};
}

// Safely add mock methods and properties to existing window
global.window.showDirectoryPicker = jest.fn();
global.window.addEventListener = jest.fn();
global.window.removeEventListener = jest.fn();

// Only mock location if it doesn't exist or is configurable
if (!global.window.location) {
    global.window.location = {
        protocol: 'https:',
        hostname: 'localhost'
    };
} else {
    // If location exists, just set the properties we need
    try {
        if (global.window.location.protocol !== 'https:') {
            // Only set if different to avoid navigation errors
            Object.defineProperty(global.window.location, 'protocol', { value: 'https:', writable: false });
        }
        if (global.window.location.hostname !== 'localhost') {
            Object.defineProperty(global.window.location, 'hostname', { value: 'localhost', writable: false });
        }
    } catch (e) {
        // If we can't set them, that's ok for tests
    }
}

global.window.isSecureContext = true;

// Mock console to reduce noise in tests
global.console = {
    ...console,
    log: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
    info: jest.fn()
};

// Mock URL APIs
global.URL = {
    createObjectURL: jest.fn(() => 'mock-url'),
    revokeObjectURL: jest.fn()
};

// Mock File APIs
global.FileReader = class MockFileReader {
    constructor() {
        this.onload = null;
        this.onerror = null;
        this.result = null;
    }
    
    readAsText(file) {
        setTimeout(() => {
            if (this.onload) {
                this.result = '{"test": "data"}';
                this.onload({ target: { result: this.result } });
            }
        }, 0);
    }
};

global.Blob = class MockBlob {
    constructor(parts, options) {
        this.parts = parts;
        this.size = parts.join('').length;
        this.type = options?.type || '';
    }
};

// Export utilities for tests using CommonJS
module.exports = { 
    createMockElement,
    mockGetElementById,
    mockCreateElement,
    mockQuerySelector,
    mockQuerySelectorAll,
    mockAddEventListener,
    mockRemoveEventListener
};

// Make mocks available globally for tests
global.testMocks = {
    mockGetElementById,
    mockCreateElement,
    mockQuerySelector,
    mockQuerySelectorAll,
    mockAddEventListener,
    mockRemoveEventListener,
    mockDirectoryHandle,
    mockFileHandle,
    mockWritableStream
};

// Export for ES modules
export const testMocks = global.testMocks;

console.log('🧪 Test environment setup complete');
    console.log('📊 Running ChatGPT to Markdown Converter tests...');

// Global test configuration
global.testConfig = {
    sampleConversation: {
        id: 'test_conversation_001',
        title: 'Test Conversation',
        create_time: 1703522622,
        mapping: {
            'msg_001': {
                message: {
                    author: { role: 'user' },
                    content: { parts: ['What is Python?'] }
                },
                children: ['msg_002'],
                parent: null
            },
            'msg_002': {
                message: {
                    author: { role: 'assistant' },
                    content: { parts: ['Python is a programming language created by Guido van Rossum.'] }
                },
                children: [],
                parent: 'msg_001'
            }
        }
    },
    expectedMarkdown: `# Test Conversation

**Created:** 12/25/2024, 2:30:22 PM

---

**User:**

What is Python?

**Assistant:**

Python is a programming language created by Guido van Rossum.

`,
    expectedFilename: '2024-12-25_test-conversation_test_conversation_001.md'
};
</file>

<file path="README.md">
# ChatGPT to Markdown Converter

Convert your ChatGPT conversation exports into clean Markdown files with intelligent duplicate detection and proper formatting. Available as both a Python command-line tool and a modern web interface.

## 🎯 Features

- **🌐 Web Interface**: Modern drag-and-drop frontend for easy file conversion
- **🐍 Python CLI**: Command-line tool for batch processing and automation
- **🧠 Smart Duplicate Detection**: Automatically skips conversations already imported based on conversation ID
- **✨ Clean Markdown Formatting**: Properly formats conversations with clear author attribution
- **📁 Well-Structured**: Generates files with clean metadata and proper formatting
- **🔒 Safe Filenames**: Automatically slugifies titles and handles special characters
- **📅 Chronological Order**: Files are created oldest-first to match conversation timeline
- **⚡ Vercel Deployment**: Deploy your own instance to Vercel with one click
- **🛡️ Privacy-First**: All processing happens in your browser - no server uploads

## 🚀 Quick Start Options

### Option 1: Web Interface (Recommended)

1. **Use Online**: Visit the deployed version at [your-vercel-url]
2. **Or Run Locally**:
   ```bash
   # Clone the repository
   git clone [your-repo-url]
   cd chatgpt-cursor-import
   
   # Start local server
   python -m http.server 8000
   # Visit http://localhost:8000
   ```

3. **Upload and Convert**:
   - Export your ChatGPT conversations (Settings → Data Controls → Export Data)
   - Drag and drop `conversations.json` into the web interface
   - Choose your destination folder
   - Files are saved directly to the folder you select (no subfolders created)

### Option 2: Python CLI

## 📋 Requirements

- Python 3.6 or higher
- No external dependencies (uses only standard library)

## 🚀 Quick Start

1. **Export your ChatGPT conversations**:
   - Go to ChatGPT Settings → Data Controls → Export Data
   - Download and extract the zip file
   - Locate the `conversations.json` file

2. **Place the export file**:
   ```bash
   # Copy conversations.json to the same directory as the script
   cp /path/to/your/export/conversations.json .
   ```

3. **Run the converter**:
   ```bash
   python chatgpt_converter.py
   ```

4. **Find your converted files**:
   - Files will be created in the `ChatGPT/` directory
   - Filename format: `{date}_{slugified-title}_{conversation-id}.md`
   - Example: `2025-01-20_redis-caching-strategies_abc123xyz.md`

## 📁 Output Structure

### Web Interface
Files are saved directly to your selected folder:
```
YourSelectedFolder/
├── Python Best Practices.md
├── Markdown Best Practices.md
└── Machine Learning Intro.md
```

### Python CLI
Creates organized output in ChatGPT directory:
```
ChatGPT/
├── Python Best Practices.md
├── Markdown Best Practices.md
└── Machine Learning Intro.md
```

Each Markdown file contains:
- Conversation title as H1 header
- Creation timestamp
- Clean message formatting with **User:** and **Assistant:** prefixes
- Proper spacing and readability

## 📝 Example Output

```markdown
# Redis Caching Strategies

**Created:** 2024-12-15 14:30:22

---

**User:**

What are the best practices for implementing Redis caching in a web application?

**Assistant:**

Here are the key best practices for implementing Redis caching:

1. **Choose the right data structures**
   - Use strings for simple key-value pairs
   - Use hashes for objects with multiple fields
   - Use lists for ordered data

2. **Set appropriate TTL values**
   - Consider your data freshness requirements
   - Use different TTLs for different types of data

...
```

## ⚙️ How It Works

### Input Format
The script expects a `conversations.json` file with this structure:
```json
[
  {
    "id": "unique-conversation-id",
    "title": "Conversation Title",
    "create_time": 1703520622.123,
    "mapping": {
      "message-id-1": {
        "message": {
          "author": {"role": "user"},
          "content": {"parts": ["User message text"]}
        },
        "children": ["message-id-2"]
      },
      "message-id-2": {
        "message": {
          "author": {"role": "assistant"},
          "content": {"parts": ["Assistant response"]}
        },
        "parent": "message-id-1"
      }
    }
  }
]
```

### Processing Steps
1. **Parse JSON**: Load and validate the conversations.json file
2. **Check Duplicates**: Scan existing files to identify already-imported conversations
3. **Extract Messages**: Traverse the conversation mapping to reconstruct message flow
4. **Generate Markdown**: Convert messages to clean Markdown format
5. **Create Files**: Write files with standardized naming convention

### Duplicate Detection
The script identifies existing conversations by parsing filenames in the output directory and extracting conversation IDs. This means you can safely run the script multiple times without creating duplicates.

## 🔧 Configuration

The script can be easily modified to customize:

- **Output directory**: Change `output_dir = Path('ChatGPT')` in the `main()` function
- **Filename format**: Modify the `generate_filename()` function
- **Markdown formatting**: Adjust the `convert_conversation_to_markdown()` function
- **Title slug length**: Change the truncation limit in `generate_filename()`

## ⚠️ Troubleshooting

### Common Issues

**"conversations.json not found"**
- Ensure the file is in the same directory as the script
- Check the file is properly extracted from the ChatGPT export

**"Error parsing JSON"**
- Verify the conversations.json file isn't corrupted
- Ensure it contains valid JSON data

**Missing messages in output**
- The script handles various ChatGPT export formats, but complex message structures might need adjustment
- Check the console output for any processing warnings

### File Encoding Issues
If you encounter encoding problems, ensure your conversations.json file is in UTF-8 format.

## 🛠️ Development

### Code Structure
- `slugify()`: Converts titles to filename-safe slugs
- `extract_messages()`: Parses the complex ChatGPT mapping structure
- `convert_conversation_to_markdown()`: Handles Markdown formatting
- `get_existing_conversation_ids()`: Manages duplicate detection
- `main()`: Orchestrates the entire conversion process

### Testing
To test with a small sample:
1. Create a minimal conversations.json with one conversation
2. Run the script and verify output format
3. Run again to test duplicate detection

## 📄 License

This project is open source and available under the MIT License.

## 🚀 Deploying to Vercel

### One-Click Deploy
[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https://github.com/yourusername/chatgpt-cursor-import)

### Manual Deployment

1. **Fork this repository** to your GitHub account

2. **Connect to Vercel**:
   ```bash
   # Install Vercel CLI
   npm i -g vercel
   
   # Deploy
   vercel --prod
   ```

3. **Configure Domain** (optional):
   - Go to your Vercel dashboard
   - Add a custom domain
   - Update DNS settings

### Environment Setup
No environment variables or build steps required! This is a static site that runs entirely in the browser.

## 🏗️ Architecture

### Frontend (Web Interface)
- **Technology**: Vanilla HTML, CSS, and JavaScript
- **Features**: Drag-and-drop upload, progress tracking, bulk downloads
- **Processing**: All conversion happens client-side for privacy
- **Deployment**: Static site compatible with Vercel, Netlify, GitHub Pages

### Backend (Python CLI)
- **Technology**: Pure Python with standard library
- **Features**: Batch processing, filesystem integration, duplicate detection
- **Usage**: Local development and automation scripts

### File Structure
```
chatgpt-cursor-import/
├── index.html              # Web interface
├── src/                    # Frontend application source
│   ├── components/        # UI components (FileUploader, ProgressDisplay)
│   ├── modules/          # Core modules (orchestrator, conversion, filesystem)
│   └── utils/            # Utility functions and constants  
├── chatgpt_converter.py    # Python CLI tool
├── example_conversations.json # Sample data for testing
├── vercel.json            # Vercel deployment config
├── package.json           # Project metadata
├── README.md              # This file
└── AGENTS.md              # AI agent guidelines
```

## 🤝 Contributing

Contributions are welcome! Please ensure:
- Follow the guidelines in `AGENTS.md`
- Code follows the style and patterns in the existing files
- Include appropriate error handling
- Test with various ChatGPT export formats
- Update documentation for any new features
- Test both Python CLI and web interface
</file>

<file path="tests/test_python_converter.py">
#!/usr/bin/env python3
"""
Python tests for ChatGPT to Markdown Converter
Following AGENTS.md testing guidelines
"""

import unittest
import json
import tempfile
import os
import sys
from datetime import datetime
from pathlib import Path

# Add the project root to the path so we can import the converter
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from chatgpt_converter import (
        slugify, format_timestamp, extract_messages, 
        convert_conversation_to_markdown, generate_filename,
        process_conversations, get_existing_conversation_ids
    )
except ImportError:
    # If direct import fails, we'll exec the file (fallback method)
    converter_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'chatgpt_converter.py')
    with open(converter_path, 'r') as f:
        exec(f.read())


class TestChatGPTConverter(unittest.TestCase):
    """Test suite for ChatGPT to Markdown converter Python implementation"""

    def setUp(self):
        """Set up test fixtures"""
        # Reset global state before each test
        global processed_ids
        processed_ids = set()
        
        self.sample_conversation = {
            'id': 'test_conv_001',
            'title': 'Python Best Practices',
            'create_time': 1703522622,
            'mapping': {
                'msg_001': {
                    'message': {
                        'author': {'role': 'user'},
                        'content': {'parts': ['What are Python best practices?']}
                    },
                    'children': ['msg_002'],
                    'parent': None
                },
                'msg_002': {
                    'message': {
                        'author': {'role': 'assistant'},
                        'content': {'parts': ['Here are key Python best practices: 1. Follow PEP 8...']}
                    },
                    'children': [],
                    'parent': 'msg_001'
                }
            }
        }

    def test_slugify_function(self):
        """Test slugify converts text to URL-safe slug"""
        self.assertEqual(slugify('Python Best Practices'), 'python-best-practices')
        self.assertEqual(slugify('Redis & Caching: Advanced!'), 'redis-caching-advanced')
        self.assertEqual(slugify('   Multiple   Spaces   '), 'multiple-spaces')
        self.assertEqual(slugify('Special@#$%Characters'), 'specialcharacters')
        self.assertEqual(slugify(''), '')

    def test_format_timestamp(self):
        """Test timestamp formatting"""
        # Test specific timestamp: 2023-12-25 14:30:22 UTC  
        timestamp = 1703522622
        self.assertEqual(format_timestamp(timestamp), '2023-12-25')
        
        # Test epoch
        self.assertEqual(format_timestamp(0), '1970-01-01')

    def test_generate_filename(self):
        """Test filename generation follows expected format"""
        filename = generate_filename(self.sample_conversation)
        expected = 'Python Best Practices.md'
        self.assertEqual(filename, expected)

    def test_generate_filename_long_title(self):
        """Test filename generation handles long titles"""
        long_conversation = self.sample_conversation.copy()
        long_conversation['title'] = 'This is an extremely long title that should be truncated because it exceeds reasonable limits'
        
        filename = generate_filename(long_conversation)
        self.assertLess(len(filename), 110)  # Should be truncated to reasonable length
        self.assertTrue(filename.endswith('.md'))

    def test_generate_filename_missing_data(self):
        """Test filename generation handles missing data gracefully"""
        empty_conversation = {}
        filename = generate_filename(empty_conversation)
        self.assertEqual(filename, 'Untitled Conversation.md')

    def test_generate_filename_duplicates(self):
        """Test duplicate filename handling"""
        conversation1 = {'title': 'Python Tips'}
        conversation2 = {'title': 'Python Tips'}  # Same title
        
        # First file should get the base name
        filename1 = generate_filename(conversation1, [])
        self.assertEqual(filename1, 'Python Tips.md')
        
        # Second file should get a suffix
        filename2 = generate_filename(conversation2, [filename1])
        self.assertEqual(filename2, 'Python Tips (2).md')
        
        # Third file should get next suffix
        filename3 = generate_filename(conversation2, [filename1, filename2])
        self.assertEqual(filename3, 'Python Tips (3).md')

    def test_extract_messages(self):
        """Test message extraction from mapping structure"""
        messages = extract_messages(self.sample_conversation['mapping'])
        
        self.assertEqual(len(messages), 2)
        self.assertEqual(messages[0]['author'], 'user')
        self.assertEqual(messages[0]['content'], 'What are Python best practices?')
        self.assertEqual(messages[1]['author'], 'assistant')
        self.assertIn('Here are key Python best practices', messages[1]['content'])

    def test_extract_messages_empty_mapping(self):
        """Test message extraction handles empty mapping"""
        messages = extract_messages({})
        self.assertEqual(messages, [])

    def test_extract_messages_malformed_mapping(self):
        """Test message extraction handles malformed data."""
        # Test with missing keys
        mapping = {
            'msg_1': {
                'message': {
                    'author': {'role': 'user'},
                    'content': {'parts': ['Valid message']}
                }
                # Missing 'children' and 'parent'
            }
        }
        messages = extract_messages(mapping)
        self.assertEqual(len(messages), 1)
        self.assertEqual(messages[0]['content'], 'Valid message')

    def test_extract_messages_with_citations(self):
        """Test that citation objects are filtered out to prevent garbled text."""
        mapping = {
            'msg_1': {
                'message': {
                    'author': {'role': 'assistant'},
                    'content': {
                        'parts': [
                            'This is text content',
                            {'type': 'cite', 'turn': 0, 'search': 0},  # Citation object
                            ' and this continues',
                            {'type': 'search', 'turn': 0, 'search': 2},  # Search object
                            ' with more text.'
                        ]
                    }
                },
                'children': [],
                'parent': None
            }
        }
        
        messages = extract_messages(mapping)
        self.assertEqual(len(messages), 1)
        
        # Should only contain the text parts, not the citation objects
        expected_content = 'This is text content and this continues with more text.'
        self.assertEqual(messages[0]['content'], expected_content)
        
        # Should not contain garbled citation text
        self.assertNotIn('cite', messages[0]['content'])
        self.assertNotIn('turn', messages[0]['content'])
        self.assertNotIn('search', messages[0]['content'])

    def test_convert_conversation_to_markdown(self):
        """Test conversation to markdown conversion"""
        markdown = convert_conversation_to_markdown(self.sample_conversation)
        
        # Check structure (title no longer included in content, shown by filename)
        self.assertNotIn('# Python Best Practices', markdown)
        self.assertIn('**Created:**', markdown)
        self.assertIn('---', markdown)
        self.assertIn('**🧑‍💬 User**', markdown)
        self.assertIn('**🤖 Assistant**', markdown)
        self.assertIn('What are Python best practices?', markdown)

    def test_convert_conversation_missing_title(self):
        """Test conversion handles missing title"""
        conversation = self.sample_conversation.copy()
        del conversation['title']
        
        markdown = convert_conversation_to_markdown(conversation)
        self.assertNotIn('# Untitled Conversation', markdown)

    def test_process_conversations(self):
        """Test processing multiple conversations"""
        conversations = [self.sample_conversation]
        results = process_conversations(conversations)
        
        self.assertEqual(results['processed'], 1)
        self.assertEqual(results['skipped'], 0)
        self.assertEqual(results['errors'], 0)
        self.assertEqual(len(results['files']), 1)

    def test_process_conversations_duplicates(self):
        """Test duplicate conversation handling"""
        # Create two conversations with the same ID
        conversations = [
            {
                'id': 'duplicate_test',
                'title': 'First Instance',
                'create_time': 1703522622,
                'mapping': {}
            },
            {
                'id': 'duplicate_test',  # Same ID
                'title': 'Second Instance',
                'create_time': 1703522623,  # Different time to test sorting
                'mapping': {}
            }
        ]
        
        # Reset processed IDs
        global processed_ids
        processed_ids = set()
        
        results = process_conversations(conversations)
        self.assertEqual(results['processed'], 1)
        self.assertEqual(results['skipped'], 1)

    def test_conversations_sorted_chronologically(self):
        """Test that conversations are processed in chronological order (oldest first)"""
        conversations = [
            {
                'id': 'newest',
                'title': 'Newest Conversation',
                'create_time': 1703522625,  # Latest
                'mapping': {}
            },
            {
                'id': 'oldest',
                'title': 'Oldest Conversation', 
                'create_time': 1703522620,  # Earliest
                'mapping': {}
            },
            {
                'id': 'middle',
                'title': 'Middle Conversation',
                'create_time': 1703522622,  # Middle
                'mapping': {}
            }
        ]
        
        # Reset processed IDs
        global processed_ids
        processed_ids = set()
        
        results = process_conversations(conversations)
        self.assertEqual(results['processed'], 3)
        
        # Check that files are ordered by creation time (oldest first)
        file_titles = [file_data['title'] for file_data in results['files']]
        expected_order = ['Oldest Conversation', 'Middle Conversation', 'Newest Conversation']
        self.assertEqual(file_titles, expected_order)

    def test_process_conversations_no_id(self):
        """Test conversations without IDs are handled"""
        conversation_no_id = self.sample_conversation.copy()
        del conversation_no_id['id']
        
        conversations = [conversation_no_id]
        results = process_conversations(conversations)
        
        self.assertEqual(results['processed'], 0)
        self.assertEqual(results['errors'], 1)

    def test_edge_cases(self):
        """Test various edge cases"""
        edge_cases = [
            {
                'id': 'edge_1',
                'title': '',  # Empty title
                'create_time': 0,  # Epoch time
                'mapping': {}  # Empty mapping
            },
            {
                'id': 'edge_2',
                'title': 'Special Characters: @#$%^&*()!',
                'create_time': 1703522622,
                'mapping': {
                    'msg_001': {
                        'message': {
                            'author': {'role': 'user'},
                            'content': {'parts': ['Message with special chars: <>&"\'']}
                        },
                        'children': [],
                        'parent': None
                    }
                }
            }
        ]
        
        for conversation in edge_cases:
            filename = generate_filename(conversation)
            markdown = convert_conversation_to_markdown(conversation)
            
            # Verify filename constraints
            self.assertLess(len(filename), 255)  # Filesystem limit
            self.assertTrue(filename.endswith('.md'))
            # No longer using date prefix - now human readable
            
            # Verify markdown structure (title no longer included in content)
            self.assertNotIn('# ', markdown)
            self.assertIn('**Created:**', markdown)
            self.assertIn('---', markdown)

    def test_integration_with_temporary_files(self):
        """Integration test using temporary files"""
        with tempfile.TemporaryDirectory() as temp_dir:
            # Create test conversations file
            conversations_file = os.path.join(temp_dir, 'conversations.json')
            test_conversations = [self.sample_conversation]
            
            with open(conversations_file, 'w', encoding='utf-8') as f:
                json.dump(test_conversations, f, indent=2)
            
            # Verify file was created correctly
            self.assertTrue(os.path.exists(conversations_file))
            
            # Load and verify content
            with open(conversations_file, 'r', encoding='utf-8') as f:
                loaded_conversations = json.load(f)
            
            self.assertEqual(len(loaded_conversations), 1)
            self.assertEqual(loaded_conversations[0]['id'], 'test_conv_001')

    def test_error_handling(self):
        """Test error handling for malformed data"""
        malformed_data = [
            None,
            {},
            {'id': 'test'},  # Missing required fields
            {'title': 'No ID'},  # Missing ID
            {'id': 'test', 'mapping': None}  # Null mapping
        ]
        
        # Should not raise exceptions
        try:
            results = process_conversations(malformed_data)
            self.assertIsInstance(results, dict)
            self.assertIn('processed', results)
            self.assertIn('skipped', results)
            self.assertIn('errors', results)
            self.assertIn('files', results)
        except Exception as e:
            self.fail(f"process_conversations raised an exception with malformed data: {e}")

    def test_performance_large_dataset(self):
        """Test performance with large dataset"""
        # Create large dataset
        large_dataset = []
        for i in range(50):  # Smaller than JS test due to Python being slower
            conversation = {
                'id': f'perf_test_{i}',
                'title': f'Performance Test {i}',
                'create_time': 1703522622 + i,
                'mapping': {
                    f'msg_{i}_001': {
                        'message': {
                            'author': {'role': 'user'},
                            'content': {'parts': [f'Question {i}']}
                        },
                        'children': [f'msg_{i}_002'],
                        'parent': None
                    },
                    f'msg_{i}_002': {
                        'message': {
                            'author': {'role': 'assistant'},
                            'content': {'parts': [f'Answer {i}']}
                        },
                        'children': [],
                        'parent': f'msg_{i}_001'
                    }
                }
            }
            large_dataset.append(conversation)
        
        # Reset state
        global processed_ids
        processed_ids = set()
        
        start_time = datetime.now()
        results = process_conversations(large_dataset)
        end_time = datetime.now()
        
        processing_time = (end_time - start_time).total_seconds()
        
        self.assertEqual(results['processed'], 50)
        self.assertEqual(len(results['files']), 50)
        self.assertLess(processing_time, 10.0)  # Should complete within 10 seconds
        
        print(f"Performance test: Processed {results['processed']} conversations in {processing_time:.2f}s")

    def test_removes_complex_nested_citation_artifacts(self):
        """Test that complex nested citation artifacts are removed from Markdown output."""
        conversation = {
            'id': 'complex_citations',
            'title': 'Complex Citations',
            'create_time': 1703522622,
            'mapping': {
                'msg_1': {
                    'message': {
                        'author': {'role': 'assistant'},
                        'content': {'parts': [
                            'This is text ',
                            'turn0search3.',
                            ' More text ',
                            'turn0news33turn0search38.',
                            ' And more ',
                            'turn0search6turn0search15',
                            ' and finally ',
                            'turn0search38turn0news21turn0news26.',
                            ' End.'
                        ]}
                    },
                    'children': [],
                    'parent': None
                }
            }
        }
        markdown = convert_conversation_to_markdown(conversation)
        self.assertIn('This is text  More text  And more  and finally  End.', markdown)
        import re
        self.assertIsNone(re.search(r'turn\d+(?:search|news)\d+', markdown))

    def test_removes_navlist_citation_artifacts(self):
        """Test that navlist citation artifacts are removed from Markdown output."""
        conversation = {
            'id': 'navlist_citation',
            'title': 'Navlist Citation',
            'create_time': 1703522622,
            'mapping': {
                'msg_1': {
                    'message': {
                        'author': {'role': 'assistant'},
                        'content': {'parts': [
                            'This is text ',
                            '\ue200navlist\ue202Relevant news on Alex Jones & Israel stance\ue202turn0news20\ue201.',
                            ' More text.'
                        ]}
                    },
                    'children': [],
                    'parent': None
                }
            }
        }
        markdown = convert_conversation_to_markdown(conversation)
        self.assertIn('This is text  More text.', markdown)
        import re
        self.assertIsNone(re.search(r'turn\d+(?:search|news)\d+', markdown))

    def test_removes_broken_citation_artifacts(self):
        """Test that broken citation artifacts are removed from Markdown output."""
        conversation = {
            'id': 'broken_citation',
            'title': 'Broken Citation',
            'create_time': 1703522622,
            'mapping': {
                'msg_1': {
                    'message': {
                        'author': {'role': 'assistant'},
                        'content': {'parts': [
                            'This is text ',
                            '\ue200cite\ue202turn0search12\ue201.',
                            ' More text.'
                        ]}
                    },
                    'children': [],
                    'parent': None
                }
            }
        }
        markdown = convert_conversation_to_markdown(conversation)
        self.assertIn('This is text  More text.', markdown)
        import re
        self.assertIsNone(re.search(r'turn\d+(?:search|news)\d+', markdown))

    def test_removes_news_citation_artifacts(self):
        """Test that news citation artifacts are removed from Markdown output."""
        conversation = {
            'id': 'news_citation',
            'title': 'News Citation',
            'create_time': 1703522622,
            'mapping': {
                'msg_1': {
                    'message': {
                        'author': {'role': 'assistant'},
                        'content': {'parts': [
                            'This is text ',
                            '\ue200cite\ue202turn0news20\ue201.',
                            ' More text.'
                        ]}
                    },
                    'children': [],
                    'parent': None
                }
            }
        }
        markdown = convert_conversation_to_markdown(conversation)
        self.assertIn('This is text  More text.', markdown)
        import re
        self.assertIsNone(re.search(r'turn\d+(?:search|news)\d+', markdown))


class TestConsistencyWithJavaScript(unittest.TestCase):
    """Test consistency between Python and JavaScript implementations"""
    
    def test_filename_generation_consistency(self):
        """Ensure Python generates same filenames as JavaScript"""
        test_cases = [
            {
                'id': 'consistency_test_1',
                'title': 'Python vs JavaScript Test',
                'create_time': 1703522622
            },
            {
                'id': 'consistency_test_2',
                'title': 'Special Characters: @#$%^&*()',
                'create_time': 1703522622
            },
            {
                'id': 'consistency_test_3',
                'title': 'Very Long Title That Should Be Truncated',
                'create_time': 0  # Epoch time
            }
        ]
        
        for conversation in test_cases:
            filename = generate_filename(conversation)
            
            # Test expected patterns that should match JavaScript
            self.assertTrue(filename.endswith('.md'))
            # Human readable filenames no longer contain dates or IDs
            
            # Test length constraints
            self.assertLess(len(filename), 255)


if __name__ == '__main__':
    # Set up global variables that the converter expects
    global processed_ids
    processed_ids = set()
    
    print("🐍 Running Python ChatGPT Converter Tests...")
    print("Following AGENTS.md testing guidelines")
    print("=" * 50)
    
    unittest.main(verbosity=2)
</file>

<file path="test-vite-react/tests/unit/utils.test.js">
/**
 * Unit Tests for Utility Functions
 * Testing pure functions with clear inputs and outputs
 * Following AGENTS.md principle: focused, reliable testing
 */

import { describe, test, expect } from '@jest/globals';
import { 
    cleanFilename, 
    generateUniqueFilename, 
    formatTimestamp, 
    delay, 
    isValidJsonFile,
    sortConversationsChronologically 
} from '../../../src/utils/helpers.js';
import { ChatGPTConverter } from '../../../src/modules/applicationOrchestrator.js';

describe('Utility Functions', () => {
    
    describe('cleanFilename', () => {
        test('removes invalid filename characters', () => {
            const result = cleanFilename('My<File>Name:with|invalid?chars*');
            expect(result).toBe('MyFileNamewithinvalidchars');
        });

        test('preserves valid characters', () => {
            const result = cleanFilename('Valid File Name 123.txt');
            expect(result).toBe('Valid File Name 123.txt');
        });

        test('collapses multiple spaces', () => {
            const result = cleanFilename('File    with     many    spaces');
            expect(result).toBe('File with many spaces');
        });

        test('trims leading and trailing spaces', () => {
            const result = cleanFilename('  Trimmed File  ');
            expect(result).toBe('Trimmed File');
        });

        test('limits length to maximum allowed', () => {
            const longName = 'a'.repeat(200);
            const result = cleanFilename(longName);
            expect(result.length).toBeLessThanOrEqual(100);
        });

        test('handles empty input', () => {
            const result = cleanFilename('');
            expect(result).toBe('');
        });
    });

    describe('generateUniqueFilename', () => {
        test('generates filename with .md extension', () => {
            const conversation = { title: 'Test Conversation' };
            const result = generateUniqueFilename(conversation, []);
            expect(result).toBe('Test Conversation.md');
        });

        test('handles missing title with default', () => {
            const conversation = {};
            const result = generateUniqueFilename(conversation, []);
            expect(result).toBe('Conversation.md');
        });

        test('adds counter for duplicate filenames', () => {
            const conversation = { title: 'Duplicate' };
            const existing = ['Duplicate.md'];
            const result = generateUniqueFilename(conversation, existing);
            expect(result).toBe('Duplicate (2).md');
        });

        test('increments counter for multiple duplicates', () => {
            const conversation = { title: 'Multiple' };
            const existing = ['Multiple.md', 'Multiple (2).md', 'Multiple (3).md'];
            const result = generateUniqueFilename(conversation, existing);
            expect(result).toBe('Multiple (4).md');
        });

        test('cleans title before generating filename', () => {
            const conversation = { title: 'Title<with>invalid:chars' };
            const result = generateUniqueFilename(conversation, []);
            expect(result).toBe('Titlewithinvalidchars.md');
        });
    });

    describe('formatTimestamp', () => {
        test('formats Unix timestamp to YYYY-MM-DD', () => {
            const timestamp = 1703522622; // 2023-12-25 12:30:22 UTC
            const result = formatTimestamp(timestamp);
            expect(result).toBe('2023-12-25');
        });

        test('handles zero timestamp', () => {
            const result = formatTimestamp(0);
            expect(result).toBe('1970-01-01');
        });

        test('handles recent timestamp', () => {
            const timestamp = Math.floor(Date.now() / 1000);
            const result = formatTimestamp(timestamp);
            const today = new Date().toISOString().split('T')[0];
            expect(result).toBe(today);
        });
    });

    describe('delay', () => {
        test('returns a promise', () => {
            const result = delay(1);
            expect(result).toBeInstanceOf(Promise);
        });

        test('resolves after specified time', async () => {
            const start = Date.now();
            await delay(50);
            const elapsed = Date.now() - start;
            expect(elapsed).toBeGreaterThanOrEqual(40); // Allow some timing variance
            expect(elapsed).toBeLessThan(100);
        });

        test('handles zero delay', async () => {
            const start = Date.now();
            await delay(0);
            const elapsed = Date.now() - start;
            expect(elapsed).toBeLessThan(20); // Increased tolerance for slower systems
        });
    });

    describe('isValidJsonFile', () => {
        test('accepts JSON MIME type', () => {
            const file = { type: 'application/json', name: 'test.json' };
            expect(isValidJsonFile(file)).toBe(true);
        });

        test('accepts .json extension', () => {
            const file = { type: '', name: 'conversations.json' };
            expect(isValidJsonFile(file)).toBe(true);
        });

        test('rejects non-JSON files', () => {
            const file = { type: 'text/plain', name: 'test.txt' };
            expect(isValidJsonFile(file)).toBe(false);
        });

        test('rejects files without JSON extension or MIME type', () => {
            const file = { type: 'application/octet-stream', name: 'test.bin' };
            expect(isValidJsonFile(file)).toBe(false);
        });

        test('handles case-insensitive extension', () => {
            const file = { type: '', name: 'TEST.JSON' };
            expect(isValidJsonFile(file)).toBe(true);
        });
    });

    describe('sortConversationsChronologically', () => {
        test('sorts conversations by create_time ascending', () => {
            const conversations = [
                { id: '3', create_time: 1703522622 },
                { id: '1', create_time: 1703522600 },
                { id: '2', create_time: 1703522610 }
            ];
            
            const sorted = sortConversationsChronologically(conversations);
            expect(sorted.map(c => c.id)).toEqual(['1', '2', '3']);
        });

        test('filters out invalid conversation objects', () => {
            const conversations = [
                { id: '1', create_time: 1703522600 },
                null,
                undefined,
                'invalid',
                { id: '2', create_time: 1703522610 }
            ];
            
            const sorted = sortConversationsChronologically(conversations);
            expect(sorted).toHaveLength(2);
            expect(sorted.map(c => c.id)).toEqual(['1', '2']);
        });

        test('handles missing create_time with default 0', () => {
            const conversations = [
                { id: '2', create_time: 1703522600 },
                { id: '1' }, // Missing create_time
                { id: '3', create_time: 1703522610 }
            ];
            
            const sorted = sortConversationsChronologically(conversations);
            expect(sorted.map(c => c.id)).toEqual(['1', '2', '3']);
        });

        test('maintains stable sort for same timestamps', () => {
            const conversations = [
                { id: '1', create_time: 1703522600, title: 'First' },
                { id: '2', create_time: 1703522600, title: 'Second' }
            ];
            
            const sorted = sortConversationsChronologically(conversations);
            expect(sorted[0].title).toBe('First');
            expect(sorted[1].title).toBe('Second');
        });

        test('handles empty array', () => {
            const sorted = sortConversationsChronologically([]);
            expect(sorted).toEqual([]);
        });
    });

    describe('File Sorting in UI', () => {
        let converter;
        
        beforeEach(() => {
            // Mock DOM elements that the converter expects without redefining document
            global.document.getElementById = jest.fn().mockReturnValue(null);
            global.document.createElement = jest.fn().mockReturnValue({});
            global.document.addEventListener = jest.fn();

            converter = new ChatGPTConverter();
            converter.currentSort = 'title';
            converter.sortDirection = 'asc';
        });

        test('sorts files by title naturally with case insensitive ordering', () => {
            const files = [
                { title: 'ZZZ Chat', filename: 'zzz-chat.md', createTime: 1000 },
                { title: 'AAA Chat', filename: 'aaa-chat.md', createTime: 2000 },
                { title: 'Chat 10', filename: 'chat-10.md', createTime: 3000 },
                { title: 'Chat 2', filename: 'chat-2.md', createTime: 4000 },
                { title: 'bbb chat', filename: 'bbb-chat.md', createTime: 5000 }
            ];

            converter.currentSort = 'title';
            converter.sortDirection = 'asc';
            const sorted = converter.sortFiles(files);
            
            expect(sorted.map(f => f.title)).toEqual(['AAA Chat', 'bbb chat', 'Chat 2', 'Chat 10', 'ZZZ Chat']);
        });

        test('sorts files by title in descending order', () => {
            const files = [
                { title: 'AAA Chat', filename: 'aaa-chat.md', createTime: 1000 },
                { title: 'BBB Chat', filename: 'bbb-chat.md', createTime: 2000 },
                { title: 'CCC Chat', filename: 'ccc-chat.md', createTime: 3000 }
            ];

            converter.currentSort = 'title';
            converter.sortDirection = 'desc';
            const sorted = converter.sortFiles(files);
            
            expect(sorted.map(f => f.title)).toEqual(['CCC Chat', 'BBB Chat', 'AAA Chat']);
        });

        test('sorts files by date chronologically', () => {
            const files = [
                { title: 'Latest', filename: 'latest.md', createTime: 3000 },
                { title: 'Oldest', filename: 'oldest.md', createTime: 1000 },
                { title: 'Middle', filename: 'middle.md', createTime: 2000 }
            ];

            converter.currentSort = 'date';
            converter.sortDirection = 'asc';
            const sorted = converter.sortFiles(files);
            
            expect(sorted.map(f => f.title)).toEqual(['Oldest', 'Middle', 'Latest']);
        });

        test('sorts files by date in descending order', () => {
            const files = [
                { title: 'Oldest', filename: 'oldest.md', createTime: 1000 },
                { title: 'Latest', filename: 'latest.md', createTime: 3000 },
                { title: 'Middle', filename: 'middle.md', createTime: 2000 }
            ];

            converter.currentSort = 'date';
            converter.sortDirection = 'desc';
            const sorted = converter.sortFiles(files);
            
            expect(sorted.map(f => f.title)).toEqual(['Latest', 'Middle', 'Oldest']);
        });

        test('handles files with missing timestamps', () => {
            const files = [
                { title: 'With Time', filename: 'with-time.md', createTime: 2000 },
                { title: 'No Time', filename: 'no-time.md' },
                { title: 'Zero Time', filename: 'zero-time.md', createTime: 0 }
            ];

            converter.currentSort = 'date';
            converter.sortDirection = 'asc';
            const sorted = converter.sortFiles(files);
            
            // Files without createTime should default to 0 and appear first
            expect(sorted[0].title).toBe('No Time');
            expect(sorted[1].title).toBe('Zero Time');
            expect(sorted[2].title).toBe('With Time');
        });

        test('handles invalid date values safely', () => {
            const files = [
                { title: 'Valid Time', filename: 'valid-time.md', createTime: 2000 },
                { title: 'Invalid String', filename: 'invalid-string.md', createTime: 'invalid' },
                { title: 'Negative Time', filename: 'negative-time.md', createTime: -1 },
                { title: 'Null Time', filename: 'null-time.md', createTime: null },
                { title: 'NaN Time', filename: 'nan-time.md', createTime: NaN }
            ];

            converter.currentSort = 'date';
            converter.sortDirection = 'asc';
            const sorted = converter.sortFiles(files);
            
            // Invalid dates should be treated as 0 and appear first
            expect(sorted[0].title).toBe('Invalid String');
            expect(sorted[1].title).toBe('Negative Time');
            expect(sorted[2].title).toBe('Null Time');
            expect(sorted[3].title).toBe('NaN Time');
            expect(sorted[4].title).toBe('Valid Time');
        });

        test('updateSortIndicators shows only active column arrow', () => {
            // Mock DOM elements for sort indicators
            const titleIndicator = {
                className: '',
                textContent: ''
            };
            const dateIndicator = {
                className: '',
                textContent: ''
            };
            
            // Mock querySelector to return our indicators
            global.document.querySelector = jest.fn((selector) => {
                if (selector === '#titleHeader .sort-indicator') return titleIndicator;
                if (selector === '#dateHeader .sort-indicator') return dateIndicator;
                return null;
            });
            
            // Test title column active (ascending)
            converter.currentSort = 'title';
            converter.sortDirection = 'asc';
            converter.updateSortIndicators();
            
            expect(titleIndicator.className).toBe('text-indigo-600');
            expect(titleIndicator.textContent).toBe('▲');
            expect(dateIndicator.className).toBe('text-gray-400');
            expect(dateIndicator.textContent).toBe('');
            
            // Test date column active (descending)
            converter.currentSort = 'date';
            converter.sortDirection = 'desc';
            converter.updateSortIndicators();
            
            expect(titleIndicator.className).toBe('text-gray-400');
            expect(titleIndicator.textContent).toBe('');
            expect(dateIndicator.className).toBe('text-indigo-600');
            expect(dateIndicator.textContent).toBe('▼');
        });

        test('renderPagination includes First and Last buttons for many pages', () => {
            // Mock pagination container
            const paginationContainer = {
                innerHTML: '',
                appendChild: jest.fn()
            };
            
            // Mock getElementById to return our container
            global.document.getElementById = jest.fn((id) => {
                if (id === 'paginationContainer') return paginationContainer;
                return null;
            });
            
            // Mock createPaginationButton method
            converter.createPaginationButton = jest.fn((text, page, isActive = false) => {
                return { textContent: text, page: page, isActive: isActive };
            });
            
            // Test with many pages (10 pages) and current page in middle
            converter.currentPage = 5;
            converter.renderPagination(10);
            
            // Should include First and Last buttons
            expect(converter.createPaginationButton).toHaveBeenCalledWith('«', 1);
            expect(converter.createPaginationButton).toHaveBeenCalledWith('»', 10);
            
            // Should also include Previous and Next
            expect(converter.createPaginationButton).toHaveBeenCalledWith('‹', 4);
            expect(converter.createPaginationButton).toHaveBeenCalledWith('›', 6);
        });

        test('renderPagination hides First and Last buttons for few pages', () => {
            // Mock pagination container
            const paginationContainer = {
                innerHTML: '',
                appendChild: jest.fn()
            };
            
            // Mock getElementById to return our container
            global.document.getElementById = jest.fn((id) => {
                if (id === 'paginationContainer') return paginationContainer;
                return null;
            });
            
            // Mock createPaginationButton method
            converter.createPaginationButton = jest.fn((text, page, isActive = false) => {
                return { textContent: text, page: page, isActive: isActive };
            });
            
            // Test with few pages (3 pages) and current page in middle
            converter.currentPage = 2;
            converter.renderPagination(3);
            
            // Should NOT include First and Last buttons for few pages
            const calls = converter.createPaginationButton.mock.calls;
            const buttonTexts = calls.map(call => call[0]);
            
            expect(buttonTexts).not.toContain('«');
            expect(buttonTexts).not.toContain('»');
            
            // Should still include Previous and Next
            expect(buttonTexts).toContain('‹');
            expect(buttonTexts).toContain('›');
        });

        test('renderPagination hides First button on first page', () => {
            // Mock pagination container
            const paginationContainer = {
                innerHTML: '',
                appendChild: jest.fn()
            };
            
            // Mock getElementById to return our container
            global.document.getElementById = jest.fn((id) => {
                if (id === 'paginationContainer') return paginationContainer;
                return null;
            });
            
            // Mock createPaginationButton method
            converter.createPaginationButton = jest.fn((text, page, isActive = false) => {
                return { textContent: text, page: page, isActive: isActive };
            });
            
            // Test with many pages but on first page
            converter.currentPage = 1;
            converter.renderPagination(10);
            
            // Should NOT include First button when on first page
            const calls = converter.createPaginationButton.mock.calls;
            const buttonTexts = calls.map(call => call[0]);
            
            expect(buttonTexts).not.toContain('«');
            expect(buttonTexts).toContain('»'); // Last button should still show
        });

        test('renderPagination hides Last button on last page', () => {
            // Mock pagination container
            const paginationContainer = {
                innerHTML: '',
                appendChild: jest.fn()
            };
            
            // Mock getElementById to return our container
            global.document.getElementById = jest.fn((id) => {
                if (id === 'paginationContainer') return paginationContainer;
                return null;
            });
            
            // Mock createPaginationButton method
            converter.createPaginationButton = jest.fn((text, page, isActive = false) => {
                return { textContent: text, page: page, isActive: isActive };
            });
            
            // Test with many pages but on last page
            converter.currentPage = 10;
            converter.renderPagination(10);
            
            // Should NOT include Last button when on last page
            const calls = converter.createPaginationButton.mock.calls;
            const buttonTexts = calls.map(call => call[0]);
            
            expect(buttonTexts).not.toContain('»');
            expect(buttonTexts).toContain('«'); // First button should still show
        });

        test('default sort is date descending', () => {
            const files = [
                { title: 'Oldest', filename: 'oldest.md', createTime: 1000 },
                { title: 'Latest', filename: 'latest.md', createTime: 3000 },
                { title: 'Middle', filename: 'middle.md', createTime: 2000 }
            ];

            // Reset to default state (no currentSort set)
            converter.currentSort = null;
            converter.sortDirection = null;
            
            // Simulate the populateFilesView initialization
            if (!converter.currentSort) {
                converter.currentSort = 'date';
                converter.sortDirection = 'desc';
            }
            
            const sorted = converter.sortFiles(files);
            
            // Should be sorted by date descending (newest first)
            expect(sorted.map(f => f.title)).toEqual(['Latest', 'Middle', 'Oldest']);
        });
    });
});
</file>

<file path="chatgpt_converter.py">
#!/usr/bin/env python3
"""
ChatGPT to Markdown Converter

Converts ChatGPT conversation exports (conversations.json) into clean
Markdown files, with intelligent duplicate detection and clean formatting.
"""

import json
import os
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

# Global variable for tracking processed conversation IDs
processed_ids = set()


def slugify(text: str) -> str:
    """Convert text to a URL-safe slug suitable for filenames."""
    # Convert to lowercase and replace spaces/special chars with hyphens
    slug = re.sub(r'[^\w\s-]', '', text.lower())
    slug = re.sub(r'[-\s]+', '-', slug)
    return slug.strip('-')


def format_timestamp(timestamp: float) -> str:
    """Convert UNIX timestamp to YYYY-MM-DD format."""
    return datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d')


def extract_messages(mapping: Dict) -> List[Dict[str, str]]:
    """
    Extract and order messages from the ChatGPT mapping structure.
    
    The mapping is a nested structure where each message has an ID and references
    to parent/child messages. We need to traverse this to get the conversation flow.
    """
    messages = []
    
    # Find the root message (usually has no parent)
    root_id = None
    for msg_id, msg_data in mapping.items():
        if msg_data.get('parent') is None and msg_data.get('message'):
            root_id = msg_id
            break
    
    if not root_id:
        # Fallback: use first message with content
        for msg_id, msg_data in mapping.items():
            if msg_data.get('message') and msg_data['message'].get('content'):
                root_id = msg_id
                break
    
    if not root_id:
        return messages
    
    # Traverse the conversation tree starting from root
    current_id = root_id
    visited = set()
    
    while current_id and current_id not in visited:
        visited.add(current_id)
        msg_data = mapping.get(current_id, {})
        message = msg_data.get('message', {})
        
        if message and message.get('content'):
            author = message.get('author', {}).get('role', 'unknown')
            content = message.get('content', {})
            
            # Handle different content structures
            text_content = ''
            if isinstance(content, dict):
                parts = content.get('parts', [])
                if parts and isinstance(parts, list):
                    # Filter out non-string parts (citations, web search results, etc.)
                    # to prevent garbled text like "citeturn0search2turn0search0"
                    text_parts = [part for part in parts if isinstance(part, str)]
                    text_content = ''.join(text_parts)
            elif isinstance(content, str):
                text_content = content
            
            if text_content.strip():
                messages.append({
                    'author': author,
                    'content': text_content.strip()
                })
        
        # Find the next message in the conversation
        children = msg_data.get('children', [])
        current_id = children[0] if children else None
    
    return messages


def escape_markdown(text: str) -> str:
    """Escape characters that could break Markdown formatting."""
    # Escape backslashes first to avoid double-escaping
    text = text.replace('\\', '\\\\')
    # Escape other problematic characters
    text = text.replace('*', '\\*')
    text = text.replace('_', '\\_')
    text = text.replace('`', '\\`')
    text = text.replace('[', '\\[')
    text = text.replace(']', '\\]')
    return text


def format_as_blockquote(content: str) -> str:
    """Format message content as blockquotes while preserving line breaks."""
    if not content or not isinstance(content, str):
        return ''
    
    # Split by line breaks and prefix each non-empty line with '> '
    lines = content.split('\n')
    return '\n'.join('>' if line.strip() == '' else f'> {line}' for line in lines)


def convert_conversation_to_markdown(conversation: Dict) -> str:
    """Convert a single conversation to Markdown format."""
    title = conversation.get('title', 'Untitled Conversation')
    create_time = conversation.get('create_time', 0)
    mapping = conversation.get('mapping', {})
    
    # Extract and format messages
    messages = extract_messages(mapping)
    
            # Build Markdown content with clean structure
    # Format timestamp as YYYY-MM-DD, HH:mm:ss for consistency
    timestamp = datetime.fromtimestamp(create_time)
    formatted_timestamp = timestamp.strftime('%Y-%m-%d, %H:%M:%S')
    
    content_lines = [
        f"**Created:** {formatted_timestamp}",
        "",
        "---",
        ""
    ]
    
    for message in messages:
        author = message['author']
        text = message['content']
        
                    # Format author name with clean styling
        author_display = "**🧑‍💬 User**" if author == "user" else "**🤖 Assistant**"
        
        content_lines.append(author_display)
        content_lines.append("")
        
        # Format content as blockquotes while preserving original formatting
        blockquoted_content = format_as_blockquote(text)
        content_lines.append(blockquoted_content)
        content_lines.append("")
    
    content = '\n'.join(content_lines)
    # Clean broken citation artifacts using multi-pass approach for comprehensive coverage
    cleaned_content = clean_citation_artifacts(content)
    return cleaned_content


def clean_citation_artifacts(content: str) -> str:
    """Clean citation artifacts using multi-pass approach for comprehensive coverage."""
    cleaned = content
    
    # Pattern 1: Remove complex citation patterns with Unicode characters
    cleaned = re.sub(r'[\ue000-\uf8ff]*(?:cite|navlist)[\ue000-\uf8ff]*.*?turn\d+(?:search|news)\d+[\ue000-\uf8ff]*\.?', '', cleaned)
    
    # Pattern 2: Remove simple turn patterns with Unicode
    cleaned = re.sub(r'turn\d+(?:search|news)\d+[\ue000-\uf8ff]*\.?', '', cleaned)
    
    # Pattern 3: Remove any remaining turn patterns without Unicode
    cleaned = re.sub(r'turn\d+(?:search|news)\d+\.?', '', cleaned)
    
    # Pattern 4: Remove any remaining Unicode citation artifacts
    cleaned = re.sub(r'[\ue000-\uf8ff]+', '', cleaned)
    
    return cleaned


def get_existing_conversation_ids(output_dir: Path) -> set:
    """Get set of conversation IDs that have already been imported."""
    existing_ids = set()
    
    if not output_dir.exists():
        return existing_ids
    
    # Look for files matching the pattern and extract conversation IDs
    for file_path in output_dir.glob('*.md'):
        filename = file_path.stem
        # Extract ID from the end of filename (after last underscore)
        parts = filename.split('_')
        if len(parts) >= 3:  # date_title_id format
            conversation_id = parts[-1]
            existing_ids.add(conversation_id)
    
    return existing_ids


def clean_filename(text: str) -> str:
    """Clean text for filename usage while keeping it readable"""
    import re
    
    # Replace problematic characters with safe alternatives
    text = re.sub(r'[<>:"/\\|?*]', '', text)  # Remove invalid filename chars
    text = re.sub(r'[^\w\s.-]', '', text)     # Keep only letters, numbers, spaces, dots, hyphens
    text = re.sub(r'\s+', ' ', text)          # Collapse multiple spaces
    text = text.strip()                       # Remove leading/trailing spaces
    text = text[:100]                         # Limit length for filesystem compatibility
    
    return text


def generate_filename(conversation: Dict, existing_filenames: List[str] = None) -> str:
    """Generate human-readable filename with duplicate handling"""
    if existing_filenames is None:
        existing_filenames = []
    
    title = conversation.get('title', 'Untitled Conversation')
    
    # Create base filename - clean but readable
    base_filename = clean_filename(title)
    
    # Ensure it's not empty
    if not base_filename:
        base_filename = 'Conversation'
    
    # Start with the base filename
    filename = f"{base_filename}.md"
    
    # Handle duplicates by adding suffix
    counter = 2
    while filename in existing_filenames:
        filename = f"{base_filename} ({counter}).md"
        counter += 1
    
    return filename


def process_conversations(conversations):
    """
    Process conversations and convert to file data structures.
    Returns a dictionary with processing results for testing compatibility.
    """
    results = {
        'processed': 0,
        'skipped': 0,
        'errors': 0,
        'files': []
    }
    
    # Use global processed_ids for duplicate detection
    global processed_ids
    if 'processed_ids' not in globals():
        processed_ids = set()
    
    # Sort conversations by creation time (oldest first) to match chronological order
    valid_conversations = [conv for conv in conversations if conv and isinstance(conv, dict)]
    sorted_conversations = sorted(valid_conversations, key=lambda x: x.get('create_time', 0))
    
    print(f"📅 Processing {len(sorted_conversations)} conversations in chronological order (oldest first)")
    
    # Track filenames to prevent duplicates
    used_filenames = []
    
    for conversation in sorted_conversations:
        # Handle None or non-dict conversations
        if not conversation or not isinstance(conversation, dict):
            print("⚠️  Warning: Invalid conversation data found, skipping")
            results['errors'] += 1
            continue
            
        conversation_id = conversation.get('id')
        
        if not conversation_id:
            print("⚠️  Warning: Conversation without ID found, skipping")
            results['errors'] += 1
            continue
        
        # Skip if already processed
        if conversation_id in processed_ids:
            print(f"⏭️  Skipping: {conversation.get('title', 'Untitled')} (already processed)")
            results['skipped'] += 1
            continue
        
        try:
            # Convert conversation to Markdown
            markdown_content = convert_conversation_to_markdown(conversation)
            
            # Generate filename with duplicate checking
            filename = generate_filename(conversation, used_filenames)
            used_filenames.append(filename)
            
            # Create file data structure
            file_data = {
                'filename': filename,
                'content': markdown_content,
                'title': conversation.get('title', 'Untitled'),
                'conversation_id': conversation_id
            }
            
            results['files'].append(file_data)
            processed_ids.add(conversation_id)
            results['processed'] += 1
            
        except Exception as e:
            print(f"❌ Error processing conversation '{conversation.get('title', 'Unknown')}': {e}")
            results['errors'] += 1
    
    return results


def main():
    """Main function to process ChatGPT conversations."""
    input_file = Path('conversations.json')
    output_dir = Path('ChatGPT')
    
    # Check if input file exists
    if not input_file.exists():
        print(f"❌ Error: {input_file} not found")
        print("Please ensure you have the conversations.json file from your ChatGPT export")
        return
    
    # Create output directory if it doesn't exist
    output_dir.mkdir(exist_ok=True)
    
    # Load conversations
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            conversations = json.load(f)
    except json.JSONDecodeError as e:
        print(f"❌ Error parsing JSON: {e}")
        return
    except Exception as e:
        print(f"❌ Error reading file: {e}")
        return
    
    # Get existing conversation IDs to avoid duplicates
    existing_ids = get_existing_conversation_ids(output_dir)
    
    # Initialize global processed_ids for this run
    global processed_ids
    processed_ids = existing_ids.copy()
    
    # Process conversations using the new function
    results = process_conversations(conversations)
    
    # Write files to disk
    for i, file_data in enumerate(results['files']):
        output_path = output_dir / file_data['filename']
        
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(file_data['content'])
            
            print(f"✅ Converted: {file_data['title']} → {file_data['filename']}")
            
            # Small delay to ensure file creation timestamps are properly ordered
            if i < len(results['files']) - 1:
                import time
                time.sleep(0.01)  # 10ms delay
            
        except Exception as e:
            print(f"❌ Error writing file '{file_data['filename']}': {e}")
            results['errors'] += 1
            results['processed'] -= 1
    
    # Summary
    print("\n" + "="*50)
    print(f"📊 Summary:")
    print(f"   ✅ Processed: {results['processed']} conversations")
    print(f"   ⏭️  Skipped: {results['skipped']} conversations (already imported)")
    print(f"   ❌ Errors: {results['errors']} conversations") if results['errors'] > 0 else None
    print(f"   📁 Output directory: {output_dir.absolute()}")


if __name__ == "__main__":
    main()
</file>

<file path="vercel.json">
{
  "version": 2,
  "builds": [
    {
      "src": "**/*",
      "use": "@vercel/static"
    }
  ],
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    },
    {
      "source": "/index.html",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=0, must-revalidate"
        }
      ]
    },
    {
      "source": "/src/(.*)\\.js",
      "headers": [
        {
          "key": "Content-Type",
          "value": "text/javascript; charset=utf-8"
        },
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    }
  ],
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/index.html"
    }
  ],
  "git": {
    "deploymentEnabled": {
      "main": true,
      "dev": false,
      "preview": false
    }
  }
}
</file>

<file path="src/utils/constants.js">
/**
 * Application Constants
 * Centralized configuration values for the ChatGPT to Markdown converter
 */

// File processing constants
export const PROCESSING_CONFIG = {
    DELAY_BETWEEN_FILES_MS: 100, // Delay ensures chronological file timestamps
    MAX_FILENAME_LENGTH: 100,   // Filesystem compatibility limit
    PROGRESS_UPDATE_INTERVAL: 50 // UI responsiveness balance
};

// File system constants
export const FILE_SYSTEM = {
    SUPPORTED_MIME_TYPES: ['application/json'],
    SUPPORTED_EXTENSIONS: ['.json'],
    OUTPUT_EXTENSION: '.md',
    DEFAULT_FILENAME: 'Conversation'
};

// UI configuration constants
export const UI_CONFIG = {
    FILES_PER_PAGE: 10,          // Default number of files to show per page
    MAX_PAGINATION_BUTTONS: 7,   // Maximum number of pagination buttons to display
    SORT_OPTIONS: {
        NAME: 'name',
        DATE: 'date'
    },
    SORT_DIRECTIONS: {
        ASC: 'asc',
        DESC: 'desc'
    }
};

// API capabilities - using function for dynamic checking
export const API_SUPPORT = {
    get FILE_SYSTEM_ACCESS() {
        // More robust File System Access API detection with mobile awareness
        const hasShowDirectoryPicker = 'showDirectoryPicker' in window;
        const isFunction = typeof window.showDirectoryPicker === 'function';
        const isSecureContext = window.isSecureContext;
        const isValidProtocol = location.protocol === 'https:' || 
                               location.hostname === 'localhost' || 
                               location.hostname === '127.0.0.1' ||
                               location.protocol === 'file:';
        
        // Mobile browser detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isSafari = /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
        
        const isSupported = hasShowDirectoryPicker && isFunction && isSecureContext && isValidProtocol;
        
        return {
            supported: isSupported,
            mobile: isMobile,
            ios: isIOS,
            safari: isSafari,
            details: {
                hasShowDirectoryPicker,
                isFunction,
                isSecureContext,
                protocol: location.protocol,
                hostname: location.hostname,
                isValidProtocol,
                userAgent: navigator.userAgent
            }
        };
    }
};

// Error messages - centralized for consistency
export const ERROR_MESSAGES = {
    INVALID_JSON: 'Invalid JSON format. Please ensure you uploaded a valid conversations.json file.',
    INVALID_STRUCTURE: 'Expected an array of conversations. Please check your file format.',
    NO_DIRECTORY: 'Please select a folder first',
    PERMISSION_DENIED: 'Permission denied. Try selecting a different folder or use downloads instead.',
    SECURITY_RESTRICTION: 'Security restriction. Try a folder in your Documents or Desktop.',
    FILE_SYSTEM_UNSUPPORTED: 'File System Access API not supported. Files will be downloaded instead.',
    FILE_EXISTS: 'File already exists. Do you want to overwrite it?',
    CANCELLED: 'Operation cancelled by user'
};

// Status messages - centralized for consistency
export const STATUS_MESSAGES = {
    PROCESSING: 'Processing conversations...',
    READING_FILE: 'Reading file...',
    PARSING_JSON: 'Parsing JSON...',
    CONVERTING: 'Converting conversations...',
    FINALIZING: 'Finalizing conversion...',
    COMPLETE: 'Conversion complete!',
    SAVING: 'Saving files...',
    CANCELLED: 'Directory selection cancelled',
    FILE_EXISTS_CHECK: 'Checking for existing files...'
};

// Logging configuration
export const LOGGING_CONFIG = {
    DEFAULT_LEVEL: 'INFO',
    DEBUG_MODE: false,
    ENABLE_EXTERNAL_LOGGING: false
};
</file>

<file path="src/utils/helpers.js">
/**
 * Utility Functions
 * Pure functions for common operations without side effects
 * Following AGENTS.md principle: small, focused modules
 */

import { FILE_SYSTEM, PROCESSING_CONFIG } from './constants.js';

/**
 * Get ordinal suffix for a day of month
 * @param {number} day
 * @returns {string}
 */
function getOrdinalSuffix(day) {
    const j = day % 10, k = day % 100;
    if (j === 1 && k !== 11) return 'st';
    if (j === 2 && k !== 12) return 'nd';
    if (j === 3 && k !== 13) return 'rd';
    return 'th';
}

/**
 * Format a Date to London timezone parts
 * @param {Date} date
 * @returns {{weekday:string, month:string, day:number, year:number, hour12:number, minute:number, ampm:string}}
 */
export function getLondonParts(date) {
    const tz = 'Europe/London';
    const dateFormatter = new Intl.DateTimeFormat('en-GB', { timeZone: tz, weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
    const timeFormatter = new Intl.DateTimeFormat('en-GB', { timeZone: tz, hour: 'numeric', minute: '2-digit', hour12: true });
    const dParts = dateFormatter.formatToParts(date);
    const tParts = timeFormatter.formatToParts(date);
    const mapParts = (parts) => Object.fromEntries(parts.map(p => [p.type, p.value]));
    const d = mapParts(dParts);
    const t = mapParts(tParts);
    const hour12 = parseInt(t.hour || '0', 10);
    const minute = parseInt((t.minute || '0').padStart(2, '0'), 10);
    const ampm = (t.dayPeriod || '').toLowerCase();
    return { weekday: d.weekday, month: d.month, day: parseInt(d.day || '0', 10), year: parseInt(d.year || '0', 10), hour12, minute, ampm };
}

/**
 * Format human-readable London date with ordinals, e.g., Monday, August 18th 2025
 */
export function formatLondonHumanDate(date) {
    const p = getLondonParts(date);
    return `${p.weekday}, ${p.month} ${p.day}${getOrdinalSuffix(p.day)} ${p.year}`;
}

/**
 * Format London time HH:mm (24-hour)
 */
export function formatLondonHHmm(date) {
    const tz = 'Europe/London';
    const f = new Intl.DateTimeFormat('en-GB', { timeZone: tz, hour: '2-digit', minute: '2-digit', hour12: false });
    return f.format(date);
}

/**
 * Format London time human-readable: h:mm am/pm (lowercase)
 */
export function formatLondonTimeHuman(date) {
    const p = getLondonParts(date);
    return `${p.hour12}:${String(p.minute).padStart(2, '0')} ${p.ampm}`;
}

/**
 * Format London time for filenames: HH.mm (24-hour)
 */
export function formatLondonTimeFile(date) {
    const tz = 'Europe/London';
    const f = new Intl.DateTimeFormat('en-GB', { timeZone: tz, hour: '2-digit', minute: '2-digit', hour12: false });
    return f.format(date).replace(':', '.');
}

/**
 * Format London created string for frontmatter: Monday, August 18th 2025, 1:23 pm
 */
export function formatLondonCreatedHuman(date) {
    const p = getLondonParts(date);
    return `${p.weekday}, ${p.month} ${p.day}${getOrdinalSuffix(p.day)} ${p.year}, ${p.hour12}:${String(p.minute).padStart(2, '0')} ${p.ampm}`;
}

/**
 * Build Obsidian filename: <HumanTitle> — ChatGPT — YYYY-MM-DD HH.mm.md
 * HumanTitle is the London human date with ordinals
 */
export function buildObsidianFilename(conversation) {
    const timestampSec = conversation.create_time || 0;
    const date = new Date(timestampSec * 1000);
    const humanDate = formatLondonHumanDate(date);
    const hm = formatLondonTimeFile(date);
    const rawTitle = conversation.title || 'Untitled Conversation';
    const safeTitle = cleanFilename(rawTitle) || 'Untitled Conversation';
    const filename = `${safeTitle} — ${humanDate} — ${hm}.md`;
    return filename;
}

/**
 * Clean text for safe filename usage while maintaining readability
 * WHY: Filenames must be filesystem-compatible but remain human-readable
 * 
 * @param {string} text - Raw text to clean
 * @returns {string} - Filesystem-safe, readable filename
 */
export function cleanFilename(text) {
    return text
        .replace(/[<>:"/\\|?*]/g, '') // Remove invalid filename characters
        .replace(/[^\w\s.-]/g, '')    // Keep only letters, numbers, spaces, dots, hyphens
        .replace(/\s+/g, ' ')         // Collapse multiple spaces
        .trim()                       // Remove leading/trailing spaces
        .substring(0, PROCESSING_CONFIG.MAX_FILENAME_LENGTH); // Limit length for compatibility
}

/**
 * Generate unique filename with duplicate handling
 * WHY: Prevents file overwrites while maintaining readable names
 * 
 * @param {Object} conversation - Conversation object with title
 * @param {string[]} existingFilenames - Already used filenames
 * @returns {string} - Unique filename with .md extension
 */
export function generateUniqueFilename(conversation, existingFilenames = []) {
    const title = conversation.title || FILE_SYSTEM.DEFAULT_FILENAME;
    const baseFilename = cleanFilename(title) || FILE_SYSTEM.DEFAULT_FILENAME;
    
    let filename = `${baseFilename}${FILE_SYSTEM.OUTPUT_EXTENSION}`;
    let counter = 2;
    
    // Add numeric suffix for duplicates
    while (existingFilenames.includes(filename)) {
        filename = `${baseFilename} (${counter})${FILE_SYSTEM.OUTPUT_EXTENSION}`;
        counter++;
    }
    
    return filename;
}

/**
 * Format Unix timestamp to readable date string
 * WHY: Provides consistent date formatting across the application
 * 
 * @param {number} timestamp - Unix timestamp in seconds
 * @returns {string} - Formatted date string
 */
export function formatTimestamp(timestamp) {
    return new Date(timestamp * 1000).toISOString().split('T')[0];
}

/**
 * Create delay promise for timing control
 * WHY: Ensures proper file creation timestamps for chronological ordering
 * 
 * @param {number} ms - Milliseconds to delay
 * @returns {Promise} - Promise that resolves after delay
 */
export function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Validate file type for upload
 * WHY: Prevents processing of invalid files early in the pipeline
 * 
 * @param {File} file - File object to validate
 * @returns {boolean} - Whether file is valid JSON
 */
export function isValidJsonFile(file) {
    return FILE_SYSTEM.SUPPORTED_MIME_TYPES.includes(file.type) || 
           FILE_SYSTEM.SUPPORTED_EXTENSIONS.some(ext => file.name.toLowerCase().endsWith(ext));
}

/**
 * Sort conversations chronologically for proper file creation order
 * WHY: Oldest-first creation ensures consistent chronological ordering
 * 
 * @param {Array} conversations - Array of conversation objects
 * @returns {Array} - Sorted conversations (oldest first)
 */
export function sortConversationsChronologically(conversations) {
    return conversations
        .filter(conv => conv && typeof conv === 'object')
        .sort((a, b) => {
            const timeA = a.create_time || 0;
            const timeB = b.create_time || 0;
            return timeA - timeB; // Ascending order (oldest first)
        });
} 

/**
 * Split content into alternating text/code segments using fenced blocks
 * Returns array of { type: 'text'|'code', fence?: string, content: string }
 */
export function splitByCodeFences(content) {
    const segments = [];
    const fenceRegex = /```([a-zA-Z0-9_-]*)\n[\s\S]*?```/g;
    let lastIndex = 0;
    let match;
    while ((match = fenceRegex.exec(content)) !== null) {
        const start = match.index;
        if (start > lastIndex) {
            segments.push({ type: 'text', content: content.slice(lastIndex, start) });
        }
        const lang = match[1] || '';
        const fenceBlock = match[0];
        segments.push({ type: 'code', fence: lang || 'txt', content: fenceBlock });
        lastIndex = start + fenceBlock.length;
    }
    if (lastIndex < content.length) {
        segments.push({ type: 'text', content: content.slice(lastIndex) });
    }
    return segments;
}

/**
 * Ensure all code fences are closed; if odd number, append closing ```txt
 */
export function ensureClosedFences(markdown) {
    const count = (markdown.match(/```/g) || []).length;
    if (count % 2 === 1) {
        return markdown + '\n```\n';
    }
    return markdown;
}

/**
 * Linkify bare URLs in plain text segments
 */
export function linkifyText(text) {
    const urlRegex = /(?<!\]\()\b(https?:\/\/[\w.-]+(?:\/[\w\-._~:/?#[\]@!$&'()*+,;=%]*)?)/g;
    return text.replace(urlRegex, (url) => `[${url}](${url})`);
}

/**
 * Normalize whitespace and basic punctuation (outside code)
 */
export function normalizeText(text) {
    let t = text.replace(/[\u00A0\t]+/g, ' ');
    // Trim trailing spaces on each line
    t = t.split('\n').map(line => line.replace(/\s+$/g, '')).join('\n');
    // Collapse excessive blank lines (keep at most two)
    t = t.replace(/\s+\n/g, '\n').replace(/\n{3,}/g, '\n\n');
    // Smart punctuation normalization (outside code)
    // Curly quotes → straight
    t = t
        .replace(/[\u2018\u2019\u201B]/g, "'")
        .replace(/[\u201C\u201D\u201F]/g, '"');
    // Em/en dashes → hyphen
    t = t.replace(/[\u2013\u2014]/g, '-');
    return t;
}

/**
 * Demote heading levels in plain text (outside code blocks).
 * Ensures outer H2 message headings remain the highest level within the message.
 * Example: '## Title' -> '### Title' when minLevel = 2
 */
export function demoteHeadings(text, minLevel = 2) {
    // Process line-by-line; only adjust lines that start with heading hashes
    return text
        .split('\n')
        .map(line => {
            const match = line.match(/^(#{1,6})\s+(.*)$/);
            if (!match) return line;
            const level = match[1].length;
            if (level >= minLevel) {
                const newLevel = Math.min(level + 1, 6);
                return `${'#'.repeat(newLevel)} ${match[2]}`;
            }
            return line;
        })
        .join('\n');
}

/**
 * Prevent unintended Setext H2 headings from '---' lines under text.
 * Convert standalone '---' lines to '***' so they render as horizontal rules
 * without turning the previous line into a Setext heading in Obsidian/CommonMark.
 * Applies only to plain text (not code fences) at message level.
 */
export function avoidSetextFromHyphens(text) {
    return text
        .split('\n')
        .map(line => (/^\s{0,3}-{3,}\s*$/.test(line) ? '***' : line))
        .join('\n');
}
</file>

<file path="test-vite-react/tests/integration/fullWorkflow.test.js">
/**
 * Integration Tests for Full Workflow
 * Testing end-to-end functionality with new modular architecture
 * Following AGENTS.md principle: comprehensive integration testing
 */

import { describe, test, expect, beforeEach, jest } from '@jest/globals';
import fs from 'fs/promises';
import path from 'path';

// Import modules from new structure
import { processConversations } from '../../../src/modules/conversionEngine.js';
import { 
    generateUniqueFilename, 
    sortConversationsChronologically 
} from '../../../src/utils/helpers.js';

describe('Full Workflow Integration Tests', () => {
    
    describe('End-to-End Conversation Processing', () => {
        test('processes complete conversation export successfully', async () => {
            // Load sample conversation data
            const sampleData = [
                {
                    id: 'conversation_001',
                    title: 'Test Integration Workflow',
                    create_time: 1703522600,
                    mapping: {
                        'msg_root': {
                            message: {
                                author: { role: 'user' },
                                content: { parts: ['How do I test modular JavaScript?'] }
                            },
                            children: ['msg_assistant'],
                            parent: null
                        },
                        'msg_assistant': {
                            message: {
                                author: { role: 'assistant' },
                                content: { parts: ['You can use Jest with ES modules for testing modular JavaScript. Here are the key steps:\n\n1. Configure Jest for ES modules\n2. Use proper mocking\n3. Test each module individually\n4. Create integration tests'] }
                            },
                            children: ['msg_followup'],
                            parent: 'msg_root'
                        },
                        'msg_followup': {
                            message: {
                                author: { role: 'user' },
                                content: { parts: ['What about testing file operations?'] }
                            },
                            children: ['msg_final'],
                            parent: 'msg_assistant'
                        },
                        'msg_final': {
                            message: {
                                author: { role: 'assistant' },
                                content: { parts: ['For file operations, you should mock the File System Access API and test the logic separately from the actual file I/O.'] }
                            },
                            children: [],
                            parent: 'msg_followup'
                        }
                    }
                },
                {
                    id: 'conversation_002',
                    title: 'Second Test Conversation',
                    create_time: 1703522700,
                    mapping: {
                        'msg_single': {
                            message: {
                                author: { role: 'user' },
                                content: { parts: ['Quick question about testing'] }
                            },
                            children: [],
                            parent: null
                        }
                    }
                }
            ];

            const processedIds = new Set();
            const results = processConversations(sampleData, processedIds);

            // Verify processing results
            expect(results.processed).toBe(2);
            expect(results.skipped).toBe(0);
            expect(results.errors).toBe(0);
            expect(results.files).toHaveLength(2);

            // Verify file generation
            const firstFile = results.files[0];
            // New filename format: <Title> — <HumanDate> — <HH.mm>.md (no "ChatGPT" segment)
            expect(firstFile.filename).toMatch(/.+ — [A-Za-z]+, [A-Za-z]+ \d{1,2}(st|nd|rd|th) \d{4} — \d{2}\.\d{2}\.md$/);
            // Title no longer included in content (shown by filename)
            expect(firstFile.content).not.toContain('# Test Integration Workflow');
            expect(firstFile.content).toMatch(/## 🧑‍💬 User — (\d{2}:\d{2}|#\d+)/);
            // Verify markdown content structure and formatting
            expect(firstFile.content).toContain('How do I test modular JavaScript?');
            expect(firstFile.content).toMatch(/## 🤖 Assistant — (\d{2}:\d{2}|#\d+)/);
            expect(firstFile.content).toContain('You can use Jest with ES modules');
            // Collapsible content should include both user and assistant messages
            expect(firstFile.content).toContain('What about testing file operations?');
            expect(firstFile.content).toContain('For file operations, you should mock the File System Access API');

            // Verify chronological ordering
            expect(results.files[0].title).toBe('Test Integration Workflow');
            expect(results.files[1].title).toBe('Second Test Conversation');
            
            // Check that creation time fields are included
            expect(results.files[0].createTime).toBe(1703522600);
            expect(results.files[1].createTime).toBe(1703522700);
            expect(results.files[0].createdDate).toBe(new Date(1703522600 * 1000).toLocaleDateString());
            expect(results.files[1].createdDate).toBe(new Date(1703522700 * 1000).toLocaleDateString());
        });

        test('handles real conversation export structure', async () => {
            // Test with structure similar to actual ChatGPT exports
            const realStructureData = [
                {
                    id: 'real_conversation_001',
                    title: 'Real Structure Test',
                    create_time: 1703522800,
                    mapping: {
                        '4f7b8a5c-1234-5678-9abc-def012345678': {
                            id: '4f7b8a5c-1234-5678-9abc-def012345678',
                            message: {
                                id: '4f7b8a5c-1234-5678-9abc-def012345678',
                                author: { role: 'system', name: null, metadata: {} },
                                create_time: 1703522800.123,
                                update_time: null,
                                content: { content_type: 'text', parts: [''] },
                                status: 'finished_successfully',
                                end_turn: null,
                                weight: 1.0,
                                metadata: { finish_details: { type: 'stop' } },
                                recipient: 'all'
                            },
                            parent: null,
                            children: ['next-message-id']
                        },
                        'next-message-id': {
                            id: 'next-message-id',
                            message: {
                                id: 'next-message-id',
                                author: { role: 'user', name: null, metadata: {} },
                                create_time: 1703522801.456,
                                update_time: null,
                                content: { content_type: 'text', parts: ['Hello, I need help with modular architecture'] },
                                status: 'finished_successfully',
                                end_turn: null,
                                weight: 1.0,
                                metadata: {},
                                recipient: 'all'
                            },
                            parent: '4f7b8a5c-1234-5678-9abc-def012345678',
                            children: []
                        }
                    }
                }
            ];

            const results = processConversations(realStructureData, new Set());
            
            expect(results.processed).toBe(1);
            expect(results.files[0].content).toContain('Hello, I need help with modular architecture');
        });

        test('handles duplicate conversation IDs correctly', async () => {
            const duplicateData = [
                {
                    id: 'duplicate_id',
                    title: 'First Instance',
                    create_time: 1703522600,
                    mapping: {
                        'msg1': {
                            message: {
                                author: { role: 'user' },
                                content: { parts: ['First message'] }
                            },
                            children: [],
                            parent: null
                        }
                    }
                },
                {
                    id: 'duplicate_id',
                    title: 'Second Instance',
                    create_time: 1703522700,
                    mapping: {
                        'msg2': {
                            message: {
                                author: { role: 'user' },
                                content: { parts: ['Second message'] }
                            },
                            children: [],
                            parent: null
                        }
                    }
                }
            ];

            const processedIds = new Set();
            const results = processConversations(duplicateData, processedIds);

            expect(results.processed).toBe(1);
            expect(results.skipped).toBe(1);
            expect(results.files).toHaveLength(1);
            expect(results.files[0].title).toBe('First Instance');
        });

        test('processes conversations in chronological order', async () => {
            const unorderedData = [
                {
                    id: 'newest',
                    title: 'Newest Conversation',
                    create_time: 1703523000,
                    mapping: {
                        'msg1': {
                            message: {
                                author: { role: 'user' },
                                content: { parts: ['Newest'] }
                            },
                            children: [],
                            parent: null
                        }
                    }
                },
                {
                    id: 'oldest',
                    title: 'Oldest Conversation',
                    create_time: 1703522500,
                    mapping: {
                        'msg2': {
                            message: {
                                author: { role: 'user' },
                                content: { parts: ['Oldest'] }
                            },
                            children: [],
                            parent: null
                        }
                    }
                },
                {
                    id: 'middle',
                    title: 'Middle Conversation',
                    create_time: 1703522750,
                    mapping: {
                        'msg3': {
                            message: {
                                author: { role: 'user' },
                                content: { parts: ['Middle'] }
                            },
                            children: [],
                            parent: null
                        }
                    }
                }
            ];

            const results = processConversations(unorderedData, new Set());

            // Should be processed in chronological order (oldest first)
            expect(results.files[0].title).toBe('Oldest Conversation');
            expect(results.files[1].title).toBe('Middle Conversation');
            expect(results.files[2].title).toBe('Newest Conversation');
        });
    });

    describe('Filename Generation and Conflict Resolution', () => {
        test('generates unique filenames for duplicate titles', () => {
            const conversations = [
                { title: 'Same Title' },
                { title: 'Same Title' },
                { title: 'Same Title' }
            ];

            const filenames = [];
            for (const conv of conversations) {
                const filename = generateUniqueFilename(conv, filenames);
                filenames.push(filename);
            }

            expect(filenames).toEqual([
                'Same Title.md',
                'Same Title (2).md',
                'Same Title (3).md'
            ]);
        });

        test('handles complex title sanitization', () => {
            const conversation = { 
                title: 'Complex<Title>with:Many|Invalid?Characters*and/Symbols\\Test"File' 
            };
            
            const filename = generateUniqueFilename(conversation, []);
            expect(filename).toBe('ComplexTitlewithManyInvalidCharactersandSymbolsTestFile.md');
        });

        test('handles very long titles with truncation', () => {
            const longTitle = 'This is a very long conversation title that exceeds the maximum filename length limit and should be truncated appropriately while maintaining readability and filesystem compatibility across different operating systems';
            const conversation = { title: longTitle };
            
            const filename = generateUniqueFilename(conversation, []);
            expect(filename.length).toBeLessThanOrEqual(104); // 100 chars + '.md'
            expect(filename.endsWith('.md')).toBe(true);
        });
    });

    describe('Sorting and Chronological Order', () => {
        test('maintains stable sort for conversations with same timestamp', () => {
            const conversations = [
                { id: '1', title: 'First', create_time: 1703522600 },
                { id: '2', title: 'Second', create_time: 1703522600 },
                { id: '3', title: 'Third', create_time: 1703522600 }
            ];

            const sorted = sortConversationsChronologically(conversations);
            
            // Should maintain original order for same timestamps
            expect(sorted.map(c => c.title)).toEqual(['First', 'Second', 'Third']);
        });

        test('filters out invalid entries while sorting', () => {
            const mixed = [
                { id: '1', create_time: 1703522700 },
                null,
                undefined,
                'invalid string',
                { id: '2', create_time: 1703522600 },
                42,
                { id: '3', create_time: 1703522800 }
            ];

            const sorted = sortConversationsChronologically(mixed);
            
            expect(sorted).toHaveLength(3);
            expect(sorted.map(c => c.id)).toEqual(['2', '1', '3']);
        });
    });

    describe('Error Handling and Edge Cases', () => {
        test('handles empty conversation array', () => {
            const results = processConversations([], new Set());
            
            expect(results.processed).toBe(0);
            expect(results.skipped).toBe(0);
            expect(results.errors).toBe(0);
            expect(results.files).toHaveLength(0);
        });

        test('handles malformed conversation objects', () => {
            const malformedData = [
                null,
                undefined,
                'not an object',
                { /* missing id */ title: 'No ID' },
                { id: 'valid', title: 'Valid Conversation', mapping: {} }
            ];

            const results = processConversations(malformedData, new Set());
            
            expect(results.processed).toBe(1);
            expect(results.errors).toBe(1);
            expect(results.files).toHaveLength(1);
        });

        test('handles conversations with empty or missing mapping', () => {
            const emptyMappingData = [
                {
                    id: 'empty_mapping',
                    title: 'Empty Mapping',
                    create_time: 1703522600,
                    mapping: {}
                },
                {
                    id: 'no_mapping',
                    title: 'No Mapping',
                    create_time: 1703522700
                    // missing mapping property
                }
            ];

            const results = processConversations(emptyMappingData, new Set());
            
            expect(results.processed).toBe(2);
            expect(results.files).toHaveLength(2);
            
            // Both should generate YAML frontmatter and created time
            expect(results.files[0].content).toContain('created:');
            expect(results.files[1].content).toContain('created:');
        });

        test('handles conversations with complex nested message structures', () => {
            const complexData = [
                {
                    id: 'complex_nested',
                    title: 'Complex Nested Messages',
                    create_time: 1703522600,
                    mapping: {
                        'root': {
                            message: {
                                author: { role: 'user' },
                                content: { 
                                    parts: [
                                        'First part of message',
                                        ' continues here',
                                        ' and ends here'
                                    ]
                                }
                            },
                            children: ['branch1', 'branch2'],
                            parent: null
                        },
                        'branch1': {
                            message: {
                                author: { role: 'assistant' },
                                content: 'String content format'
                            },
                            children: [],
                            parent: 'root'
                        },
                        'branch2': {
                            message: {
                                author: { role: 'assistant' },
                                content: { parts: ['Object content format'] }
                            },
                            children: [],
                            parent: 'root'
                        }
                    }
                }
            ];

            const results = processConversations(complexData, new Set());
            
            expect(results.processed).toBe(1);
            const content = results.files[0].content;
            
            expect(content).toContain('First part of message continues here and ends here');
            expect(content).toContain('String content format');
            // Note: Only one branch should be followed in the linear conversation
        });
    });
    
    describe('Individual File Save Functionality', () => {
        test('save button calls individual save method with correct file object', () => {
            // Setup DOM elements
            document.body.innerHTML = `
                <div id="filesSection">
                    <div id="filesContainer">
                        <table>
                            <tbody>
                                <tr>
                                    <td></td>
                                    <td></td>
                                    <td>
                                        <button class="save-file-btn" 
                                                data-filename="test-conversation.md"
                                                data-content="test%20content"
                                                data-title="Test Conversation">
                                        </button>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            // Mock the ChatGPTConverter class with the saveSingleFileToMarkdown method
            const mockConverter = {
                saveSingleFileToMarkdown: jest.fn().mockResolvedValue(true),
                attachFileButtonHandlers: function() {
                    // Replicate the save button handler logic
                    document.querySelectorAll('.save-file-btn').forEach(btn => {
                        btn.addEventListener('click', async () => {
                            const filename = btn.dataset.filename;
                            const content = decodeURIComponent(btn.dataset.content);
                            const title = btn.dataset.title;
                            
                            const file = {
                                filename: filename,
                                content: content,
                                title: title
                            };
                            
                            await this.saveSingleFileToMarkdown(file);
                        });
                    });
                }
            };

            // Attach the handlers and simulate click
            mockConverter.attachFileButtonHandlers();
            const saveButton = document.querySelector('.save-file-btn');
            saveButton.click();

            // Wait for async call and verify
            return new Promise(resolve => {
                setTimeout(() => {
                    expect(mockConverter.saveSingleFileToMarkdown).toHaveBeenCalledWith({
                        filename: 'test-conversation.md',
                        content: 'test content',
                        title: 'Test Conversation'
                    });
                    resolve();
                                 }, 0);
             });
         });

         test('download button calls download method with correct file object', () => {
             // Setup DOM elements
             document.body.innerHTML = `
                 <div id="filesSection">
                     <div id="filesContainer">
                         <table>
                             <tbody>
                                 <tr>
                                     <td></td>
                                     <td></td>
                                     <td>
                                         <button class="download-file-btn" 
                                                 data-filename="test-conversation.md"
                                                 data-content="test%20markdown%20content">
                                         </button>
                                     </td>
                                 </tr>
                             </tbody>
                         </table>
                     </div>
                 </div>
             `;

             // Mock the ChatGPTConverter class with the downloadSingleFile method
             const mockConverter = {
                 downloadSingleFile: jest.fn(),
                 attachFileButtonHandlers: function() {
                     // Replicate the download button handler logic
                     document.querySelectorAll('.download-file-btn').forEach(btn => {
                         btn.addEventListener('click', () => {
                             const filename = btn.dataset.filename;
                             const content = decodeURIComponent(btn.dataset.content);
                             
                             const file = {
                                 filename: filename,
                                 content: content
                             };
                             
                             this.downloadSingleFile(file);
                         });
                     });
                 }
             };

             // Attach the handlers and simulate click
             mockConverter.attachFileButtonHandlers();
             const downloadButton = document.querySelector('.download-file-btn');
             downloadButton.click();

             // Verify the method was called with correct parameters
             expect(mockConverter.downloadSingleFile).toHaveBeenCalledWith({
                 filename: 'test-conversation.md',
                 content: 'test markdown content'
             });
         });

         test('file save confirmation dialog is shown when file is saved successfully', () => {
             // Setup DOM elements
             document.body.innerHTML = `
                 <div id="filesSection">
                     <div id="filesContainer">
                         <table>
                             <tbody>
                                 <tr>
                                     <td></td>
                                     <td></td>
                                     <td>
                                         <button class="save-file-btn" 
                                                 data-filename="test-conversation.md"
                                                 data-content="test%20content"
                                                 data-title="Test Conversation">
                                         </button>
                                     </td>
                                 </tr>
                             </tbody>
                         </table>
                     </div>
                 </div>
             `;

             // Mock the ChatGPTConverter class with the saveSingleFileToMarkdown method
             const mockConverter = {
                 showFileSaveConfirmation: jest.fn(),
                 saveSingleFileToMarkdown: jest.fn().mockImplementation(async (file) => {
                     // Simulate successful save by calling the confirmation
                     mockConverter.showFileSaveConfirmation(file.title, 'TestFolder', file.filename);
                 }),
                 attachFileButtonHandlers: function() {
                     // Replicate the save button handler logic
                     document.querySelectorAll('.save-file-btn').forEach(btn => {
                         btn.addEventListener('click', async () => {
                             const filename = btn.dataset.filename;
                             const content = decodeURIComponent(btn.dataset.content);
                             const title = btn.dataset.title;
                             
                             const file = {
                                 filename: filename,
                                 content: content,
                                 title: title
                             };
                             
                             await this.saveSingleFileToMarkdown(file);
                         });
                     });
                 }
             };

             // Attach the handlers and simulate click
             mockConverter.attachFileButtonHandlers();
             const saveButton = document.querySelector('.save-file-btn');
             saveButton.click();

             // Wait for async call and verify
             return new Promise(resolve => {
                 setTimeout(() => {
                     expect(mockConverter.showFileSaveConfirmation).toHaveBeenCalledWith(
                         'Test Conversation',
                         'TestFolder',
                         'test-conversation.md'
                     );
                     resolve();
                 }, 0);
             });
         });
     });
});
</file>

<file path="test-vite-react/tests/unit/conversionEngine.test.js">
/**
 * Unit Tests for Conversion Engine
 * Testing conversation processing and Markdown generation
 * Following AGENTS.md principle: comprehensive module testing
 */

import { describe, test, expect, beforeEach } from '@jest/globals';
import { convertConversationToMarkdown, processConversations } from '../../../src/modules/conversionEngine.js';

describe('Conversion Engine', () => {
    
    describe('convertConversationToMarkdown', () => {
        test('converts simple conversation to Markdown', () => {
            const conversation = {
                title: 'Test Conversation',
                create_time: 1703522622,
                mapping: {
                    'msg_1': {
                        message: {
                            author: { role: 'user' },
                            content: { parts: ['Hello, how are you?'] }
                        },
                        children: ['msg_2'],
                        parent: null
                    },
                    'msg_2': {
                        message: {
                            author: { role: 'assistant' },
                            content: { parts: ['I am doing well, thank you!'] }
                        },
                        children: [],
                        parent: 'msg_1'
                    }
                }
            };

            const result = convertConversationToMarkdown(conversation);
            
            // Title no longer included in content (shown by filename)
            expect(result).not.toContain('# Test Conversation');
            // Frontmatter present
            expect(result).toContain('---');
            expect(result).toContain('tags: [chatgpt]');
            // Heading sections with role icons/labels
            expect(result).toMatch(/## 🧑‍💬 User — (\d{2}:\d{2}|#1)/);
            expect(result).toMatch(/## 🤖 Assistant — (\d{2}:\d{2}|#2)/);
            expect(result).toContain('Hello, how are you?');
            expect(result).toContain('I am doing well, thank you!');
        });

        test('handles conversation without title', () => {
            const conversation = {
                create_time: 1703522622,
                mapping: {
                    'msg_1': {
                        message: {
                            author: { role: 'user' },
                            content: { parts: ['Test message'] }
                        },
                        children: [],
                        parent: null
                    }
                }
            };

            const result = convertConversationToMarkdown(conversation);
            // Frontmatter created
            expect(result).toContain('created:');
        });

        test('handles conversation without create_time', () => {
            const conversation = {
                title: 'No Timestamp',
                mapping: {
                    'msg_1': {
                        message: {
                            author: { role: 'user' },
                            content: { parts: ['Test'] }
                        },
                        children: [],
                        parent: null
                    }
                }
            };

            const result = convertConversationToMarkdown(conversation);
            expect(result).toContain('1970');
        });

        test('handles empty mapping', () => {
            const conversation = {
                title: 'Empty Chat',
                create_time: 1703522622,
                mapping: {}
            };

            const result = convertConversationToMarkdown(conversation);
            // Title no longer included in content
            expect(result).toContain('created:');
            expect(result).toContain('---');
            expect(result).not.toContain('<summary>🧑‍💬 User');
            expect(result).not.toContain('<summary>🤖 Assistant');
        });

        test('handles complex message content structures', () => {
            const conversation = {
                title: 'Complex Content',
                create_time: 1703522622,
                mapping: {
                    'msg_1': {
                        message: {
                            author: { role: 'user' },
                            content: { parts: ['Part 1', 'Part 2', 'Part 3'] }
                        },
                        children: [],
                        parent: null
                    }
                }
            };

            const result = convertConversationToMarkdown(conversation);
            expect(result).toContain('Part 1Part 2Part 3');
        });

        test('handles string content format', () => {
            const conversation = {
                title: 'String Content',
                create_time: 1703522622,
                mapping: {
                    'msg_1': {
                        message: {
                            author: { role: 'user' },
                            content: 'Direct string content'
                        },
                        children: [],
                        parent: null
                    }
                }
            };

            const result = convertConversationToMarkdown(conversation);
            expect(result).toContain('Direct string content');
        });

        test('filters out non-string parts to prevent citation rendering bugs', () => {
            const conversation = {
                title: 'Citation Content',
                create_time: 1703522622,
                mapping: {
                    'msg_1': {
                        message: {
                            author: { role: 'assistant' },
                            content: { 
                                parts: [
                                    'This is text content',
                                    { type: 'cite', turn: 0, search: 2 }, // Non-string citation object
                                    ' and this continues the text',
                                    { type: 'search', turn: 0, search: 0 }, // Non-string search object
                                    ' with more text.'
                                ]
                            }
                        },
                        children: [],
                        parent: null
                    }
                }
            };

            const result = convertConversationToMarkdown(conversation);
            // Should include image placeholders for non-text parts
            expect(result).toContain('This is text content_Image omitted_ and this continues the text_Image omitted_ with more text.');
            // Should not contain the garbled citation text
            expect(result).not.toContain('citeturn');
            expect(result).not.toContain('[object Object]');
        });

        test('removes broken citation artifacts from output', () => {
            const conversation = {
                title: 'Broken Citation',
                create_time: 1703522622,
                mapping: {
                    'msg_1': {
                        message: {
                            author: { role: 'assistant' },
                            content: { parts: [
                                'This is text ',
                                '\uE200cite\uE202turn0search12\uE201.',
                                ' More text.'
                            ] }
                        },
                        children: [],
                        parent: null
                    }
                }
            };
            const result = convertConversationToMarkdown(conversation);
            expect(result).toContain('This is text  More text.');
            expect(result).not.toMatch(/turn\d+(?:search|news)\d+/);
        });

        test('removes news citation artifacts from output', () => {
            const conversation = {
                title: 'News Citation',
                create_time: 1703522622,
                mapping: {
                    'msg_1': {
                        message: {
                            author: { role: 'assistant' },
                            content: { parts: [
                                'This is text ',
                                '\uE200cite\uE202turn0news20\uE201.',
                                ' More text.'
                            ] }
                        },
                        children: [],
                        parent: null
                    }
                }
            };
            const result = convertConversationToMarkdown(conversation);
            expect(result).toContain('This is text  More text.');
            expect(result).not.toMatch(/turn\d+(?:search|news)\d+/);
        });

        test('removes navlist citation artifacts from output', () => {
            const conversation = {
                title: 'Navlist Citation',
                create_time: 1703522622,
                mapping: {
                    'msg_1': {
                        message: {
                            author: { role: 'assistant' },
                            content: { parts: [
                                'This is text ',
                                '\uE200navlist\uE202Relevant news on Alex Jones & Israel stance\uE202turn0news20\uE201.',
                                ' More text.'
                            ] }
                        },
                        children: [],
                        parent: null
                    }
                }
            };
            const result = convertConversationToMarkdown(conversation);
            expect(result).toContain('This is text  More text.');
            expect(result).not.toMatch(/turn\d+(?:search|news)\d+/);
        });

        test('removes complex nested citation artifacts from output', () => {
            const conversation = {
                title: 'Complex Citations',
                create_time: 1703522622,
                mapping: {
                    'msg_1': {
                        message: {
                            author: { role: 'assistant' },
                            content: { parts: [
                                'This is text ',
                                'turn0search3.',
                                ' More text ',
                                'turn0news33turn0search38.',
                                ' And more ',
                                'turn0search6turn0search15',
                                ' and finally ',
                                'turn0search38turn0news21turn0news26.',
                                ' End.'
                            ] }
                        },
                        children: [],
                        parent: null
                    }
                }
            };
            const result = convertConversationToMarkdown(conversation);
            expect(result).toContain('This is text  More text  And more  and finally  End.');
            expect(result).not.toMatch(/turn\d+(?:search|news)\d+/);
        });

        test('filters out empty messages', () => {
            const conversation = {
                title: 'With Empty Messages',
                create_time: 1703522622,
                mapping: {
                    'msg_1': {
                        message: {
                            author: { role: 'user' },
                            content: { parts: ['Valid message'] }
                        },
                        children: ['msg_2'],
                        parent: null
                    },
                    'msg_2': {
                        message: {
                            author: { role: 'assistant' },
                            content: { parts: [''] }
                        },
                        children: ['msg_3'],
                        parent: 'msg_1'
                    },
                    'msg_3': {
                        message: {
                            author: { role: 'user' },
                            content: { parts: ['Another valid message'] }
                        },
                        children: [],
                        parent: 'msg_2'
                    }
                }
            };

            const result = convertConversationToMarkdown(conversation);
            expect(result).toContain('Valid message');
            expect(result).toContain('Another valid message');
            // Should not render empty assistant section
            const assistantHeadings = (result.match(/## 🤖 Assistant/g) || []).length;
            expect(assistantHeadings).toBe(0);
        });
    });

    describe('processConversations', () => {
        let mockProcessedIds;

        beforeEach(() => {
            mockProcessedIds = new Set();
        });

        test('processes single conversation correctly', () => {
            const conversations = [{
                id: 'conv_1',
                title: 'First Conversation',
                create_time: 1703522622,
                mapping: {
                    'msg_1': {
                        message: {
                            author: { role: 'user' },
                            content: { parts: ['Test message'] }
                        },
                        children: [],
                        parent: null
                    }
                }
            }];

            const results = processConversations(conversations);
            
            expect(results.processed).toBe(1);
            expect(results.skipped).toBe(0);
            expect(results.errors).toBe(0);
            expect(results.files).toHaveLength(1);
            
            const file = results.files[0];
            expect(file.filename).toMatch(/.+ — [A-Za-z]+, [A-Za-z]+ \d{1,2}(st|nd|rd|th) \d{4} — \d{2}\.\d{2}\.md$/);
            expect(file.filename).toMatch(/\.md$/);
            expect(file.title).toBe('First Conversation');
            expect(file.conversationId).toBe('conv_1');
            expect(file.createTime).toBe(1703522622);
            expect(file.createdDate).toBe(new Date(1703522622 * 1000).toLocaleDateString());
            expect(file.content).toMatch(/## 🧑‍💬 User — (\d{2}:\d{2}|#\d+)/);
            expect(file.content).toContain('Test message');
        });

        test('processes conversations in chronological order', () => {
            const conversations = [
                {
                    id: 'conv_new',
                    title: 'Newer Conversation',
                    create_time: 1703522722, // Later time
                    mapping: {
                        'msg_1': {
                            message: {
                                author: { role: 'user' },
                                content: { parts: ['New message'] }
                            },
                            children: [],
                            parent: null
                        }
                    }
                },
                {
                    id: 'conv_old',
                    title: 'Older Conversation',
                    create_time: 1703522622, // Earlier time
                    mapping: {
                        'msg_1': {
                            message: {
                                author: { role: 'user' },
                                content: { parts: ['Old message'] }
                            },
                            children: [],
                            parent: null
                        }
                    }
                }
            ];

            const results = processConversations(conversations);
            
            expect(results.files).toHaveLength(2);
            
            // Should be ordered oldest first (for chronological file creation)
            expect(results.files[0].title).toBe('Older Conversation');
            expect(results.files[1].title).toBe('Newer Conversation');
            expect(results.files[0].createTime).toBe(1703522622);
            expect(results.files[1].createTime).toBe(1703522722);
        });

        test('skips conversations without ID', () => {
            const conversations = [
                {
                    // Missing id
                    title: 'No ID Conversation',
                    create_time: 1703522600,
                    mapping: {}
                },
                {
                    id: 'conv_valid',
                    title: 'Valid Conversation',
                    create_time: 1703522610,
                    mapping: {
                        'msg_1': {
                            message: {
                                author: { role: 'user' },
                                content: { parts: ['Valid'] }
                            },
                            children: [],
                            parent: null
                        }
                    }
                }
            ];

            const results = processConversations(conversations, mockProcessedIds);

            expect(results.processed).toBe(1);
            expect(results.skipped).toBe(0);
            expect(results.errors).toBe(1);
            expect(results.files).toHaveLength(1);
        });

        test('skips already processed conversations', () => {
            mockProcessedIds.add('conv_duplicate');
            
            const conversations = [
                {
                    id: 'conv_duplicate',
                    title: 'Already Processed',
                    create_time: 1703522600,
                    mapping: {}
                },
                {
                    id: 'conv_new',
                    title: 'New Conversation',
                    create_time: 1703522610,
                    mapping: {
                        'msg_1': {
                            message: {
                                author: { role: 'user' },
                                content: { parts: ['New'] }
                            },
                            children: [],
                            parent: null
                        }
                    }
                }
            ];

            const results = processConversations(conversations, mockProcessedIds);

            expect(results.processed).toBe(1);
            expect(results.skipped).toBe(1);
            expect(results.errors).toBe(0);
            expect(results.files).toHaveLength(1);
        });

        test('handles duplicate filenames', () => {
            const conversations = [
                {
                    id: 'conv_1',
                    title: 'Same Title',
                    create_time: 1703522600,
                    mapping: {
                        'msg_1': {
                            message: {
                                author: { role: 'user' },
                                content: { parts: ['First'] }
                            },
                            children: [],
                            parent: null
                        }
                    }
                },
                {
                    id: 'conv_2',
                    title: 'Same Title',
                    create_time: 1703522610,
                    mapping: {
                        'msg_1': {
                            message: {
                                author: { role: 'user' },
                                content: { parts: ['Second'] }
                            },
                            children: [],
                            parent: null
                        }
                    }
                }
            ];

            const results = processConversations(conversations, mockProcessedIds);

            expect(results.files[0].filename).toMatch(/.+ — [A-Za-z]+, [A-Za-z]+ \d{1,2}(st|nd|rd|th) \d{4} — \d{2}\.\d{2}( \(\d+\))?\.md$/);
            expect(results.files[1].filename).toMatch(/.+ — [A-Za-z]+, [A-Za-z]+ \d{1,2}(st|nd|rd|th) \d{4} — \d{2}\.\d{2}( \(\d+\))?\.md$/);
            expect(results.files[0].filename).not.toBe(results.files[1].filename);
        });

        test('filters out invalid conversation objects', () => {
            const conversations = [
                null,
                undefined,
                'invalid',
                { id: 'valid', title: 'Valid', create_time: 1703522600, mapping: { 'msg_1': { message: { author: { role: 'user' }, content: { parts: ['Test'] } }, children: [], parent: null } } },
                42
            ];

            const results = processConversations(conversations, mockProcessedIds);

            expect(results.processed).toBe(1);
            expect(results.files).toHaveLength(1);
        });

        test('handles empty conversations array', () => {
            const results = processConversations([], mockProcessedIds);

            expect(results.processed).toBe(0);
            expect(results.skipped).toBe(0);
            expect(results.errors).toBe(0);
            expect(results.files).toHaveLength(0);
        });
    });
});
</file>

<file path="src/modules/fileSystemManager.js">
/**
 * File System Manager
 * Handles directory selection, file saving, and File System Access API operations
 * Following AGENTS.md principle: modular, focused functionality
 */

import { API_SUPPORT, ERROR_MESSAGES, PROCESSING_CONFIG } from '../utils/constants.js';
import { delay } from '../utils/helpers.js';
import { logInfo, logDebug, logWarn, logError } from '../utils/logger.js';

/**
 * Check if File System Access API is available
 * WHY: Need to degrade gracefully when API is not supported
 * 
 * @returns {boolean} - Whether File System Access API is supported
 */
export function isFileSystemAccessSupported() {
    const apiSupport = API_SUPPORT.FILE_SYSTEM_ACCESS;
    
    // Debug logging to help troubleshoot
    logDebug('📁 File System Access API Detection:', apiSupport);
    
    return apiSupport.supported;
}

/**
 * Get detailed API support information
 * WHY: Provides detailed information for better user feedback
 * 
 * @returns {Object} - Detailed API support information
 */
export function getFileSystemAccessInfo() {
    return API_SUPPORT.FILE_SYSTEM_ACCESS;
}

/**
 * Prompt user to select directory with enhanced error handling
 * WHY: Directory selection is the most error-prone operation, needs robust handling
 * 
 * @param {Object} options - Configuration options for directory picker
 * @returns {Promise<FileSystemDirectoryHandle|null>} - Selected directory handle or null
 */
export async function selectDirectory(options = {}) {
    if (!isFileSystemAccessSupported()) {
        throw new Error(ERROR_MESSAGES.FILE_SYSTEM_UNSUPPORTED);
    }

    try {
        const pickerOptions = {
            mode: 'readwrite',
            ...options
        };
        
        const directoryHandle = await window.showDirectoryPicker(pickerOptions);
        logInfo(`✅ Directory selected: ${directoryHandle.name}`);
        
        return directoryHandle;
    } catch (error) {
        return handleDirectorySelectionError(error);
    }
}

/**
 * Handle directory selection errors with specific messages
 * WHY: Provides user-friendly error messages for different failure scenarios
 * 
 * @param {Error} error - Directory selection error
 * @returns {null} - Always returns null for failed selection
 * @throws {Error} - Throws error with user-friendly message
 */
function handleDirectorySelectionError(error) {
    console.error('Directory selection error:', error);
    
    switch (error.name) {
        case 'AbortError':
            throw new Error(ERROR_MESSAGES.CANCELLED);
        case 'NotAllowedError':
            throw new Error(ERROR_MESSAGES.PERMISSION_DENIED);
        case 'SecurityError':
            throw new Error(ERROR_MESSAGES.SECURITY_RESTRICTION);
        default:
            throw new Error(`${error.message}. Files will be downloaded instead.`);
    }
}

/**
 * Save a single file to directory with permission handling and duplicate detection
 * WHY: File saving needs individual error handling, permission checks, and duplicate detection
 * 
 * @param {string} filename - Name of file to create
 * @param {string} content - File content to write
 * @param {FileSystemDirectoryHandle} directoryHandle - Target directory
 * @param {boolean} forceOverwrite - Whether to overwrite without asking (for bulk operations)
 * @returns {Promise<Object>} - Detailed result with success status and information
 */
export async function saveFileToDirectory(filename, content, directoryHandle, forceOverwrite = false) {
    try {
        // Sanitize filename for filesystem compatibility
        const safeFilename = sanitizeFilename(filename);
        
        // Check if file already exists
        let fileExists = false;
        try {
            await directoryHandle.getFileHandle(safeFilename);
            fileExists = true;
        } catch (error) {
            // File doesn't exist, which is fine
            fileExists = false;
        }
        
        // If file exists and we're not forcing overwrite, ask for confirmation
        if (fileExists && !forceOverwrite) {
            const shouldOverwrite = await showFileExistsConfirmation(safeFilename);
            if (!shouldOverwrite) {
                return { 
                    success: false, 
                    cancelled: true, 
                    message: `File "${safeFilename}" already exists and user chose not to overwrite.`,
                    filename: safeFilename 
                };
            }
        }
        
        // Create file handle (this will overwrite if exists)
        const fileHandle = await directoryHandle.getFileHandle(safeFilename, {
            create: true
        });
        
        // Verify write permissions
        const permission = await fileHandle.requestPermission({ mode: 'readwrite' });
        if (permission !== 'granted') {
            logError(`Permission denied for file: ${safeFilename}`);
            return { 
                success: false, 
                cancelled: false, 
                message: `Permission denied for file: ${safeFilename}`,
                filename: safeFilename 
            };
        }
        
        // Write content
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
        
        return { 
            success: true, 
            cancelled: false, 
            message: fileExists ? `File "${safeFilename}" overwritten successfully.` : `File "${safeFilename}" created successfully.`,
            filename: safeFilename,
            wasOverwrite: fileExists 
        };
    } catch (error) {
        logError(`Error saving file ${filename}:`, error);
        return { 
            success: false, 
            cancelled: false, 
            message: `Error saving file ${filename}: ${error.message}`,
            filename: sanitizeFilename(filename) 
        };
    }
}

/**
 * Show confirmation dialog for existing file
 * WHY: Provides user choice when file already exists
 * 
 * @param {string} filename - Name of the existing file
 * @returns {Promise<boolean>} - Whether user confirmed to overwrite
 */
async function showFileExistsConfirmation(filename) {
    return new Promise((resolve) => {
        // Create confirmation dialog
        const dialog = document.createElement('div');
        dialog.className = 'file-exists-dialog';
        dialog.innerHTML = `
            <div class="dialog-overlay">
                <div class="dialog-content">
                    <h3>File Already Exists</h3>
                    <p>The file "<strong>${filename}</strong>" already exists in the selected folder.</p>
                    <p>Do you want to overwrite it?</p>
                    <div class="dialog-buttons">
                        <button class="btn btn-secondary cancel-btn">Cancel</button>
                        <button class="btn btn-primary overwrite-btn">Overwrite</button>
                    </div>
                </div>
            </div>
        `;
        
        // Add dialog styles
        const style = document.createElement('style');
        style.textContent = `
            .file-exists-dialog .dialog-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                backdrop-filter: blur(2px);
            }
            .file-exists-dialog .dialog-content {
                background: #2a2a2a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 32px;
                max-width: 450px;
                width: 90%;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
                position: relative;
            }
            .file-exists-dialog h3 {
                margin: 0 0 20px 0;
                color: #ffffff;
                font-size: 20px;
                font-weight: 600;
            }
            .file-exists-dialog p {
                margin: 0 0 16px 0;
                color: #cccccc;
                line-height: 1.6;
                font-size: 15px;
            }
            .file-exists-dialog .dialog-buttons {
                display: flex;
                gap: 16px;
                justify-content: flex-end;
                margin-top: 24px;
            }
            .file-exists-dialog .btn {
                padding: 12px 20px;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                font-weight: 500;
                transition: all 0.2s ease;
                min-width: 90px;
            }
            .file-exists-dialog .btn-secondary {
                background: #404040;
                color: #ffffff;
                border: 1px solid #555;
            }
            .file-exists-dialog .btn-secondary:hover {
                background: #4a4a4a;
                border-color: #666;
            }
            .file-exists-dialog .btn-primary {
                background: #007acc;
                color: #ffffff;
            }
            .file-exists-dialog .btn-primary:hover {
                background: #0066aa;
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(0, 122, 204, 0.3);
            }
        `;
        
        // Add to document
        document.head.appendChild(style);
        document.body.appendChild(dialog);
        
        // Focus the overwrite button for better UX
        const overwriteBtn = dialog.querySelector('.overwrite-btn');
        const cancelBtn = dialog.querySelector('.cancel-btn');
        
        // Handle button clicks
        const cleanup = () => {
            document.removeEventListener('keydown', handleKeyDown);
            document.body.removeChild(dialog);
            document.head.removeChild(style);
        };
        
        overwriteBtn.addEventListener('click', () => {
            cleanup();
            resolve(true);
        });
        
        cancelBtn.addEventListener('click', () => {
            cleanup();
            resolve(false);
        });
        
        // Handle escape key
        const handleKeyDown = (event) => {
            if (event.key === 'Escape') {
                cleanup();
                resolve(false);
            }
        };
        document.addEventListener('keydown', handleKeyDown);
        
        // Focus the overwrite button
        setTimeout(() => overwriteBtn.focus(), 100);
    });
}

/**
 * Sanitize filename for cross-platform filesystem compatibility
 * WHY: Different filesystems have different character restrictions
 * 
 * @param {string} filename - Original filename
 * @returns {string} - Sanitized filename
 */
function sanitizeFilename(filename) {
    if (!filename || typeof filename !== 'string') {
        logWarn('Invalid filename provided for sanitization:', filename);
        return 'untitled.md';
    }
    
    // Remove or replace problematic characters
    let sanitized = filename
        .replace(/[<>:"/\\|?*]/g, '_')  // Replace invalid chars with underscore
        .replace(/\s+/g, ' ')          // Normalize whitespace
        .replace(/\.+$/, '')           // Remove trailing dots
        .trim();                       // Remove leading/trailing whitespace
    
    // Ensure filename isn't too long (most filesystems have 255 char limit)
    if (sanitized.length > 200) {
        const ext = sanitized.slice(sanitized.lastIndexOf('.'));
        const nameWithoutExt = sanitized.slice(0, sanitized.lastIndexOf('.'));
        sanitized = nameWithoutExt.slice(0, 200 - ext.length) + ext;
        logWarn(`Filename truncated due to length: ${filename} → ${sanitized}`);
    }
    
    // Ensure it's not empty after sanitization
    if (!sanitized) {
        sanitized = 'untitled.md';
        logWarn(`Filename became empty after sanitization, using default: ${filename} → ${sanitized}`);
    }
    
    // Log only if changes were made
    if (sanitized !== filename) {
        logDebug(`Sanitized filename: ${filename} → ${sanitized}`);
    }
    
    return sanitized;
}

/**
 * Show bulk duplicate files confirmation dialog
 * WHY: Provides clear information about duplicates and user choice for bulk operations
 * 
 * @param {Object} scanResults - Results from scanForExistingFiles
 * @returns {Promise<string>} - User choice: 'skip', 'overwrite', or 'cancel'
 */
async function showBulkDuplicateDialog(scanResults) {
    const { existingFiles, newFiles, totalFiles, duplicateCount, scanErrors } = scanResults;
    
    logInfo(`📋 Showing duplicate dialog: ${duplicateCount} duplicates found out of ${totalFiles} files`);
    
    return new Promise((resolve) => {
        // Create confirmation dialog
        const dialog = document.createElement('div');
        dialog.className = 'bulk-duplicate-dialog';
        dialog.id = 'bulkDuplicateDialog'; // Add ID for debugging
        
        // Show first few duplicate filenames as examples
        const exampleFiles = existingFiles.slice(0, 3).map(f => f.safeFilename);
        const moreCount = duplicateCount - exampleFiles.length;
        
        const filesList = exampleFiles.map(name => `• ${name}`).join('\n');
        const moreText = moreCount > 0 ? `\n... and ${moreCount} more` : '';
        
        // Add scan errors warning if any
        let scanErrorsHtml = '';
        if (scanErrors && scanErrors.length > 0) {
            const errorSample = scanErrors.slice(0, 2);
            const errorList = errorSample.map(e => `• ${e.filename}: ${e.error}`).join('\n');
            const moreErrors = scanErrors.length > 2 ? `\n... and ${scanErrors.length - 2} more errors` : '';
            
            scanErrorsHtml = `
                <div class="scan-errors-warning">
                    <h4>⚠️ Scan Issues Detected</h4>
                    <div class="error-list">${errorList}${moreErrors}</div>
                    <p><small>Files with errors are treated as existing for safety.</small></p>
                </div>
            `;
        }
        
        dialog.innerHTML = `
            <div class="dialog-overlay">
                <div class="dialog-content">
                    <h3>📋 Duplicate Files Detected</h3>
                    <p><strong>${duplicateCount} of ${totalFiles} files</strong> already exist in this folder:</p>
                    <div class="file-list">${filesList}${moreText}</div>
                    ${scanErrorsHtml}
                    <p>What would you like to do?</p>
                    <div class="dialog-buttons">
                        <button class="btn btn-secondary cancel-btn">Cancel</button>
                        <button class="btn btn-info skip-btn">Skip Duplicates</button>
                        <button class="btn btn-warning overwrite-btn">Overwrite All</button>
                    </div>
                    <div class="dialog-info">
                        <small>• Skip: Only save ${newFiles.length} new files</small>
                        <small>• Overwrite: Replace existing files with new content</small>
                    </div>
                </div>
            </div>
        `;
        
        // Add dialog styles with higher z-index to ensure visibility
        const style = document.createElement('style');
        style.id = 'bulkDuplicateDialogStyles';
        style.textContent = `
            .bulk-duplicate-dialog .dialog-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 99999;
                backdrop-filter: blur(3px);
            }
            .bulk-duplicate-dialog .dialog-content {
                background: #2a2a2a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 32px;
                max-width: 550px;
                width: 90%;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
                position: relative;
                max-height: 80vh;
                overflow-y: auto;
                animation: dialogFadeIn 0.3s ease-out;
            }
            @keyframes dialogFadeIn {
                from { opacity: 0; transform: scale(0.9) translateY(-20px); }
                to { opacity: 1; transform: scale(1) translateY(0); }
            }
            .bulk-duplicate-dialog h3 {
                margin: 0 0 20px 0;
                color: #ffffff;
                font-size: 20px;
                font-weight: 600;
            }
            .bulk-duplicate-dialog p {
                margin: 0 0 16px 0;
                color: #cccccc;
                line-height: 1.6;
                font-size: 15px;
            }
            .bulk-duplicate-dialog .file-list {
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 6px;
                padding: 16px;
                margin: 16px 0;
                font-family: 'Monaco', 'Consolas', monospace;
                font-size: 13px;
                color: #e0e0e0;
                white-space: pre-line;
                max-height: 150px;
                overflow-y: auto;
            }
            .bulk-duplicate-dialog .scan-errors-warning {
                background: #3d2914;
                border: 1px solid #b8860b;
                border-radius: 6px;
                padding: 16px;
                margin: 16px 0;
            }
            .bulk-duplicate-dialog .scan-errors-warning h4 {
                margin: 0 0 12px 0;
                color: #ffd700;
                font-size: 16px;
            }
            .bulk-duplicate-dialog .error-list {
                background: #2a1f0d;
                border: 1px solid #8b7355;
                border-radius: 4px;
                padding: 12px;
                font-family: 'Monaco', 'Consolas', monospace;
                font-size: 12px;
                color: #ffcc99;
                white-space: pre-line;
                max-height: 100px;
                overflow-y: auto;
                margin-bottom: 8px;
            }
            .bulk-duplicate-dialog .dialog-buttons {
                display: flex;
                gap: 12px;
                justify-content: flex-end;
                margin: 24px 0 16px 0;
            }
            .bulk-duplicate-dialog .btn {
                padding: 12px 18px;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                font-weight: 500;
                transition: all 0.2s ease;
                min-width: 100px;
            }
            .bulk-duplicate-dialog .btn-secondary {
                background: #404040;
                color: #ffffff;
                border: 1px solid #555;
            }
            .bulk-duplicate-dialog .btn-secondary:hover {
                background: #4a4a4a;
                border-color: #666;
            }
            .bulk-duplicate-dialog .btn-info {
                background: #17a2b8;
                color: #ffffff;
            }
            .bulk-duplicate-dialog .btn-info:hover {
                background: #138496;
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(23, 162, 184, 0.3);
            }
            .bulk-duplicate-dialog .btn-warning {
                background: #ffc107;
                color: #212529;
            }
            .bulk-duplicate-dialog .btn-warning:hover {
                background: #e0a800;
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(255, 193, 7, 0.3);
            }
            .bulk-duplicate-dialog .dialog-info {
                display: flex;
                flex-direction: column;
                gap: 4px;
                border-top: 1px solid #444;
                padding-top: 16px;
            }
            .bulk-duplicate-dialog .dialog-info small {
                color: #999;
                font-size: 12px;
            }
        `;
        
        // Add to document
        document.head.appendChild(style);
        document.body.appendChild(dialog);
        
        logInfo('✅ Duplicate dialog added to DOM');
        
        // Get button references
        const cancelBtn = dialog.querySelector('.cancel-btn');
        const skipBtn = dialog.querySelector('.skip-btn');
        const overwriteBtn = dialog.querySelector('.overwrite-btn');
        
        // Handle button clicks
        const cleanup = () => {
            try {
                if (dialog.parentNode) {
                    document.body.removeChild(dialog);
                }
                if (style.parentNode) {
                    document.head.removeChild(style);
                }
                logInfo('✅ Duplicate dialog cleaned up');
            } catch (error) {
                logWarn('⚠️ Error cleaning up dialog:', error);
            }
        };
        
        cancelBtn.addEventListener('click', () => {
            logInfo('📋 User chose to cancel duplicate operation');
            cleanup();
            resolve('cancel');
        });
        
        skipBtn.addEventListener('click', () => {
            logInfo('📋 User chose to skip duplicates');
            cleanup();
            resolve('skip');
        });
        
        overwriteBtn.addEventListener('click', () => {
            logInfo('📋 User chose to overwrite duplicates');
            cleanup();
            resolve('overwrite');
        });
        
        // Handle escape key
        const handleKeyDown = (event) => {
            if (event.key === 'Escape') {
                document.removeEventListener('keydown', handleKeyDown);
                logInfo('📋 User cancelled with Escape key');
                cleanup();
                resolve('cancel');
            }
        };
        document.addEventListener('keydown', handleKeyDown);
        
        // Focus the skip button (safest default)
        setTimeout(() => {
            try {
                skipBtn.focus();
                logInfo('✅ Duplicate dialog focused and ready');
            } catch (error) {
                logWarn('⚠️ Could not focus dialog button:', error);
            }
        }, 100);
    });
}

/**
 * Save multiple files with chronological timing and duplicate handling
 * WHY: Ensures files are created in chronological order for proper organization
 * 
 * @param {Array} files - Array of file objects to save
 * @param {FileSystemDirectoryHandle} directoryHandle - Target directory
 * @param {Function} progressCallback - Progress update callback
 * @param {Function} cancellationCallback - Function that returns true if operation should be cancelled
 * @returns {Promise<Object>} - Save results with success/error counts and details
 */
export async function saveFilesChronologically(files, directoryHandle, progressCallback = null, cancellationCallback = null) {
    logInfo(`🔄 Starting chronological save process: ${files.length} files to ${directoryHandle.name}/`);
    
    // First, scan for existing files
    if (progressCallback) {
        progressCallback(5, 0, files.length, 'Scanning for existing files...');
    }
    
    let scanResults;
    try {
        scanResults = await scanForExistingFiles(files, directoryHandle);
    } catch (error) {
        logError('❌ Scan failed:', error);
        return {
            successCount: 0,
            errorCount: files.length,
            cancelledCount: 0,
            results: files.map(f => ({
                success: false,
                cancelled: false,
                message: `Scan failed: ${error.message}`,
                filename: f.filename
            })),
            totalProcessed: 0,
            scanFailed: true
        };
    }
    
    // Report scan errors to user if any
    if (scanResults.scanErrors && scanResults.scanErrors.length > 0) {
        logWarn(`⚠️ ${scanResults.scanErrors.length} files had scan errors - they will be treated as existing files for safety`);
    }
    
    // If duplicates found, ask user what to do
    let filesToSave = files;
    let userChoice = 'proceed'; // Default for no duplicates
    
    if (scanResults.duplicateCount > 0) {
        logInfo(`📋 Found ${scanResults.duplicateCount} duplicate files, showing dialog...`);
        userChoice = await showBulkDuplicateDialog(scanResults);
        logInfo(`📋 User choice: ${userChoice}`);
        
        if (userChoice === 'cancel') {
            logInfo('📋 User cancelled the operation');
            return { 
                successCount: 0, 
                errorCount: 0, 
                cancelledCount: files.length,
                results: files.map(f => ({
                    success: false,
                    cancelled: true,
                    message: 'Bulk operation cancelled by user',
                    filename: f.filename
                })),
                totalProcessed: 0,
                userCancelled: true
            };
        } else if (userChoice === 'skip') {
            // Only save new files
            filesToSave = scanResults.newFiles;
            logInfo(`📂 User chose to skip duplicates. Saving ${filesToSave.length} new files only.`);
        } else if (userChoice === 'overwrite') {
            // Save all files (overwrite existing)
            filesToSave = files;
            logInfo(`⚠️ User chose to overwrite duplicates. Saving all ${filesToSave.length} files.`);
        }
    } else {
        logInfo('✅ No duplicate files found, proceeding with all files');
    }
    
    // Check for stale scan results (if more than 30 seconds have passed)
    const scanAge = Date.now() - scanResults.timestamp;
    const maxScanAge = 30000; // 30 seconds
    
    if (scanAge > maxScanAge && scanResults.duplicateCount > 0) {
        logWarn(`⚠️ Scan results are ${Math.round(scanAge/1000)}s old. Directory contents may have changed.`);
        
        // Quick re-validation for critical files if needed
        if (userChoice === 'skip') {
            if (progressCallback) {
                progressCallback(8, 0, files.length, 'Re-validating scan results...');
            }
            
            // Re-check a few files to ensure scan is still valid
            const samplesToCheck = Math.min(5, scanResults.existingFiles.length);
            let recheckFailed = false;
            
            for (let i = 0; i < samplesToCheck; i++) {
                const file = scanResults.existingFiles[i];
                try {
                    await directoryHandle.getFileHandle(file.safeFilename);
                } catch (error) {
                    if (error.name === 'NotFoundError') {
                        logWarn(`⚠️ File ${file.safeFilename} was deleted since scan. Results may be stale.`);
                        recheckFailed = true;
                        break;
                    }
                }
            }
            
            if (recheckFailed) {
                logWarn('🔄 Detected stale scan results. Consider re-scanning for accurate results.');
            }
        }
    }
    
            logDebug(`📅 Files will be created oldest-first to maintain chronological order`);
    
    // Now save the selected files
    let successCount = 0;
    let errorCount = 0;
    let cancelledCount = 0;
    const results = [];
    
    // Track skipped files if user chose to skip duplicates
    if (userChoice === 'skip') {
        for (const skippedFile of scanResults.existingFiles) {
            results.push({
                success: false,
                cancelled: true,
                message: `File "${skippedFile.safeFilename}" already exists and was skipped.`,
                filename: skippedFile.filename,
                skipped: true
            });
            cancelledCount++;
        }
    }

    for (let i = 0; i < filesToSave.length; i++) {
        // Check for cancellation before processing each file
        if (cancellationCallback && cancellationCallback()) {
            logInfo('🛑 Save operation cancelled by user');
            // Mark remaining files as cancelled
            for (let j = i; j < filesToSave.length; j++) {
                results.push({
                    success: false,
                    cancelled: true,
                    message: 'Save operation cancelled by user',
                    filename: filesToSave[j].filename
                });
                cancelledCount++;
            }
            break;
        }
        
        const file = filesToSave[i];
        
        try {
            // For bulk operations, force overwrite when user chose overwrite, or don't ask when no duplicates
            const forceOverwrite = userChoice === 'overwrite' || scanResults.duplicateCount === 0;
            const result = await saveFileToDirectory(file.filename, file.content, directoryHandle, forceOverwrite);
            
            results.push(result);
            
            if (result.success) {
                successCount++;
                logInfo(`✅ Saved: ${result.filename}${result.wasOverwrite ? ' (overwritten)' : ''}`);
            } else if (result.cancelled) {
                cancelledCount++;
                logInfo(`⏭️ Skipped: ${result.filename} - ${result.message}`);
            } else {
                errorCount++;
                logWarn(`❌ Failed to save: ${result.filename} - ${result.message}`);
            }
        } catch (error) {
            logError(`❌ Error saving ${file.filename}:`, error);
            errorCount++;
            results.push({
                success: false,
                cancelled: false,
                message: `Unexpected error: ${error.message}`,
                filename: file.filename
            });
        }
        
        // Delay ensures chronological file timestamps
        if (i < filesToSave.length - 1) {
            await delay(PROCESSING_CONFIG.DELAY_BETWEEN_FILES_MS);
        }
        
        // Report progress
        if (progressCallback) {
            // Calculate progress based on files being saved (this represents actual save operation progress)
            const progress = Math.round((10 + ((i + 1) / filesToSave.length) * 90)); // 10% for scanning, 90% for saving
            // Use filesToSave.length for the total display when duplicates are skipped
            // This ensures the progress shows the actual files being processed
            const totalForProgress = userChoice === 'skip' ? filesToSave.length : files.length;
            // The current file number should always be (i + 1) for the files being saved
            progressCallback(progress, i + 1, totalForProgress);
        }
    }

    return { 
        successCount, 
        errorCount, 
        cancelledCount, 
        results,
        totalProcessed: successCount + errorCount + cancelledCount,
        userChoice,
        duplicatesFound: scanResults.duplicateCount,
        scanErrors: scanResults.scanErrors,
        scanAge: Math.round(scanAge / 1000), // Include scan age in results
        userCancelled: cancellationCallback && cancellationCallback() // Check if cancelled at the end
    };
}

/**
 * Scan directory for existing files
 * WHY: Pre-scan allows users to make informed decisions about duplicates before bulk operations
 * 
 * @param {Array} files - Array of file objects to check
 * @param {FileSystemDirectoryHandle} directoryHandle - Target directory
 * @returns {Promise<Object>} - Scan results with existing and new files
 */
export async function scanForExistingFiles(files, directoryHandle) {
    // Validate directory handle first
    if (!directoryHandle) {
        throw new Error('Directory handle is required for scanning');
    }
    
    // Verify directory is still accessible
    try {
        const permission = await directoryHandle.requestPermission({ mode: 'readwrite' });
        if (permission !== 'granted') {
            throw new Error('Directory access permission denied');
        }
    } catch (error) {
        throw new Error(`Cannot access directory: ${error.message}`);
    }
    
    const existingFiles = [];
    const newFiles = [];
    const scanErrors = [];
    
    logInfo(`🔍 Scanning directory for existing files...`);
    
    for (const file of files) {
        const safeFilename = sanitizeFilename(file.filename);
        
        try {
            const fileHandle = await directoryHandle.getFileHandle(safeFilename);
            // File exists - verify it's actually accessible
            try {
                await fileHandle.requestPermission({ mode: 'readwrite' });
                existingFiles.push({
                    ...file,
                    safeFilename
                });
            } catch (permError) {
                // File exists but no write permission
                scanErrors.push({
                    filename: safeFilename,
                    error: 'File exists but no write permission'
                });
                existingFiles.push({
                    ...file,
                    safeFilename,
                    hasWriteAccess: false
                });
            }
        } catch (error) {
            // Check if this is actually a "file not found" error vs other issues
            if (error.name === 'NotFoundError' || error.message.includes('not found')) {
                // File doesn't exist
                newFiles.push({
                    ...file,
                    safeFilename
                });
            } else {
                // Other error - could be permission, corruption, etc.
                logWarn(`⚠️ Scan error for ${safeFilename}:`, error);
                scanErrors.push({
                    filename: safeFilename,
                    error: error.message
                });
                // Treat as existing to be safe (user can choose to overwrite)
                existingFiles.push({
                    ...file,
                    safeFilename,
                    hasError: true,
                    errorMessage: error.message
                });
            }
        }
    }
    
    logInfo(`📊 Scan results: ${existingFiles.length} existing, ${newFiles.length} new files${scanErrors.length > 0 ? `, ${scanErrors.length} errors` : ''}`);
    
    if (scanErrors.length > 0) {
        logWarn('⚠️ Scan errors detected:', scanErrors);
    }
    
    return {
        existingFiles,
        newFiles,
        totalFiles: files.length,
        duplicateCount: existingFiles.length,
        scanErrors,
        timestamp: Date.now() // Add timestamp for staleness detection
    };
}

/**
 * Validate directory handle is still accessible
 * WHY: Directory handles can become invalid due to permission changes
 * 
 * @param {FileSystemDirectoryHandle} directoryHandle - Directory to validate
 * @returns {Promise<boolean>} - Whether directory is still accessible
 */
export async function validateDirectoryAccess(directoryHandle) {
    if (!directoryHandle) return false;
    
    try {
        await directoryHandle.requestPermission({ mode: 'readwrite' });
        return true;
    } catch (error) {
        console.error('Directory validation failed:', error);
        return false;
    }
}

/**
 * Create downloadable blob for fallback download
 * WHY: Provides fallback when File System Access API fails
 * 
 * @param {string} content - File content
 * @param {string} mimeType - MIME type for blob
 * @returns {Blob} - Downloadable blob
 */
export function createDownloadBlob(content, mimeType = 'text/markdown') {
    return new Blob([content], { type: mimeType });
}

/**
 * Trigger file download in browser
 * WHY: Fallback download method when direct saving isn't available
 * 
 * @param {Blob} blob - File blob to download
 * @param {string} filename - Download filename
 */
export function downloadFile(blob, filename) {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}
</file>

<file path="src/modules/conversionEngine.js">
/**
 * Conversation Conversion Engine
 * Handles parsing ChatGPT conversations and converting to Markdown
 * Following AGENTS.md principle: focused, single-responsibility modules
 */

import { 
    generateUniqueFilename, 
    formatTimestamp, 
    sortConversationsChronologically,
    buildObsidianFilename,
    formatLondonCreatedHuman,
    formatLondonHHmm,
    splitByCodeFences,
    ensureClosedFences,
    linkifyText,
    normalizeText,
    demoteHeadings,
    avoidSetextFromHyphens
} from '../utils/helpers.js';
import { logInfo, logDebug } from '../utils/logger.js';

/**
 * Extract and order messages from ChatGPT mapping structure
 * WHY: ChatGPT exports use a complex mapping structure that needs flattening
 * 
 * @param {Object} mapping - ChatGPT conversation mapping object
 * @returns {Array} - Ordered array of message objects
 */
function extractMessagesFromMapping(mapping) {
    const messages = [];
    
    // Find root message (conversation start point)
    let rootId = findRootMessage(mapping);
    if (!rootId) return messages;
    
    // Traverse conversation tree to build ordered message list
    const visited = new Set();
    let currentId = rootId;
    
    while (currentId && !visited.has(currentId)) {
        visited.add(currentId);
        const messageData = mapping[currentId] || {};
        const message = messageData.message || {};
        
        if (message?.content) {
            const processedMessage = extractMessageContent(message);
            if (processedMessage.content.trim()) {
                messages.push(processedMessage);
            }
        }
        
        // Move to next message in conversation thread
        const children = messageData.children || [];
        currentId = children.length > 0 ? children[0] : null;
    }
    
    return messages;
}

/**
 * Find the root message in a conversation mapping
 * WHY: Conversations need a starting point for chronological ordering
 * 
 * @param {Object} mapping - ChatGPT conversation mapping
 * @returns {string|null} - Root message ID or null if not found
 */
function findRootMessage(mapping) {
    // Look for message with no parent
    for (const [msgId, msgData] of Object.entries(mapping)) {
        if (msgData.parent === null && msgData.message) {
            return msgId;
        }
    }
    
    // Fallback: find first message with content
    for (const [msgId, msgData] of Object.entries(mapping)) {
        if (msgData.message?.content) {
            return msgId;
        }
    }
    
    return null;
}

/**
 * Extract content from message object, handling different content structures
 * WHY: ChatGPT exports have varying content formats that need normalization
 * 
 * @param {Object} message - Raw message object from ChatGPT export
 * @returns {Object} - Normalized message with author and content
 */
function extractMessageContent(message) {
    const author = message.author?.role || 'unknown';
    const content = message.content || {};
    const createTime = message.create_time || null;
    
    let textContent = '';
    if (typeof content === 'object' && Array.isArray(content.parts)) {
        const parts = content.parts;
        const mapped = parts.map(part => {
            if (typeof part === 'string') return part;
            // Placeholder for non-text parts (images, citations, etc.)
            return '_Image omitted_';
        });
        textContent = mapped.join('');
    } else if (typeof content === 'string') {
        textContent = content;
    }
    
    return {
        author: author,
        content: textContent.trim(),
        createTime
    };
}

/**
 * Format message content as blockquotes while preserving line breaks
 * WHY: Blockquotes provide better visual distinction for message content
 * 
 * @param {string} content - Raw message content
 * @returns {string} - Content formatted as blockquotes
 */
function formatAsBlockquote(content) {
    if (!content || typeof content !== 'string') {
        return '';
    }
    
    // Split by line breaks and prefix each non-empty line with '> '
    return content
        .split('\n')
        .map(line => line.trim() === '' ? '>' : `> ${line}`)
        .join('\n');
}

/**
 * Convert a single conversation to Markdown format
 * WHY: Markdown requires consistent formatting for proper rendering
 * 
 * @param {Object} conversation - ChatGPT conversation object
 * @returns {string} - Formatted Markdown content
 */
export function convertConversationToMarkdown(conversation) {
    const title = conversation.title || 'Untitled Conversation';
    const createTime = conversation.create_time || 0;
    const mapping = conversation.mapping || {};
    
    const messages = extractMessagesFromMapping(mapping);
    // Frontmatter (Obsidian-optimized)
    const baseDate = new Date(createTime * 1000);
    const createdHuman = formatLondonCreatedHuman(baseDate);
    const convUrl = conversation?.id ? `https://chat.openai.com/c/${conversation.id}` : null;
    const fm = [
        '---',
        `created: ${createdHuman}`,
        'tags: [chatgpt]',
        convUrl ? `url: ${convUrl}` : null,
        '---',
        ''
    ].filter(Boolean).join('\n');

    const lines = [fm];

    // Per-message sections rendered as headings (foldable in Obsidian)
    messages.forEach((m, idx) => {
        const isUser = m.author === 'user';
        const icon = isUser ? '🧑‍💬' : '🤖';
        const label = isUser ? 'User' : 'Assistant';
        const msgDate = m.createTime ? new Date(m.createTime * 1000) : null;
        const timeLabel = msgDate ? formatLondonHHmm(msgDate) : `#${idx + 1}`;

        // Split content to avoid cleaning inside code
        const segments = splitByCodeFences(m.content || '');
        const processed = segments.map(seg => {
            if (seg.type === 'code') return seg.content; // preserve as-is
            // outside code: cleanup
            const withLinks = linkifyText(seg.content);
            // Demote inner headings so the H2 wrapper folds everything beneath
            const normalized = normalizeText(withLinks);
            const demoted = demoteHeadings(normalized, 2);
            return demoted;
        }).join('');

        // Avoid Setext H2 from '---' lines and ensure fences closed
        const safe = ensureClosedFences(avoidSetextFromHyphens(processed)).trim();

        // Heading style for foldable sections in Obsidian Reading/Edit modes
        const heading = `## ${icon} ${label} — ${timeLabel}`;
        lines.push(heading);
        lines.push('');
        lines.push(safe);
        lines.push('');
    });

    const content = lines.join('\n');
    // Clean broken citation artifacts (e.g., citeturn0search12.)
    // Unicode range \uE000-\uF8FF is Private Use Area, covers these weird chars
    const cleanedContent = cleanCitationArtifacts(content);
    return cleanedContent;
}

/**
 * Clean citation artifacts using multi-pass approach
 * WHY: Different citation patterns require different regex strategies for complete removal
 * 
 * @param {string} content - Raw content that may contain citation artifacts
 * @returns {string} - Content with all citation artifacts removed
 */
function cleanCitationArtifacts(content) {
    let cleaned = content;
    
    // Pattern 1: Remove complex citation patterns with Unicode characters
    cleaned = cleaned.replace(/[\uE000-\uF8FF]*(?:cite|navlist)[\uE000-\uF8FF]*.*?turn\d+(?:search|news)\d+[\uE000-\uF8FF]*\.?/g, '');
    
    // Pattern 2: Remove simple turn patterns with Unicode
    cleaned = cleaned.replace(/turn\d+(?:search|news)\d+[\uE000-\uF8FF]*\.?/g, '');
    
    // Pattern 3: Remove any remaining turn patterns without Unicode
    cleaned = cleaned.replace(/turn\d+(?:search|news)\d+\.?/g, '');
    
    // Pattern 4: Remove any remaining Unicode citation artifacts
    cleaned = cleaned.replace(/[\uE000-\uF8FF]+/g, '');
    
    return cleaned;
}

/**
 * Process array of conversations and convert to file objects
 * WHY: Batch processing with error handling and progress tracking
 * 
 * @param {Array} conversations - Array of ChatGPT conversation objects
 * @param {Set} processedIds - Already processed conversation IDs
 * @returns {Object} - Processing results with files array and statistics
 */
export function processConversations(conversations, processedIds = new Set()) {
    const results = {
        processed: 0,
        skipped: 0,
        errors: 0,
        files: []
    };
    
    // Sort chronologically for proper file creation order
    const sortedConversations = sortConversationsChronologically(conversations);
    logInfo(`📅 Processing ${sortedConversations.length} conversations in chronological order (oldest first)`);
    logDebug(`🕐 This ensures consistent chronological ordering of conversations`);
    
    const usedFilenames = [];
    
    for (const conversation of sortedConversations) {
        try {
            const result = processSingleConversation(conversation, processedIds, usedFilenames);
            
            if (result.skipped) {
                results.skipped++;
            } else if (result.file) {
                results.files.push(result.file);
                results.processed++;
                processedIds.add(conversation.id);
            }
        } catch (error) {
            console.error(`Error processing conversation '${conversation.title || 'Unknown'}':`, error);
            results.errors++;
        }
    }
    
    return results;
}

/**
 * Process a single conversation with validation and error handling
 * WHY: Isolates single conversation processing for better error containment
 * 
 * @param {Object} conversation - Individual conversation object
 * @param {Set} processedIds - Already processed conversation IDs  
 * @param {Array} usedFilenames - Already used filenames for duplicate prevention
 * @returns {Object} - Processing result for single conversation
 */
function processSingleConversation(conversation, processedIds, usedFilenames) {
    const conversationId = conversation.id;
    
    if (!conversationId) {
        throw new Error('Conversation without ID found');
    }
    
    // Skip duplicates
    if (processedIds.has(conversationId)) {
        logDebug(`Skipping: ${conversation.title || 'Untitled'} (already processed)`);
        return { skipped: true };
    }
    
    // Convert to Markdown
    const markdownContent = convertConversationToMarkdown(conversation);
    
    // Generate obsidian-optimized filename
    let filename = buildObsidianFilename(conversation);
    // Ensure uniqueness in session
    let counter = 2;
    while (usedFilenames.includes(filename)) {
        const dot = filename.lastIndexOf('.');
        const base = filename.slice(0, dot);
        const ext = filename.slice(dot);
        filename = `${base} (${counter})${ext}`;
        counter++;
    }
    usedFilenames.push(filename);
    
    return {
        file: {
            filename: filename,
            content: markdownContent,
            title: conversation.title || 'Untitled',
            conversationId: conversationId,
            createTime: conversation.create_time || 0, // Add creation time for sorting and display
            createdDate: new Date((conversation.create_time || 0) * 1000).toLocaleDateString() // Formatted date for display
        }
    };
}
</file>

<file path="src/components/ProgressDisplay.js">
/**
 * Progress Display Component
 * Accessible progress indicator with status messaging
 * Following AGENTS.md principle: semantic HTML and ARIA attributes
 */

import { STATUS_MESSAGES } from '../utils/constants.js';
import { logWarn, logInfo } from '../utils/logger.js';

/**
 * Progress Display Component Class
 * WHY: Encapsulates progress UI logic with accessibility features
 */
export class ProgressDisplay {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.statusText = null;
        this.progressBar = null;
        this.progressFill = null;
        this.cancelButton = null;
        this.isVisible = false;
        this.isInitialized = false;
        this.onCancelCallback = null;
        
        if (!this.container) {
            logWarn(`Progress container '${containerId}' not found`);
        }
    }

    /**
     * Initialize progress display elements (only once)
     * WHY: Sets up accessible DOM structure with ARIA attributes for dark theme
     */
    initialize() {
        if (!this.container || this.isInitialized) return;

        this.container.innerHTML = `
            <div class="mb-3">
                <div id="statusText" class="text-sm text-blue-700 mb-2 font-medium" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-live="polite" aria-atomic="true">
                    ${STATUS_MESSAGES.PROCESSING}
                </div>
                <div id="progressBar" class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
            </div>
            <button id="cancelButton" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded text-sm hidden mt-3 flex items-center transition-colors">
                <i class="fas fa-times mr-2"></i>
                Cancel Save
            </button>
        `;

        this.statusText = this.container.querySelector('#statusText');
        this.progressBar = this.container.querySelector('#progressBar');
        this.progressFill = this.container.querySelector('#progressFill');
        this.cancelButton = this.container.querySelector('#cancelButton');
        
        // Set up cancel button event listener
        if (this.cancelButton) {
            this.cancelButton.addEventListener('click', () => {
                this.handleCancel();
            });
        }
        
        this.isInitialized = true;
        logInfo('✅ Progress display initialized');
    }

    /**
     * Handle cancel button click
     * WHY: Provides user feedback and calls cancellation callback
     */
    handleCancel() {
        if (this.cancelButton) {
            this.cancelButton.disabled = true;
            this.cancelButton.innerHTML = `
                <i class="fas fa-spinner fa-spin mr-2"></i>
                Cancelling...
            `;
        }
        
        if (this.onCancelCallback && typeof this.onCancelCallback === 'function') {
            this.onCancelCallback();
        }
    }

    /**
     * Set cancel callback function
     * WHY: Allows parent components to handle cancellation
     * 
     * @param {Function} callback - Function to call when cancel is clicked
     */
    setCancelCallback(callback) {
        this.onCancelCallback = callback;
    }

    /**
     * Show progress display with optional cancel button
     * WHY: Makes progress visible to user with proper styling
     * 
     * @param {boolean} showCancelButton - Whether to show the cancel button
     * @param {boolean} switchToFilesView - Whether to switch to Files view (default: false)
     */
    show(showCancelButton = false, switchToFilesView = false) {
        if (!this.container) {
            logWarn('Progress container not found, cannot show progress');
            return;
        }
        
        // Initialize only if not already done
        if (!this.isInitialized) {
            this.initialize();
        }
        
        // FIRST: Hide all other progress bars before showing this one
        const allProgressCards = [
            document.getElementById('progressCard'),
            document.getElementById('conversionProgressCard')
        ];
        
        allProgressCards.forEach(card => {
            if (card) {
                card.style.display = 'none';
            }
        });
        
        // Also hide all progress containers
        const allProgressContainers = [
            document.getElementById('progressContainer'),
            document.getElementById('conversionProgressContainer')
        ];
        
        allProgressContainers.forEach(container => {
            if (container) {
                container.style.display = 'none';
            }
        });
        
        // Hide the upload card when showing progress (for conversion operations)
        if (!switchToFilesView) {
            const uploadCard = document.getElementById('uploadCard');
            if (uploadCard) {
                uploadCard.style.display = 'none';
                logInfo('✅ Upload card hidden during conversion');
            }
        }
        
        this.container.style.display = 'block';
        this.isVisible = true;
        
        // Show/hide cancel button based on parameter
        if (this.cancelButton) {
            if (showCancelButton) {
                this.cancelButton.classList.remove('hidden');
                this.cancelButton.disabled = false;
                this.cancelButton.innerHTML = `
                    <i class="fas fa-times mr-2"></i>
                    Cancel Save
                `;
            } else {
                this.cancelButton.classList.add('hidden');
            }
        }
        
        // Ensure the appropriate progress card is visible
        let progressCard = null;
        if (switchToFilesView) {
            // For file saving operations, show the Files view progress card
            progressCard = document.getElementById('progressCard');
            if (progressCard) {
                progressCard.classList.remove('hidden');
                logInfo('✅ Progress card made visible in Files view');
            } else {
                logWarn('⚠️ Progress card element not found');
            }
            
            // Ensure we're on the Files view when showing progress
            if (window.switchToView) {
                window.switchToView('files');
                logInfo('✅ Switched to Files view for progress display');
            }
        } else {
            // For conversion operations, show the Upload view progress card
            const conversionProgressCard = document.getElementById('conversionProgressCard');
            if (conversionProgressCard) {
                conversionProgressCard.classList.remove && conversionProgressCard.classList.remove('hidden');
                conversionProgressCard.style.display = 'block';
                logInfo('✅ Conversion progress card made visible in Upload view');
            } else {
                logWarn('⚠️ Conversion progress card element not found');
            }
        }
        
        logInfo('✅ Progress display shown');
        
        // Force a small delay to ensure DOM updates are complete
        setTimeout(() => {
            // Ensure the specific progress card is visible if it was set
            if (progressCard) {
                progressCard.style.display = 'block';
            }
            // Ensure the container itself is visible (this is the actual progress bar container)
            if (this.container) {
                this.container.style.display = 'block';
            }
        }, 50);
    }

    /**
     * Hide progress display
     * WHY: Clears progress when conversion is complete
     */
    hide() {
        if (!this.container) return;
        
        this.container.style.display = 'none';
        this.isVisible = false;
        
        // Hide both progress cards
        const progressCard = document.getElementById('progressCard');
        if (progressCard) {
            progressCard.classList.add && progressCard.classList.add('hidden');
            progressCard.style.display = 'none';
            logInfo('✅ Progress card hidden');
        }
        
        const conversionProgressCard = document.getElementById('conversionProgressCard');
        if (conversionProgressCard) {
            conversionProgressCard.classList.add && conversionProgressCard.classList.add('hidden');
            conversionProgressCard.style.display = 'none';
            logInfo('✅ Conversion progress card hidden');
        }

        // Show upload card again when hiding conversion progress
        const uploadCard = document.getElementById('uploadCard');
        if (uploadCard) {
            uploadCard.style.display = 'block';
        }
    }

    /**
     * Update progress value and status message
     * WHY: Provides real-time feedback with accessibility support
     * 
     * @param {number} percentage - Progress percentage (0-100)
     * @param {string} message - Status message to display
     */
    updateProgress(percentage, message) {
        // Ensure initialization if not done yet
        if (!this.isInitialized) {
            this.initialize();
        }
        
        if (!this.statusText || !this.progressBar || !this.progressFill) {
            logWarn('⚠️ Progress elements not found, reinitializing...');
            this.initialize();
            if (!this.statusText || !this.progressBar || !this.progressFill) {
                logWarn('⚠️ Still cannot find progress elements');
                return;
            }
        }
        
        // Update progress bar ARIA attributes on statusText (as expected by tests)
        this.statusText.setAttribute('aria-valuenow', percentage);
        
        // Update status message
        this.statusText.textContent = message;
        this.statusText.className = 'progress-text'; // Reset to default style
        
        // Update progress fill width
        const clampedPercentage = Math.max(0, Math.min(100, percentage));
        this.progressFill.style.width = `${clampedPercentage}%`;
        
        // Add completion styling if at 100%
        if (percentage >= 100) {
            this.statusText.className = 'progress-text success';
            this.progressFill.style.background = 'var(--success)';
        } else {
            this.progressFill.style.background = 'var(--accent-primary)';
        }
        
        // Log progress for debugging
        logInfo(`📊 Progress: ${percentage}% - ${message}`);
    }

    /**
     * Display error message
     * WHY: Provides clear error feedback with appropriate styling
     * 
     * @param {string} errorMessage - Error message to display
     */
    showError(errorMessage) {
        // Ensure initialization if not done yet
        if (!this.isInitialized) {
            this.initialize();
        }
        
        if (!this.statusText) {
            logWarn('⚠️ Status text element not found, cannot show error');
            return;
        }
        
        this.statusText.textContent = errorMessage;
        this.statusText.className = 'progress-text error';
        this.statusText.setAttribute('role', 'alert');
        
        // Reset progress bar to 0
        if (this.progressFill) {
            this.progressFill.style.width = '0%';
            this.progressFill.style.background = 'var(--accent-primary)';
        }
        
        logInfo(`❌ Error displayed: ${errorMessage}`);
    }
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatGPT to Markdown Converter</title>
    <meta name="description" content="Convert your ChatGPT conversations to clean Markdown files">
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>📝</text></svg>">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        .dropzone {
            transition: all 0.3s ease;
        }
        .dropzone.active {
            border-color: #4f46e5;
            background-color: #eef2ff;
        }
        .conversation-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Progress bar styling */
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #4f46e5;
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        /* Status message styling */
        .status {
            padding: 12px 16px;
            border-radius: 8px;
            margin: 12px 0;
            border-left: 4px solid;
        }
        
        .status.success {
            background: #f0fdf4;
            color: #15803d;
            border-left-color: #15803d;
        }
        
        .status.error {
            background: #fef2f2;
            color: #dc2626;
            border-left-color: #dc2626;
        }
        
        .status.info {
            background: #eff6ff;
            color: #2563eb;
            border-left-color: #2563eb;
        }
        
        /* Pulse animation for save button */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(79, 70, 229, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(79, 70, 229, 0); }
            100% { box-shadow: 0 0 0 0 rgba(79, 70, 229, 0); }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        /* Accessibility improvements */
        .sr-only {
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            padding: 0 !important;
            margin: -1px !important;
            overflow: hidden !important;
            clip: rect(0, 0, 0, 0) !important;
            white-space: nowrap !important;
            border: 0 !important;
        }
        
        /* Focus styles */
        .focus\:ring-2:focus {
            outline: 2px solid #4f46e5;
            outline-offset: 2px;
        }
        
        /* Hide elements by default */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-4xl">
        <!-- Header -->
        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold text-indigo-700 mb-3">ChatGPT to Markdown Converter</h1>
            <p class="text-lg text-gray-600">Transform your conversations into clean, organized Markdown files</p>
        </header>

        <!-- Main Content -->
        <main>
            <!-- Upload Section -->
            <section id="upload-section" class="bg-white rounded-xl shadow-md p-6 mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 flex items-center">
                    <i class="fas fa-upload mr-3 text-indigo-500"></i>
                    Upload Conversations
                </h2>
                <p class="text-gray-600 mb-6">Select your ChatGPT conversations.json file to begin conversion</p>
                
                <!-- Progress Display for Conversion -->
                <div id="conversionProgressCard" class="hidden bg-blue-50 border-l-4 border-blue-500 p-4 mb-6">
                    <div class="flex">
                        <div class="flex-shrink-0">
                            <i class="fas fa-spinner fa-spin text-blue-500"></i>
                        </div>
                        <div class="ml-3 w-full">
                            <p class="text-sm text-blue-700 mb-2">Converting your conversations...</p>
                            <div id="conversionProgressContainer" class="hidden">
                                <!-- Progress content will be dynamically generated by ProgressDisplay component -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="dropzone" class="dropzone border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:border-indigo-400 transition-colors" role="button" tabindex="0" aria-label="Upload area for ChatGPT conversations.json file">
                    <div class="flex flex-col items-center justify-center space-y-3">
                        <i class="fas fa-file-import text-4xl text-indigo-400" style="font-size: 3rem;"></i>
                        <p class="text-lg font-medium text-gray-700">Drop your conversations.json file here</p>
                        <p class="text-gray-500">or</p>
                        <button id="browse-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-6 rounded-lg transition-colors focus:ring-2 focus:ring-indigo-200">
                            Click to browse files
                        </button>
                    </div>
                    <input type="file" id="fileInput" accept=".json" class="hidden" aria-label="Select conversations.json file">
                </div>
                
                <div class="mt-4 text-sm text-gray-500">
                    <i class="fas fa-info-circle mr-1"></i>
                    Please select a conversations.json file exported from ChatGPT. The file should contain an array of conversation objects.
                </div>
            </section>

            <!-- Conversion Complete Section (Hidden by default) -->
            <section id="complete-section" class="hidden bg-white rounded-xl shadow-md p-6 mb-8 fade-in">
                <div class="flex items-center justify-between mb-6">
                    <h2 class="text-2xl font-semibold text-gray-800 flex items-center">
                        <i class="fas fa-check-circle mr-3 text-green-500"></i>
                        Conversion Complete
                    </h2>
                    <button id="new-conversion-btn" class="text-indigo-600 hover:text-indigo-800 font-medium flex items-center focus:ring-2 focus:ring-indigo-200 rounded px-2 py-1">
                        <i class="fas fa-redo mr-2"></i>
                        New Conversion
                    </button>
                </div>
                
                <div class="bg-green-50 border-l-4 border-green-500 p-4 mb-6">
                    <div class="flex">
                        <div class="flex-shrink-0">
                            <i class="fas fa-check-circle text-green-500"></i>
                        </div>
                        <div class="ml-3">
                            <p class="text-sm text-green-700">
                                Your conversations have been successfully converted to Markdown format.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Results Content -->
                <div id="results" class="hidden">
                    <!-- ZIP Download Section -->
                    <div class="zip-download text-center mb-6">
                        <button id="downloadZip" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors flex items-center mx-auto focus:ring-2 focus:ring-indigo-200">
                            <i class="fas fa-download mr-3"></i>
                            Download All as ZIP
                        </button>
                        <p class="text-sm text-gray-500 mt-2">Download all converted files in a single ZIP archive</p>
                    </div>
                    
                    <div id="downloadList" class="mb-6">
                        <!-- Download options will be populated here -->
                    </div>
                </div>

                <!-- Individual Files Section -->
                <div>
                    <h3 class="text-xl font-medium text-gray-800 mb-4 flex items-center">
                        <i class="fas fa-file-alt mr-3 text-indigo-500"></i>
                        Individual Files
                    </h3>
                    <p class="text-gray-600 mb-4">Browse, sort, and download individual conversation files</p>
                    
                    <!-- Files Container -->
                    <div id="filesContainer" class="hidden">
                        <!-- Progress Display for Save Operations -->
                        <div id="progressCard" class="hidden bg-blue-50 border-l-4 border-blue-500 p-4 mb-6">
                            <div class="flex">
                                <div class="flex-shrink-0">
                                    <i class="fas fa-spinner fa-spin text-blue-500"></i>
                                </div>
                                <div class="ml-3 w-full">
                                    <p class="text-sm text-blue-700 mb-2">Saving files to your selected folder...</p>
                                    <div id="progressContainer" class="hidden">
                                        <!-- Progress content will be dynamically generated by ProgressDisplay component -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex items-center justify-between mb-4">
                            <div class="relative w-64">
                                <input type="text" id="search-conversations" placeholder="Search conversations..." class="w-full pl-10 pr-4 py-2 rounded-lg border border-gray-300 focus:ring-2 focus:ring-indigo-200 focus:border-indigo-500">
                                <i class="fas fa-search absolute left-3 top-3 text-gray-400"></i>
                            </div>
                            <div class="flex items-center space-x-4">
                                <div id="resultsInfo" class="text-sm text-gray-600"></div>
                                <div>
                                    <label for="sortSelect" class="sr-only">Sort by</label>
                                    <select id="sortSelect" class="rounded-lg border border-gray-300 py-2 pl-3 pr-8 focus:ring-2 focus:ring-indigo-200 focus:border-indigo-500">
                                        <option value="date-desc">Newest first</option>
                                        <option value="date-asc">Oldest first</option>
                                        <option value="name-asc">Title (A-Z)</option>
                                        <option value="name-desc">Title (Z-A)</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Files table container -->
                        <div class="overflow-x-auto border border-gray-200 rounded-lg">
                            <table id="fileTable" class="w-full border-collapse bg-white">
                                <thead class="bg-gray-50 border-b border-gray-200">
                                    <tr>
                                        <th id="titleHeader" class="px-4 py-3 text-left font-semibold text-gray-800 text-sm cursor-pointer hover:bg-gray-100 transition-colors" style="width: 65%;">
                                            Title <span class="sort-indicator ml-2"></span>
                                        </th>
                                        <th id="dateHeader" class="px-4 py-3 text-left font-semibold text-gray-800 text-sm cursor-pointer hover:bg-gray-100 transition-colors" style="width: 20%;">
                                            Date <span class="sort-indicator ml-2"></span>
                                        </th>
                                        <th class="px-4 py-3 text-right font-semibold text-gray-800 text-sm" style="width: 15%;">Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="fileTableBody">
                                    <!-- File rows will be dynamically generated -->
                                </tbody>
                            </table>
                        </div>
                        
                        <!-- Pagination -->
                        <div id="paginationContainer" class="flex justify-center items-center space-x-2 mt-4">
                            <!-- Pagination buttons will be dynamically generated -->
                        </div>
                    </div>
                    
                    <div id="conversations-list" class="space-y-3">
                        <!-- Conversation items will be added here dynamically -->
                    </div>
                </div>
            </section>
        </main>

        <!-- Footer -->
        <footer class="mt-12 text-center text-gray-500 text-sm">
            <p>ChatGPT to Markdown Converter • Last updated: <span id="current-date"></span></p>
        </footer>
    </div>

    <!-- Hidden elements for compatibility -->
    <div id="uploadArea" style="display: none;"></div>
    <div id="file-requirements" class="sr-only">
        Please select a conversations.json file exported from ChatGPT. The file should contain an array of conversation objects.
    </div>

    <!-- JSZip library for ZIP file creation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script type="module" src="src/main.js"></script>
    <script>
        // Set current date in footer
        document.getElementById('current-date').textContent = new Date().toLocaleDateString('en-US', {
            weekday: 'short',
            year: 'numeric',
            month: 'short',
            day: 'numeric'
        });

        // File upload functionality integration
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        const browseBtn = document.getElementById('browse-btn');
        const uploadSection = document.getElementById('upload-section');
        const completeSection = document.getElementById('complete-section');
        const newConversionBtn = document.getElementById('new-conversion-btn');

        // Handle drag and drop events
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropzone.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            dropzone.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropzone.addEventListener(eventName, unhighlight, false);
        });

        function highlight() {
            dropzone.classList.add('active');
        }

        function unhighlight() {
            dropzone.classList.remove('active');
        }

        // Handle dropped files
        dropzone.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length) {
                // Let the existing FileUploader component handle this
                fileInput.files = files;
                fileInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
        }

        // Handle file selection via button
        browseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            fileInput.click();
        });

        // New conversion button
        newConversionBtn.addEventListener('click', () => {
            completeSection.classList.add('hidden');
            uploadSection.classList.remove('hidden');
            fileInput.value = '';
            
            // Reset any visible progress or results
            document.getElementById('conversionProgressCard').classList.add('hidden');
            document.getElementById('results').classList.add('hidden');
            document.getElementById('filesContainer').classList.add('hidden');
            document.getElementById('progressCard').classList.add('hidden');
        });

        // Search functionality
        document.getElementById('search-conversations').addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase();
            const items = document.querySelectorAll('.conversation-item');
            
            items.forEach(item => {
                const title = item.querySelector('h4').textContent.toLowerCase();
                if (title.includes(searchTerm)) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        });

        // Basic sort functionality for conversation list (existing app will override this)
        document.getElementById('sortSelect') && document.getElementById('sortSelect').addEventListener('change', function() {
            // This will be handled by the existing application logic
        });

        // ZIP download button functionality
        document.getElementById('downloadZip') && document.getElementById('downloadZip').addEventListener('click', function() {
            // This will be connected by the application when results are displayed
            if (window.ChatGPTConverterApp && window.ChatGPTConverterApp.getInstance()) {
                window.ChatGPTConverterApp.getInstance().downloadAllAsZip();
            }
        });

        // View switching compatibility (for new design)
        window.switchToComplete = function() {
            uploadSection.classList.add('hidden');
            completeSection.classList.remove('hidden');
        };

        window.switchToUpload = function() {
            completeSection.classList.add('hidden');
            uploadSection.classList.remove('hidden');
        };

        window.showResults = function() {
            document.getElementById('results').classList.remove('hidden');
        };

        window.showFiles = function() {
            document.getElementById('filesContainer').classList.remove('hidden');
        };

        window.hideProgressCard = function() {
            document.getElementById('progressCard').classList.add('hidden');
        };

        window.showProgressCard = function() {
            document.getElementById('progressCard').classList.remove('hidden');
        };
    </script>

    <footer>
        <p class="sr-only">
            This tool processes your files locally in your browser for privacy. 
            No data is sent to external servers.
        </p>
    </footer>
</body>
</html>
</file>

<file path="src/modules/applicationOrchestrator.js">
/**
 * Application Orchestrator
 * Main coordinator for the ChatGPT to Markdown converter application
 * Following AGENTS.md principle: clean architecture with separated concerns
 */

import { FileUploader } from '../components/FileUploader.js';
import { ProgressDisplay } from '../components/ProgressDisplay.js';
import UIBuilder from '../components/UIBuilder.js';
import { processConversations } from './conversionEngine.js';
import { 
    selectDirectory, 
    saveFilesChronologically, 
    validateDirectoryAccess,
    downloadFile,
    createDownloadBlob,
    isFileSystemAccessSupported,
    saveFileToDirectory,
    scanForExistingFiles,
    getFileSystemAccessInfo
} from './fileSystemManager.js';
import { ERROR_MESSAGES, STATUS_MESSAGES } from '../utils/constants.js';
import { logInfo, logDebug, logWarn, logError } from '../utils/logger.js';
import { telemetry } from '../utils/telemetry.js';
import { 
    getString, 
    status, 
    error, 
    success, 
    info, 
    ui, 
    message, 
    formatFileSize 
} from '../utils/strings.js';
import { accessibilityManager } from '../utils/accessibility.js';

/**
 * ChatGPT to Markdown Application
 * WHY: Orchestrates the entire conversion workflow with proper error handling
 */
export class ChatGPTConverter {
    constructor() {
        this.fileUploader = null;
        this.progressDisplay = null;
        this.selectedDirectoryHandle = null;
        this.convertedFiles = [];
        this.processedIds = new Set();
        this.saveLocalButton = null;
        this.uiBuilder = new UIBuilder();
        
        this.initializeComponents();
    }

    /**
     * Initialize all application components
     * WHY: Sets up the UI components and establishes connections
     */
    initializeComponents() {
        try {
            // Initialize components with new structure
            this.fileUploader = new FileUploader('dropzone', 'fileInput');
            this.progressDisplay = new ProgressDisplay('conversionProgressContainer');
            this.saveProgressDisplay = new ProgressDisplay('progressContainer');
            
            // Set up file upload handling
            this.fileUploader.setFileSelectedCallback(this.handleFileUpload.bind(this));
            
            // Initialize accessibility features
            accessibilityManager.initialize();
            
            const initMessage = message('INITIALIZING_CONVERTER');
            const apiMessage = isFileSystemAccessSupported() 
                ? message('FILE_SYSTEM_API_AVAILABLE')
                : message('FILE_SYSTEM_API_NOT_AVAILABLE');
                
            logInfo(`✅ ${initMessage}`);
            logInfo(`📁 ${apiMessage}`);
            
            // Announce initialization to screen readers
            accessibilityManager.announceStatus(initMessage, 'success');
            
        } catch (e) {
            logError('❌ Failed to initialize application:', e);
            const errorMessage = error('FAILED_TO_INITIALIZE');
            this.showError(errorMessage);
            accessibilityManager.announceStatus(errorMessage, 'error');
        }
    }

    /**
     * Handle file upload and processing
     * WHY: Coordinates the entire file processing workflow
     * 
     * @param {File} file - Uploaded file to process
     */
    async handleFileUpload(file) {
        const startTime = Date.now();
        logInfo(message('PROCESSING_FILE', { fileName: file.name, fileSize: formatFileSize(file.size) }));
        
        // Track conversion start
        telemetry.trackConversionStarted(file.size, file.name);
        
        this.fileUploader.setProcessingState(true);
        this.progressDisplay.show(false, false); // Don't switch to Files view for conversion
        
        try {
            // Read and parse file
            const readingMessage = status('READING_FILE');
            this.progressDisplay.updateProgress(0, readingMessage);
            accessibilityManager.announceProgress(readingMessage, 0);
            const fileContent = await this.readFileContent(file);
            
            // Add a small delay to make reading feel more substantial
            await this.delay(300);
            
            const parsingMessage = status('PARSING_JSON');
            this.progressDisplay.updateProgress(20, parsingMessage);
            accessibilityManager.announceProgress(parsingMessage, 20);
            const conversations = this.parseConversations(fileContent);
            
            // Add delay for parsing
            await this.delay(400);
            
            // Convert conversations with more granular progress
            const convertingMessage = status('CONVERTING');
            this.progressDisplay.updateProgress(40, convertingMessage);
            accessibilityManager.announceProgress(convertingMessage, 40);
            const results = processConversations(conversations, this.processedIds);
            
            // Add delay for conversion processing
            await this.delay(500);
            
            const finalizingMessage = status('FINALIZING');
            this.progressDisplay.updateProgress(80, finalizingMessage);
            accessibilityManager.announceProgress(finalizingMessage, 80);
            await this.delay(300);
            
            const completeMessage = status('COMPLETE');
            this.progressDisplay.updateProgress(100, completeMessage);
            accessibilityManager.announceProgress(completeMessage, 100);
            this.convertedFiles = results.files;
            
            // Track successful conversion
            const processingTime = Date.now() - startTime;
            telemetry.trackConversionCompleted(
                conversations.length, 
                results.files.length, 
                processingTime, 
                results.errors
            );
            
            // Add final delay before showing results
            await this.delay(800);
            
            // Display results with delay for smooth transition
            setTimeout(() => {
                this.displayResults(results);
                
                // Switch to complete section and show results
                if (window.switchToComplete) {
                    window.switchToComplete();
                    window.showResults();
                    
                    // Populate the Files view in the background
                    setTimeout(() => {
                        if (results.files && results.files.length > 0) {
                            this.populateFilesView(results);
                            window.showFiles();
                            logInfo(`✅ Files view populated with ${results.files.length} files`);
                        } else {
                            logWarn('⚠️ No files available to populate Files view');
                        }
                    }, 100);
                }
                
                // Hide progress after switching to results view
                setTimeout(() => {
                    this.progressDisplay.hide();
                }, 200);
            }, 500);
            
        } catch (error) {
            logError('❌ Error processing file:', error);
            
            // Track conversion failure with context
            const stage = error.message.includes('JSON') ? 'parsing' : 
                         error.message.includes('structure') ? 'parsing' : 'processing';
            telemetry.trackConversionFailed(error, stage);
            
            this.progressDisplay.showError(error.message);
            this.showError(error.message);
            accessibilityManager.announceStatus(`Conversion failed: ${error.message}`, 'error');
        } finally {
            this.fileUploader.setProcessingState(false);
        }
    }

    /**
     * Read file content as text
     * WHY: Promisified file reading with error handling
     * 
     * @param {File} file - File to read
     * @returns {Promise<string>} - File content
     */
    readFileContent(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(new Error('Failed to read file'));
            reader.readAsText(file);
        });
    }

    /**
     * Parse conversations JSON with validation
     * WHY: Validates JSON structure before processing
     * 
     * @param {string} fileContent - Raw file content
     * @returns {Array} - Parsed conversations array
     */
    parseConversations(fileContent) {
        let conversations;
        
        try {
            conversations = JSON.parse(fileContent);
        } catch (parseError) {
            throw new Error(error('INVALID_JSON'));
        }
        
        if (!Array.isArray(conversations)) {
            throw new Error(error('INVALID_STRUCTURE'));
        }
        
        return conversations;
    }

    /**
     * Handle directory selection for local saving
     * WHY: Provides user control over save location
     */
    async handleDirectorySelection() {
        try {
            const directoryHandle = await selectDirectory();
            this.selectedDirectoryHandle = directoryHandle;
            this.uiBuilder.setDirectoryHandle(directoryHandle);
            
            // Track directory selection
            telemetry.trackDirectorySelected();
            
            const successMessage = `✅ ${success('DIRECTORY_SELECTED')}: ${directoryHandle.name}. ${success('READY_TO_SAVE')}`;
            this.showSuccess(successMessage);
            accessibilityManager.announceStatus(`Directory selected: ${directoryHandle.name}`, 'success');
            
            this.updateSaveButtonState();
            
            // Re-render the files table to show Save buttons
            if (this.allFiles && this.allFiles.length > 0) {
                this.renderFilesTable();
            }
            
        } catch (error) {
            console.error('Directory selection error:', error);
            this.showError(error.message);
            accessibilityManager.announceStatus(`Directory selection failed: ${error.message}`, 'error');
        }
    }



    /**
     * Save files to local directory
     * WHY: Orchestrates the file saving process with progress feedback
     */
    async handleLocalSave() {
        const saveStartTime = Date.now();
        
        if (!this.selectedDirectoryHandle) {
            const errorMessage = error('NO_DIRECTORY');
            this.showError(errorMessage);
            accessibilityManager.announceStatus(errorMessage, 'error');
            return;
        }

        // Validate directory is still accessible
        const isValid = await validateDirectoryAccess(this.selectedDirectoryHandle);
        if (!isValid) {
            const errorMessage = error('DIRECTORY_ACCESS_LOST');
            this.showError(`❌ ${errorMessage}`);
            accessibilityManager.announceStatus(errorMessage, 'error');
            this.selectedDirectoryHandle = null;
            this.uiBuilder.setDirectoryHandle(null);
            this.updateSaveButtonState();
            return;
        }

        logInfo(`💾 Starting save operation for ${this.convertedFiles.length} files to ${this.selectedDirectoryHandle.name}`);
        
        // Switch to Files view first, then show progress
        if (window.switchToView) {
            window.switchToView('files');
            logInfo('✅ Switched to Files view for save operation');
        }
        
        // Set up cancellation flag
        let isCancelled = false;
        
        // Show progress display with cancel button and switch to Files view
        this.saveProgressDisplay.show(true, true);
        this.saveProgressDisplay.setCancelCallback(() => {
            isCancelled = true;
            logInfo('🛑 User requested cancellation of save operation');
        });
        
        const preparingMessage = info('PREPARING_FILES', { 
            count: this.convertedFiles.length, 
            folderName: this.selectedDirectoryHandle.name 
        });
        this.showInfo(`💾 ${preparingMessage}`);
        accessibilityManager.announceStatus(preparingMessage);

        try {
            const progressCallback = (progress, completed, total, statusMessage) => {
                const message = statusMessage || `💾 ${status('SAVING_FILES')} ${progress}% (${completed}/${total})`;
                logInfo(`📊 Progress update: ${progress}% - ${message}`);
                this.saveProgressDisplay.updateProgress(progress, message);
                accessibilityManager.announceProgress(message, progress);
            };

            const cancellationCallback = () => isCancelled;

            const results = await saveFilesChronologically(
                this.convertedFiles, 
                this.selectedDirectoryHandle, 
                progressCallback,
                cancellationCallback
            );

            // Track save operation results
            const saveTime = Date.now() - saveStartTime;
            telemetry.trackFilesSaved('local', this.convertedFiles.length, results.successCount, saveTime);

            logInfo(`✅ Save operation completed: ${results.successCount} saved, ${results.cancelledCount} cancelled, ${results.errorCount} errors`);

            // Handle different outcomes based on user choice and results
            if (results.userCancelled) {
                this.showInfo('📂 Save operation cancelled');
                return;
            }

            // Build detailed success message
            let message = '';
            const parts = [];
            
            if (results.successCount > 0) {
                parts.push(`✅ Saved ${results.successCount} files`);
            }
            
            if (results.cancelledCount > 0) {
                if (results.userChoice === 'skip') {
                    parts.push(`📂 Skipped ${results.cancelledCount} existing files`);
                } else {
                    parts.push(`📂 ${results.cancelledCount} cancelled`);
                }
            }
            
            if (results.errorCount > 0) {
                parts.push(`❌ ${results.errorCount} errors`);
            }
            
            message = parts.join(', ');
            
            // Show appropriate message based on results
            if (results.successCount > 0) {
                this.showSuccess(`${message} in ${this.selectedDirectoryHandle.name}`);
                
                // Show additional context about user choice
                if (results.duplicatesFound > 0) {
                    setTimeout(() => {
                        if (results.userChoice === 'skip') {
                            this.showSuccess(`✅ SUCCESS! ${results.successCount} new files saved. ${results.duplicatesFound} existing files left unchanged.`);
                        } else if (results.userChoice === 'overwrite') {
                            this.showSuccess(`✅ SUCCESS! All ${results.successCount} files saved. ${results.duplicatesFound} files were overwritten.`);
                        }
                    }, 1000);
                } else {
                    setTimeout(() => {
                        this.showSuccess(`✅ SUCCESS! Check your ${this.selectedDirectoryHandle.name} folder for the files`);
                    }, 1000);
                }
            } else if (results.cancelledCount > 0 && results.errorCount === 0) {
                if (results.userChoice === 'skip') {
                    this.showInfo(`📂 All files already existed and were skipped. No new files to save.`);
                } else {
                    this.showInfo(`📂 All ${results.cancelledCount} file saves were cancelled`);
                }
            } else {
                this.showError(`❌ Failed to save any files. ${results.errorCount} errors occurred. Check permissions or try downloading instead.`);
            }

        } catch (error) {
            console.error('❌ Error during save:', error);
            telemetry.trackError('save', error, { 
                fileCount: this.convertedFiles.length,
                directoryName: this.selectedDirectoryHandle?.name 
            });
            
            const errorMessage = `${error('SAVE_FAILED')}: ${error.message}`;
            this.showError(errorMessage);
            accessibilityManager.announceStatus(errorMessage, 'error');
        } finally {
            // Clear the cancel callback
            this.saveProgressDisplay.setCancelCallback(null);
            setTimeout(() => this.saveProgressDisplay.hide(), 1000);
        }
    }

    /**
     * Download individual file
     * WHY: Provides fallback download option
     * 
     * @param {Object} file - File object to download
     */
    downloadSingleFile(file) {
        try {
            const blob = createDownloadBlob(file.content);
            downloadFile(blob, file.filename);
            
            // Track individual file download
            telemetry.trackIndividualFileAction('download', true);
            accessibilityManager.announceFileOperation('download', true, file.filename);
        } catch (error) {
            console.error(`Error downloading ${file.filename}:`, error);
            telemetry.trackIndividualFileAction('download', false, error);
            
            const errorMessage = `${error('DOWNLOAD_FAILED')} ${file.filename}`;
            this.showError(errorMessage);
            accessibilityManager.announceFileOperation('download', false, file.filename);
        }
    }

    /**
     * Save individual file to chosen directory
     * WHY: Reuses the same File System Access API logic as bulk save for consistency
     * 
     * @param {Object} file - File object to save
     */
    async saveSingleFileToMarkdown(file) {
        try {
            // Check if File System Access API is supported
            if (!isFileSystemAccessSupported()) {
                const errorMessage = error('BROWSER_NOT_SUPPORTED');
                this.showError(errorMessage);
                accessibilityManager.announceStatus(errorMessage, 'error');
                return;
            }

            const chooseMessage = info('CHOOSE_SAVE_LOCATION', { filename: file.title || file.filename });
            this.showInfo(`📁 ${chooseMessage}`);
            
            // Let user select directory for this specific file
            const directoryHandle = await selectDirectory();
            
            if (!directoryHandle) {
                const cancelMessage = info('SAVE_CANCELLED');
                this.showInfo(`📂 ${cancelMessage}`);
                accessibilityManager.announceStatus(cancelMessage);
                return;
            }

            this.showInfo(`💾 Saving "${file.filename}" to ${directoryHandle.name}...`);

            // Use the updated save logic with detailed response
            const result = await saveFileToDirectory(file.filename, file.content, directoryHandle);
            
            if (result.success) {
                // Track successful individual file save
                telemetry.trackIndividualFileAction('save', true);
                
                // Show prominent success confirmation
                this.showFileSaveConfirmation(file.title || file.filename, directoryHandle.name, result.filename);
                logInfo(`✅ Individual file saved: ${result.filename} → ${directoryHandle.name}/`);
                accessibilityManager.announceFileOperation('save', true, file.filename);
            } else if (result.cancelled) {
                this.showInfo(`📂 ${result.message}`);
                logInfo(`📂 Save cancelled by user: ${result.filename}`);
                accessibilityManager.announceStatus(result.message);
            } else {
                telemetry.trackIndividualFileAction('save', false, new Error(result.message));
                this.showError(`❌ ${result.message}`);
                logError(`❌ Save failed: ${result.filename} - ${result.message}`);
                accessibilityManager.announceFileOperation('save', false, file.filename);
            }

        } catch (saveError) {
            logError(`Error saving individual file ${file.filename}:`, saveError);
            telemetry.trackError('save', saveError, { type: 'individual_file', filename: file.filename });
            
            // Provide specific error messages
            if (saveError.message.includes('cancelled')) {
                const cancelMessage = info('SAVE_CANCELLED');
                this.showInfo(`📂 ${cancelMessage}`);
                accessibilityManager.announceStatus(cancelMessage);
            } else {
                const errorMessage = `${error('SAVE_FAILED')} "${file.filename}": ${saveError.message}`;
                this.showError(errorMessage);
                accessibilityManager.announceStatus(errorMessage, 'error');
            }
        }
    }

    /**
     * Download all files individually
     * WHY: Batch download fallback when local saving fails
     */
    downloadAllFiles() {
        let successCount = 0;
        
        for (const file of this.convertedFiles) {
            try {
                this.downloadSingleFile(file);
                successCount++;
            } catch (error) {
                logError(`Error downloading ${file.filename}:`, error);
            }
        }
        
        this.showSuccess(`📥 Downloaded ${successCount} files`);
    }

    /**
     * Download all files as a ZIP archive
     * WHY: Provides a single download option for mobile users
     */
    async downloadAllAsZip() {
        const zipStartTime = Date.now();
        
        try {
            // Check if JSZip is available
            if (typeof JSZip === 'undefined') {
                // Fallback to individual downloads
                const fallbackMessage = info('ZIP_NOT_AVAILABLE');
                this.showInfo(`📦 ${fallbackMessage}`);
                accessibilityManager.announceStatus(fallbackMessage);
                this.downloadAllFiles();
                return;
            }

            const creatingMessage = status('CREATING_ZIP');
            this.showInfo(`📦 ${creatingMessage}`);
            accessibilityManager.announceStatus(creatingMessage);
            
            const zip = new JSZip();
            
            // Add all files to the ZIP
            for (const file of this.convertedFiles) {
                zip.file(file.filename, file.content);
            }
            
            // Generate the ZIP file
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            
            // Download the ZIP file
            const url = URL.createObjectURL(zipBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `chatgpt-conversations-${new Date().toISOString().split('T')[0]}.zip`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            // Track ZIP download success
            const zipTime = Date.now() - zipStartTime;
            telemetry.trackFilesSaved('zip', this.convertedFiles.length, this.convertedFiles.length, zipTime);
            
            const successMessage = `📦 ${success('FILES_DOWNLOADED')} ${this.convertedFiles.length} files as ZIP archive`;
            this.showSuccess(successMessage);
            accessibilityManager.announceStatus(successMessage, 'success');
            
        } catch (error) {
            logError('Error creating ZIP archive:', error);
            telemetry.trackError('save', error, { type: 'zip_creation', fileCount: this.convertedFiles.length });
            
            const errorMessage = error('ZIP_CREATION_FAILED');
            this.showError(errorMessage);
            accessibilityManager.announceStatus(errorMessage, 'error');
            // Fallback to individual downloads
            this.downloadAllFiles();
        }
    }

    /**
     * Update save button state based on directory selection
     * WHY: Provides visual feedback about readiness to save
     */
    updateSaveButtonState() {
        if (this.uiBuilder) {
            this.uiBuilder.updateSaveButtonState(this.convertedFiles);
        }
    }

    /**
     * Display conversion results with UI
     * WHY: Shows results and provides download/save options
     * 
     * @param {Object} results - Conversion results
     */
    displayResults(results) {
        const resultsDiv = document.getElementById('results');
        const downloadList = document.getElementById('downloadList');
        
        if (!resultsDiv || !downloadList) return;
        
        resultsDiv.classList.remove('hidden');
        downloadList.innerHTML = '';
        
        // Add summary card
        const summaryCard = this.uiBuilder.createResultsSummaryCard(results);
        downloadList.appendChild(summaryCard);
        
        if (results.files.length > 0) {
            // Add directory selection card with callbacks
            const directoryCard = this.uiBuilder.createDirectoryCard(results, {
                onDirectorySelect: () => this.handleDirectorySelection(),
                onSave: () => this.handleLocalSave(),
                onDownloadZip: () => this.downloadAllAsZip()
            });
            downloadList.appendChild(directoryCard);
            
            // Store files for the dedicated Files view (but don't create duplicate table in Results view)
            this.populateFilesView(results);
        }
    }

    /**
     * Populate the dedicated Files view with sorting and pagination
     * WHY: Provides a dedicated interface for browsing individual files
     */
    populateFilesView(results) {
        const filesContainer = document.getElementById('filesContainer');
        const fileTableBody = document.getElementById('fileTableBody');
        const resultsInfo = document.getElementById('resultsInfo');
        const sortSelect = document.getElementById('sortSelect');
        const paginationContainer = document.getElementById('paginationContainer');
        
        if (!filesContainer || !fileTableBody || !resultsInfo) return;
        
        // Show files container
        filesContainer.classList.remove('hidden');
        
        // Store files data for pagination/sorting
        this.allFiles = results.files;
        this.currentPage = 1;
        this.filesPerPage = 10;
        
        // Initialize sort state if not already set
        if (!this.currentSort) {
            this.currentSort = 'date';
            this.sortDirection = 'desc';
        }
        
        // Hide sort dropdown and set up column click handlers
        if (sortSelect) {
            sortSelect.style.display = 'none';
            // Also hide the sort label
            const sortLabel = sortSelect.previousElementSibling;
            if (sortLabel && sortLabel.textContent.includes('Sort by:')) {
                sortLabel.style.display = 'none';
            }
        }
        
        // Set up column header click handlers (only if not already set up)
        if (!this.columnSortingSetup) {
            this.setupColumnSorting();
            this.columnSortingSetup = true;
        }
        
        // Initial render
        this.renderFilesTable();
    }

    /**
     * Create a table row for a file
     * WHY: Extracted method for cleaner code and better maintainability
     */
    createFileRow(file) {
        const row = document.createElement('tr');
        row.className = 'border-b border-gray-200 hover:bg-gray-50 transition-colors';
        
        // Fix date extraction - use multiple possible properties
        const dateCreated = this.getFileDate(file);
        
        // Title column with filename shown as subtitle - FIXED WIDTH to prevent layout shifts
        const titleCell = document.createElement('td');
        titleCell.className = 'px-4 py-3 text-gray-800 font-medium align-top';
        titleCell.style.width = '65%'; // Match header width
        
        const titleContainer = document.createElement('div');
        const titleSpan = document.createElement('div');
        titleSpan.textContent = file.title;
        titleSpan.style.wordBreak = 'break-word'; // Prevent overflow
        
        titleContainer.appendChild(titleSpan);
        titleCell.appendChild(titleContainer);
        
        // Date column - FIXED WIDTH to prevent layout shifts
        const dateCell = document.createElement('td');
        dateCell.className = 'px-4 py-3 text-gray-600 text-sm align-top whitespace-nowrap';
        dateCell.style.width = '20%'; // Match header width
        dateCell.textContent = dateCreated;
        
        // Actions column - FIXED WIDTH to prevent layout shifts
        const actionsCell = document.createElement('td');
        actionsCell.className = 'px-4 py-3 text-right align-top whitespace-nowrap';
        actionsCell.style.width = '15%'; // Match header width
        
        const actionsContainer = document.createElement('div');
        actionsContainer.className = 'flex gap-2 justify-end';
        
        // Always create Save button first, then Download button
        // This maintains consistent layout and allows individual file saving
        const saveBtn = document.createElement('button');
        saveBtn.className = 'bg-indigo-600 hover:bg-indigo-700 text-white px-2 py-1 rounded text-xs flex-shrink-0 transition-colors save-file-btn';
        saveBtn.setAttribute('data-filename', file.filename);
        saveBtn.setAttribute('data-content', encodeURIComponent(file.content));
        saveBtn.setAttribute('data-title', file.title);
        saveBtn.innerHTML = `
            <svg class="icon" style="width: 16px; height: 16px;" viewBox="0 0 24 24">
                <path d="M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z"/>
            </svg>
        `;
        actionsContainer.appendChild(saveBtn);
        
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'bg-gray-500 hover:bg-gray-600 text-white px-2 py-1 rounded text-xs flex-shrink-0 transition-colors download-file-btn';
        downloadBtn.setAttribute('data-filename', file.filename);
        downloadBtn.setAttribute('data-content', encodeURIComponent(file.content));
        downloadBtn.innerHTML = `
            <svg class="icon" style="width: 16px; height: 16px;" viewBox="0 0 24 24">
                <path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z"/>
            </svg>
        `;
        
        actionsContainer.appendChild(downloadBtn);
        
        actionsCell.appendChild(actionsContainer);
        
        row.appendChild(titleCell);
        row.appendChild(dateCell);
        row.appendChild(actionsCell);
        
        return row;
    }

    /**
     * Render the files table with current page of files
     * WHY: Displays paginated file list with sorting capabilities
     */
    renderFilesTable() {
        const fileTableBody = document.getElementById('fileTableBody');
        const resultsInfo = document.getElementById('resultsInfo');
        const paginationContainer = document.getElementById('paginationContainer');
        
        if (!fileTableBody) {
            logWarn('⚠️ File table body not found');
            return;
        }
        
        if (!this.allFiles || this.allFiles.length === 0) {
            logWarn('⚠️ No files available to render');
            
            // Clear table and show no files message
            fileTableBody.innerHTML = '';
            if (resultsInfo) {
                resultsInfo.textContent = 'No files available';
            }
            if (paginationContainer) {
                paginationContainer.innerHTML = '';
            }
            return;
        }
        
        // Sort files
        const sortedFiles = this.sortFiles([...this.allFiles]);
        
        // Calculate pagination
        const totalFiles = sortedFiles.length;
        const totalPages = Math.ceil(totalFiles / this.filesPerPage);
        const startIndex = (this.currentPage - 1) * this.filesPerPage;
        const endIndex = Math.min(startIndex + this.filesPerPage, totalFiles);
        const currentFiles = sortedFiles.slice(startIndex, endIndex);
        
        // Update results info
        if (resultsInfo) {
            resultsInfo.textContent = `Showing ${startIndex + 1}-${endIndex} of ${totalFiles} files`;
        }
        
        // Store current scroll position to maintain user's position
        const container = fileTableBody.closest('.card-content');
        const scrollTop = container ? container.scrollTop : 0;
        
        // Clear table body 
        fileTableBody.innerHTML = '';
        
        // Render current page files
        currentFiles.forEach(file => {
            const row = this.uiBuilder.createFileRow(file);
            fileTableBody.appendChild(row);
        });
        
        // Restore scroll position
        if (container) {
            container.scrollTop = scrollTop;
        }
        
        // Add event listeners to buttons
        this.attachFileButtonHandlers();
        
        // Update sort indicators after DOM is updated
        this.updateSortIndicators();
        
        // Render pagination
        this.renderPagination(totalPages);
        
        logInfo(`✅ Files table rendered: ${currentFiles.length} files on page ${this.currentPage} of ${totalPages}`);
    }

    /**
     * Set up column header click handlers for sorting
     * WHY: Provides natural table sorting interface
     */
    setupColumnSorting() {
        const titleHeader = document.getElementById('titleHeader');
        const dateHeader = document.getElementById('dateHeader');
        
        logDebug('🔧 Setting up column sorting...', { titleHeader: !!titleHeader, dateHeader: !!dateHeader });
        
        // Remove existing listeners to prevent duplicates
        if (titleHeader) {
            titleHeader.removeEventListener('click', this._titleSortHandler);
            titleHeader.removeEventListener('mouseenter', this._titleMouseEnterHandler);
            titleHeader.removeEventListener('mouseleave', this._titleMouseLeaveHandler);
            
            // Create bound handlers to ensure proper removal
            this._titleSortHandler = () => this.handleColumnSort('title');
            this._titleMouseEnterHandler = () => {
                titleHeader.classList.add('bg-gray-100');
            };
            this._titleMouseLeaveHandler = () => {
                titleHeader.classList.remove('bg-gray-100');
            };
            
            titleHeader.addEventListener('click', this._titleSortHandler);
            titleHeader.style.transition = 'background-color 0.2s ease';
            titleHeader.addEventListener('mouseenter', this._titleMouseEnterHandler);
            titleHeader.addEventListener('mouseleave', this._titleMouseLeaveHandler);
            logDebug('✅ Title header click listener attached');
        }
        
        if (dateHeader) {
            dateHeader.removeEventListener('click', this._dateSortHandler);
            dateHeader.removeEventListener('mouseenter', this._dateMouseEnterHandler);
            dateHeader.removeEventListener('mouseleave', this._dateMouseLeaveHandler);
            
            // Create bound handlers to ensure proper removal
            this._dateSortHandler = () => this.handleColumnSort('date');
            this._dateMouseEnterHandler = () => {
                dateHeader.classList.add('bg-gray-100');
            };
            this._dateMouseLeaveHandler = () => {
                dateHeader.classList.remove('bg-gray-100');
            };
            
            dateHeader.addEventListener('click', this._dateSortHandler);
            dateHeader.style.transition = 'background-color 0.2s ease';
            dateHeader.addEventListener('mouseenter', this._dateMouseEnterHandler);
            dateHeader.addEventListener('mouseleave', this._dateMouseLeaveHandler);
            logDebug('✅ Date header click listener attached');
        }
        
        // Initial sort state - set date as default descending (only if not already set)
        if (!this.currentSort) {
            this.currentSort = 'date';
            this.sortDirection = 'desc';
        }
        
        // Update sort indicators
        this.updateSortIndicators();
    }

    /**
     * Handle column sort when user clicks on table headers
     * WHY: Provides natural table sorting interface
     */
    handleColumnSort(column) {
        logDebug(`🔄 Column sort clicked: ${column}, current: ${this.currentSort}, direction: ${this.sortDirection}`);
        
        const previousColumn = this.currentSort;
        
        if (this.currentSort === column) {
            // Same column - toggle direction
            this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
            logDebug(`↕️ Toggling sort direction for ${column}: ${this.sortDirection}`);
        } else {
            // Different column - set new sort and default to ascending
            this.currentSort = column;
            this.sortDirection = 'asc';
            logDebug(`🔄 Switching to new column ${column}: ${this.sortDirection}`);
        }
        
        // Only reset to first page when changing columns, not when toggling direction
        if (previousColumn !== column) {
            this.currentPage = 1;
        }
        
        // Re-render table with new sort
        this.renderFilesTable();
    }

    /**
     * Update visual sort indicators in table headers
     * WHY: Shows users which column is active and sort direction
     */
    updateSortIndicators() {
        const titleIndicator = document.querySelector('#titleHeader .sort-indicator');
        const dateIndicator = document.querySelector('#dateHeader .sort-indicator');
        
        logDebug('🎨 Updating sort indicators...', { 
            currentSort: this.currentSort, 
            sortDirection: this.sortDirection,
            titleIndicator: !!titleIndicator,
            dateIndicator: !!dateIndicator 
        });
        
        if (!titleIndicator || !dateIndicator) {
            logWarn('⚠️ Sort indicators not found in DOM');
            return;
        }
        
        // Reset all indicators to inactive state (hide arrows)
        titleIndicator.className = 'text-gray-400';
        dateIndicator.className = 'text-gray-400';
        titleIndicator.textContent = '';
        dateIndicator.textContent = '';
        
        // Set active indicator with correct direction
        const activeIndicator = this.currentSort === 'title' ? titleIndicator : dateIndicator;
        activeIndicator.className = 'text-indigo-600';
        activeIndicator.textContent = this.sortDirection === 'asc' ? '▲' : '▼';
        
        logDebug(`✨ Active sort: ${this.currentSort} ${this.sortDirection === 'asc' ? '(ascending)' : '(descending)'}`);
    }

    /**
     * Get valid timestamp for sorting, treating invalid values as 0
     * WHY: Ensures consistent sorting behavior for invalid date values
     * 
     * @param {*} timestamp - Raw timestamp value
     * @returns {number} - Valid timestamp or 0 for invalid values
     */
    getValidTimestamp(timestamp) {
        if (timestamp && !isNaN(timestamp) && timestamp > 0) {
            try {
                const date = new Date(timestamp * 1000);
                // Check if date is valid
                if (!isNaN(date.getTime())) {
                    return timestamp;
                }
            } catch (error) {
                logWarn('Error validating timestamp:', error);
            }
        }
        return 0;
    }

    /**
     * Get properly formatted date from file object
     * WHY: Handles different date property names and formats consistently
     */
    getFileDate(file) {
        if (!file || typeof file !== 'object') {
            return 'Unknown';
        }
        
        // Try different possible date properties
        const createTime = file.createTime || file.create_time;
        
        if (createTime && !isNaN(createTime) && createTime > 0) {
            try {
                const date = new Date(createTime * 1000);
                // Check if date is valid
                if (!isNaN(date.getTime())) {
                    return date.toLocaleDateString();
                }
            } catch (error) {
                logWarn('Error formatting date:', error);
            }
        }
        
        // Fallback to createdDate if available
        if (file.createdDate && file.createdDate !== 'Unknown' && typeof file.createdDate === 'string') {
            return file.createdDate;
        }
        
        return 'Unknown';
    }

    /**
     * Sort files based on current criteria
     * WHY: Allows users to organize files by name or date with natural sorting
     */
    sortFiles(files) {
        return files.sort((a, b) => {
            let aValue, bValue;
            
            if (this.currentSort === 'title') {
                // Natural string sorting - case insensitive
                aValue = (a.title || a.filename || '').toLowerCase().trim();
                bValue = (b.title || b.filename || '').toLowerCase().trim();
                
                // Handle natural sorting for numbers in titles
                if (this.sortDirection === 'asc') {
                    return aValue.localeCompare(bValue, undefined, { numeric: true, sensitivity: 'base' });
                } else {
                    return bValue.localeCompare(aValue, undefined, { numeric: true, sensitivity: 'base' });
                }
            } else if (this.currentSort === 'date') {
                // Sort by timestamp for accurate chronological ordering
                // Handle invalid dates by treating them as 0
                aValue = this.getValidTimestamp(a.createTime || a.create_time);
                bValue = this.getValidTimestamp(b.createTime || b.create_time);
                
                if (this.sortDirection === 'asc') {
                    return aValue - bValue;
                } else {
                    return bValue - aValue;
                }
            }
            
            return 0;
        });
    }

    /**
     * Render pagination controls
     * WHY: Provides navigation for large numbers of files
     */
    renderPagination(totalPages) {
        const paginationContainer = document.getElementById('paginationContainer');
        if (!paginationContainer || totalPages <= 1) {
            if (paginationContainer) paginationContainer.innerHTML = '';
            return;
        }
        
        paginationContainer.innerHTML = '';
        
        const maxButtons = 7;
        let startPage = Math.max(1, this.currentPage - Math.floor(maxButtons / 2));
        let endPage = Math.min(totalPages, startPage + maxButtons - 1);
        
        // Adjust start if we're near the end
        if (endPage - startPage + 1 < maxButtons) {
            startPage = Math.max(1, endPage - maxButtons + 1);
        }
        
        // First button (only show if not on first page and there are many pages)
        if (this.currentPage > 1 && totalPages > 5) {
            const firstBtn = this.createPaginationButton('«', 1);
            paginationContainer.appendChild(firstBtn);
        }
        
        // Previous button
        if (this.currentPage > 1) {
            const prevBtn = this.createPaginationButton('‹', this.currentPage - 1);
            paginationContainer.appendChild(prevBtn);
        }
        
        // Page number buttons
        for (let i = startPage; i <= endPage; i++) {
            const pageBtn = this.createPaginationButton(i.toString(), i, i === this.currentPage);
            paginationContainer.appendChild(pageBtn);
        }
        
        // Next button
        if (this.currentPage < totalPages) {
            const nextBtn = this.createPaginationButton('›', this.currentPage + 1);
            paginationContainer.appendChild(nextBtn);
        }
        
        // Last button (only show if not on last page and there are many pages)
        if (this.currentPage < totalPages && totalPages > 5) {
            const lastBtn = this.createPaginationButton('»', totalPages);
            paginationContainer.appendChild(lastBtn);
        }
    }

    /**
     * Create pagination button
     * WHY: Creates consistent pagination button styling and behavior
     */
    createPaginationButton(text, page, isActive = false) {
        const button = document.createElement('button');
        button.textContent = text;
        button.className = `btn ${isActive ? 'btn-primary' : 'btn-secondary'}`;
        button.style.padding = 'var(--space-2) var(--space-3)';
        button.style.fontSize = 'var(--font-size-sm)';
        button.style.minWidth = '40px';
        
        if (!isActive) {
            button.addEventListener('click', () => {
                this.currentPage = page;
                this.renderFilesTable();
            });
        }
        
        return button;
    }

    /**
     * Attach event handlers to file action buttons
     * WHY: Enables download and save functionality for individual files
     */
    attachFileButtonHandlers() {
        // Download buttons
        document.querySelectorAll('.download-file-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const filename = btn.dataset.filename;
                const content = decodeURIComponent(btn.dataset.content);
                
                // Create file object and use the proper download method
                const file = {
                    filename: filename,
                    content: content
                };
                
                this.downloadSingleFile(file);
            });
        });

        // Save buttons - use individual file save method that lets user pick folder
        document.querySelectorAll('.save-file-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                const filename = btn.dataset.filename;
                const content = decodeURIComponent(btn.dataset.content);
                const title = btn.dataset.title;
                
                // Create file object for the save method
                const file = {
                    filename: filename,
                    content: content,
                    title: title
                };
                
                // Use the dedicated individual file save method
                await this.saveSingleFileToMarkdown(file);
            });
        });
    }

    /**
     * Show success message
     * WHY: Provides feedback when files are saved successfully
     */
    showSuccessMessage(message) {
        // Create temporary success message
        const successDiv = document.createElement('div');
        successDiv.className = 'status success';
        successDiv.style.position = 'fixed';
        successDiv.style.top = 'var(--space-4)';
        successDiv.style.right = 'var(--space-4)';
        successDiv.style.zIndex = '1000';
        successDiv.style.maxWidth = '300px';
        successDiv.textContent = message;
        
        document.body.appendChild(successDiv);
        
        // Remove after 3 seconds
        setTimeout(() => {
            if (successDiv.parentNode) {
                successDiv.remove();
            }
        }, 3000);
    }

    /**
     * Create results summary element
     * WHY: Provides clear feedback about conversion results
     */
    createResultsSummary(results) {
        const summary = document.createElement('div');
        summary.innerHTML = `
            <h4>📊 Conversion Summary</h4>
            <p>✅ Converted: ${results.processed} conversations</p>
            ${results.errors > 0 ? `<p>❌ Errors: ${results.errors} conversations</p>` : ''}
        `;
        summary.style.marginBottom = '20px';
        return summary;
    }

    /**
     * Create summary card for results
     * WHY: Displays conversion statistics in a clean card format
     */
    createResultsSummaryCard(results) {
        const card = document.createElement('div');
        card.className = 'bg-white rounded-xl shadow-md p-6 mb-8';
        
        const header = document.createElement('div');
        header.className = 'mb-4';
        
        const title = document.createElement('h3');
        title.className = 'text-xl font-medium text-gray-800 flex items-center mb-2';
        title.innerHTML = `
            <i class="fas fa-check-circle mr-3 text-green-500"></i>
            Conversion Summary
        `;
        
        const description = document.createElement('p');
        description.className = 'text-gray-600';
        description.textContent = 'Your ChatGPT conversations have been successfully converted';
        
        header.appendChild(title);
        header.appendChild(description);
        
        const content = document.createElement('div');
        content.className = '';
        
        const stats = document.createElement('div');
        stats.className = 'flex justify-center gap-4';
        
        // Create stat items - simplified to show only the main conversion result
        const statItems = [
            { label: 'Conversations Converted', value: results.processed, icon: 'M12,3C6.5,3 2,6.58 2,11A7.18,7.18 0 0,0 2.24,12.65C2.09,13.6 2,14.62 2,15.68C2,17.68 2.5,19.5 3.5,21L12,12.5C12,12.33 12,12.17 12,12A1,1 0 0,1 13,11A1,1 0 0,1 14,12C14,12.17 14,12.33 14,12.5L22.5,21C23.5,19.5 24,17.68 24,15.68C24,14.62 23.91,13.6 23.76,12.65A7.18,7.18 0 0,0 24,11C24,6.58 19.5,3 14,3H12Z' }
        ];
        
        // Only show errors if there were any
        if (results.errors > 0) {
            statItems.push({ label: 'Errors', value: results.errors, icon: 'M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z' });
        }
        
        statItems.forEach(item => {
            const statCard = document.createElement('div');
            statCard.className = 'bg-gray-50 p-6 rounded-lg text-center min-w-[200px]';
            
            // Use Font Awesome icon instead of SVG
            const iconClass = item.label.includes('Error') ? 'fas fa-exclamation-triangle text-red-500' : 'fas fa-comments text-indigo-500';
            
            statCard.innerHTML = `
                <i class="${iconClass} text-3xl mb-3 block"></i>
                <div class="text-2xl font-bold text-gray-800 mb-2">${item.value}</div>
                <div class="text-base text-gray-600">${item.label}</div>
            `;
            
            stats.appendChild(statCard);
        });
        
        content.appendChild(stats);
        card.appendChild(header);
        card.appendChild(content);
        
        return card;
    }

    /**
     * Create directory selection card
     * WHY: Provides local save options with clear instructions in card format
     */
    createDirectoryCard(results) {
        const card = document.createElement('div');
        card.className = 'bg-white rounded-xl shadow-md p-6 mb-8';
        
        const header = document.createElement('div');
        header.className = 'mb-4';
        
        const title = document.createElement('h3');
        title.className = 'text-xl font-medium text-gray-800 flex items-center mb-2';
        title.innerHTML = `
            <i class="fas fa-folder mr-3 text-indigo-500"></i>
            Save Location
        `;
        
        const description = document.createElement('p');
        description.className = 'text-gray-600';
        description.textContent = 'Choose where to save your converted files';
        
        header.appendChild(title);
        header.appendChild(description);
        
        const content = document.createElement('div');
        content.className = '';
        
        if (isFileSystemAccessSupported()) {
            // Directory selection buttons
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'flex flex-col gap-3 mb-4';
            
            const selectBtn = this.createDirectoryButton();
            const saveBtn = this.createSaveButton(results);
            
            buttonGroup.appendChild(selectBtn);
            buttonGroup.appendChild(saveBtn);
            content.appendChild(buttonGroup);
            
            // Instructions
            const instructions = this.createInstructions();
            content.appendChild(instructions);
            
        } else {
            const apiInfo = getFileSystemAccessInfo();
            const warning = this.createUnsupportedWarning();
            content.appendChild(warning);
            
            // Add prominent download button for mobile users
            if (apiInfo.mobile) {
                const downloadSection = document.createElement('div');
                downloadSection.className = 'mt-4';
                
                const downloadTitle = document.createElement('h4');
                downloadTitle.className = 'text-lg font-medium text-gray-800 mb-3 flex items-center';
                downloadTitle.innerHTML = `
                    <i class="fas fa-download mr-2 text-indigo-500"></i>
                    Download Options
                `;
                
                const downloadButton = document.createElement('button');
                downloadButton.className = 'bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-4 px-6 rounded-lg transition-colors w-full mb-3 flex items-center justify-center';
                downloadButton.innerHTML = `
                    <i class="fas fa-download mr-3"></i>
                    Download All as ZIP
                `;
                downloadButton.onclick = () => this.downloadAllAsZip();
                
                const downloadInfo = document.createElement('p');
                downloadInfo.className = 'text-sm text-gray-600 mb-3';
                downloadInfo.textContent = 'Download all converted files as a single ZIP archive for easy file management.';
                
                downloadSection.appendChild(downloadTitle);
                downloadSection.appendChild(downloadInfo);
                downloadSection.appendChild(downloadButton);
                
                content.appendChild(downloadSection);
            }
        }
        
        card.appendChild(header);
        card.appendChild(content);
        
        return card;
    }







    /**
     * Create directory selection button
     * WHY: Primary directory selection interface
     */
    createDirectoryButton() {
        const btn = document.createElement('button');
        btn.className = 'bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-lg transition-colors flex items-center';
        btn.innerHTML = this.selectedDirectoryHandle ? 
            `<i class="fas fa-folder-open mr-2"></i>Change Directory (Current: ${this.selectedDirectoryHandle.name})` : 
            '<i class="fas fa-folder mr-2"></i>Choose Folder';
        btn.onclick = () => this.handleDirectorySelection();
        return btn;
    }



    /**
     * Create save to local folder button
     * WHY: Main save action with visual feedback
     */
    createSaveButton(results) {
        const btn = document.createElement('button');
        btn.className = this.selectedDirectoryHandle ? 
            'bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-3 px-6 rounded-lg transition-colors flex items-center justify-center' :
            'bg-gray-300 text-gray-500 font-medium py-3 px-6 rounded-lg cursor-not-allowed flex items-center justify-center';
        btn.innerHTML = this.selectedDirectoryHandle ? 
            `<i class="fas fa-save mr-2"></i>Save ${results.files.length} files to selected folder` : 
            '<i class="fas fa-save mr-2"></i>Save to Local Folder (Select folder first)';
        btn.disabled = !this.selectedDirectoryHandle;
        btn.onclick = () => this.handleLocalSave();
        
        // Store reference for updates
        this.saveLocalButton = btn;
        
        return btn;
    }

    /**
     * Create instructions element
     * WHY: Provides clear guidance for saving files
     */
    createInstructions() {
        const instructions = document.createElement('div');
        instructions.className = 'mt-3 text-sm text-gray-600 leading-normal';
        
        if (this.selectedDirectoryHandle) {
            instructions.innerHTML = `
                <div class="bg-green-50 border-l-4 border-green-500 p-3 rounded">
                    <div class="flex">
                        <div class="flex-shrink-0">
                            <i class="fas fa-check-circle text-green-500"></i>
                        </div>
                        <div class="ml-3">
                            <p class="text-sm text-green-700">
                                <strong>Ready to save</strong><br>
                                Selected folder: <strong>${this.selectedDirectoryHandle.name}</strong><br>
                                Click "Save to Local Folder" to save all files directly to your chosen location.
                            </p>
                        </div>
                    </div>
                </div>
            `;
        } else {
            instructions.innerHTML = `
                <div class="bg-blue-50 border-l-4 border-blue-500 p-3 rounded">
                    <div class="flex">
                        <div class="flex-shrink-0">
                            <i class="fas fa-info-circle text-blue-500"></i>
                        </div>
                        <div class="ml-3">
                            <p class="text-sm text-blue-700">
                                <strong>Select your destination folder</strong><br>
                                Choose where you want to save your converted Markdown files.
                            </p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        return instructions;
    }

    /**
     * Create unsupported API warning
     * WHY: Informs users when File System Access API is unavailable
     */
    createUnsupportedWarning() {
        const apiInfo = getFileSystemAccessInfo();
        const warning = document.createElement('div');
        warning.className = 'bg-yellow-50 border-l-4 border-yellow-500 p-4 rounded mb-4';
        
        let message = 'Your browser doesn\'t support direct folder saving. ';
        
        if (apiInfo.mobile) {
            if (apiInfo.ios) {
                message += 'On iOS devices, use the download options below to save your files. You can then move them to your preferred folder using the Files app.';
            } else {
                message += 'On mobile devices, use the download options below to save your files.';
            }
        } else {
            message += 'Use the download options below to save your files.';
        }
        
        warning.innerHTML = `
            <div class="flex items-start space-x-3">
                <div class="flex-shrink-0">
                    <i class="fas fa-exclamation-triangle text-yellow-500 mt-1"></i>
                </div>
                <div>
                    <strong class="block mb-2 text-yellow-800">Mobile Browser Detected</strong>
                    <p class="text-yellow-700 leading-normal mb-0">${message}</p>
                    ${apiInfo.mobile ? `
                        <div class="mt-3 p-3 bg-blue-50 border border-blue-200 rounded">
                            <strong class="block mb-1 text-blue-800"><i class="fas fa-lightbulb mr-1"></i>Mobile Tip:</strong>
                            <p class="text-blue-700 text-sm mb-0">Download all files as a ZIP archive for easier file management on your device.</p>
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
        
        return warning;
    }

    /**
     * Show success message
     * WHY: Provides positive feedback
     */
    showSuccess(message) {
        this.showStatusMessage(message, 'success');
    }

    /**
     * Show info message
     * WHY: Provides informational feedback
     */
    showInfo(message) {
        this.showStatusMessage(message, 'info');
    }

    /**
     * Show error message
     * WHY: Provides error feedback
     */
    showError(message) {
        this.showStatusMessage(message, 'error');
    }

    /**
     * Show file save confirmation dialog
     * WHY: Provides clear visual confirmation when individual files are saved
     */
    showFileSaveConfirmation(fileTitle, folderName, filename) {
        // Create confirmation dialog
        const dialog = document.createElement('div');
        dialog.className = 'file-save-confirmation-dialog';
        dialog.innerHTML = `
            <div class="dialog-overlay">
                <div class="dialog-content">
                    <div class="success-icon">✅</div>
                    <h3>File Saved Successfully!</h3>
                    <p><strong>${fileTitle}</strong> has been saved to the <strong>${folderName}</strong> folder.</p>
                    <p class="filename">Filename: <code>${filename}</code></p>
                    <div class="dialog-buttons">
                        <button class="btn btn-primary ok-btn">OK</button>
                    </div>
                </div>
            </div>
        `;
        
        // Add dialog styles
        const style = document.createElement('style');
        style.textContent = `
            .file-save-confirmation-dialog .dialog-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                backdrop-filter: blur(2px);
            }
            .file-save-confirmation-dialog .dialog-content {
                background: #2a2a2a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 32px;
                max-width: 450px;
                width: 90%;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
                position: relative;
                text-align: center;
            }
            .file-save-confirmation-dialog .success-icon {
                font-size: 48px;
                margin-bottom: 16px;
                animation: bounce 0.6s ease-in-out;
            }
            .file-save-confirmation-dialog h3 {
                margin: 0 0 20px 0;
                color: #ffffff;
                font-size: 20px;
                font-weight: 600;
            }
            .file-save-confirmation-dialog p {
                margin: 0 0 16px 0;
                color: #cccccc;
                line-height: 1.6;
                font-size: 15px;
            }
            .file-save-confirmation-dialog .filename {
                background: #1a1a1a;
                border: 1px solid #333;
                border-radius: 6px;
                padding: 12px;
                margin: 16px 0;
                font-family: monospace;
                font-size: 13px;
            }
            .file-save-confirmation-dialog .filename code {
                color: #4CAF50;
                background: #1a1a1a;
                padding: 2px 6px;
                border-radius: 3px;
            }
            .file-save-confirmation-dialog .dialog-buttons {
                display: flex;
                justify-content: center;
                margin-top: 24px;
            }
            .file-save-confirmation-dialog .btn {
                padding: 12px 24px;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                font-weight: 500;
                transition: all 0.2s ease;
                min-width: 80px;
            }
            .file-save-confirmation-dialog .btn-primary {
                background: #007acc;
                color: #ffffff;
            }
            .file-save-confirmation-dialog .btn-primary:hover {
                background: #0066aa;
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(0, 122, 204, 0.3);
            }
            @keyframes bounce {
                0%, 20%, 50%, 80%, 100% {
                    transform: translateY(0);
                }
                40% {
                    transform: translateY(-10px);
                }
                60% {
                    transform: translateY(-5px);
                }
            }
        `;
        
        // Add to document
        document.head.appendChild(style);
        document.body.appendChild(dialog);
        
        // Get button reference
        const okBtn = dialog.querySelector('.ok-btn');
        
        // Handle button click and cleanup
        const cleanup = () => {
            try {
                if (dialog.parentNode) {
                    document.body.removeChild(dialog);
                }
                if (style.parentNode) {
                    document.head.removeChild(style);
                }
            } catch (error) {
                logWarn('⚠️ Error cleaning up confirmation dialog:', error);
            }
        };
        
        okBtn.addEventListener('click', cleanup);
        
        // Handle escape key
        const handleKeyDown = (event) => {
            if (event.key === 'Escape' || event.key === 'Enter') {
                document.removeEventListener('keydown', handleKeyDown);
                cleanup();
            }
        };
        document.addEventListener('keydown', handleKeyDown);
        
        // Focus the OK button
        setTimeout(() => okBtn.focus(), 100);
        
        // Auto-close after 5 seconds
        setTimeout(() => {
            if (dialog.parentNode) {
                cleanup();
            }
        }, 5000);
    }

    /**
     * Show status message in UI
     * WHY: Centralizes status message display
     */
    showStatusMessage(message, type) {
        if (this.progressDisplay && this.progressDisplay.isVisible) {
            // Use the correct methods that exist on ProgressDisplay
            if (type === 'error') {
                this.progressDisplay.showError(message);
            } else {
                // For info/success messages, use updateProgress with current or max percentage
                this.progressDisplay.updateProgress(100, message);
            }
        } else {
            // Fallback: log to console
            logInfo(`${type.toUpperCase()}: ${message}`);
        }
    }

    /**
     * Helper method to create delays for better UX
     * WHY: Creates artificial delays to make processing feel more substantial
     * 
     * @param {number} ms - Milliseconds to delay
     * @returns {Promise} - Promise that resolves after the delay
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * Reset application state
     * WHY: Allows for multiple conversions in same session
     */
    reset() {
        this.convertedFiles = [];
        this.processedIds.clear();
        this.selectedDirectoryHandle = null;
        this.saveLocalButton = null;
        
        // Hide results
        const resultsDiv = document.getElementById('results');
        if (resultsDiv) {
            resultsDiv.style.display = 'none';
        }
    }
}
</file>

</files>
